[[zifencei]]
== "Zifencei" 指令获取屏障扩展，版本 2.0

本章定义了 "Zifencei" 扩展，其中包括 FENCE.I 指令，该指令提供了在同一 hart 上对指令内存写入和指令获取之间的显式同步。
目前，这条指令是确保 hart 可见的存储也对其指令获取可见的唯一标准机制。

[NOTE]
====
我们考虑过但没有包括 "存储指令字" 指令，如 cite:[majc] 中所述。JIT 编译器可能会在单个 FENCE.I 之前生成大量指令，并通过将翻译后的指令写入已知不驻留在 I-cache 中的内存区域来摊销任何指令缓存嗅探/失效的开销。
====

[TIP]
====
FENCE.I 指令设计用于支持各种实现。一个简单的实现可以在执行 FENCE.I 时刷新本地指令缓存和指令流水线。一个更复杂的实现可能会在每次数据（指令）缓存未命中时嗅探指令（数据）缓存，或者使用包含的统一私有 L2 缓存在本地存储指令写入时使主指令缓存中的行失效。如果指令和数据缓存以这种方式保持一致，或者如果内存系统仅由未缓存的 RAM 组成，那么在 FENCE.I 时只需要刷新获取流水线。

FENCE.I 指令以前是基本 I 指令集的一部分。两个主要问题推动了将其移出强制性基础，尽管在撰写本文时，它仍然是维护指令获取一致性的唯一标准方法。

首先，已经认识到在某些系统上，FENCE.I 的实现成本很高，并且在内存模型任务组中正在讨论替代机制。特别是对于具有不一致的指令缓存和不一致的数据缓存的设计，或者指令缓存填充不嗅探一致的数据缓存的设计，当遇到 FENCE.I 指令时，必须完全刷新两个缓存。当在统一缓存或外部内存系统前面有多个级别的 I 和 D 缓存时，这个问题会更加严重。

其次，该指令不足以在类 Unix 操作系统环境中以用户级别提供。FENCE.I 仅同步本地 hart，操作系统可以在 FENCE.I 之后将用户 hart 重新调度到不同的物理 hart。这将要求操作系统在每次上下文迁移时执行额外的 FENCE.I。因此，标准的 Linux ABI 已经从用户级别移除了 FENCE.I，现在需要系统调用来维护指令获取一致性，这允许操作系统在当前系统上最小化所需的 FENCE.I 执行次数，并提供与未来改进的指令获取一致性机制的前向兼容性。

正在讨论的未来指令获取一致性方法包括提供仅针对 _rs1_ 中指定地址的 FENCE.I 的更受限制版本，和/或允许软件使用依赖于机器模式缓存维护操作的 ABI。
====

include::images/wavedrom/zifencei-ff.adoc[]
[[zifencei-ff]]
//.FENCE.I 指令
(((FENCE.I，同步)))

FENCE.I 指令用于同步指令和数据流。RISC-V 不保证对指令内存的存储在 RISC-V hart 上的指令获取中可见，直到该 hart 执行 FENCE.I 指令。FENCE.I 指令确保 RISC-V hart 上的后续指令获取将看到已经对同一 RISC-V hart 可见的任何先前数据存储。FENCE.I 不确保其他 RISC-V hart 的指令获取将在多处理器系统中观察到本地 hart 的存储。为了使对指令内存的存储对所有 RISC-V hart 可见，写入 hart 还必须在请求所有远程 RISC-V hart 执行 FENCE.I 之前执行数据 FENCE。

FENCE.I 指令中未使用的字段 _imm[11:0]_、_rs1_ 和 _rd_ 保留用于将来的更细粒度的屏障。为了前向兼容性，基本实现应忽略这些字段，标准软件应将这些字段置零。
(((FENCE.I，更细粒度)))
(((FENCE.I，前向兼容性)))

[NOTE]
====
由于 FENCE.I 仅对 hart 自己的指令获取排序，应用程序代码应仅在应用程序线程不会迁移到不同 hart 时依赖 FENCE.I。EEI 可以提供用于高效多处理器指令流同步的机制。
====
