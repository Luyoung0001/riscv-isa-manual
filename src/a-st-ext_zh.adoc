[[atomics]]
== "A" 扩展:  原子指令，版本 2.1


原子指令扩展称为" A "扩展，包含了原子读-修改-写内存的指令，以支持在同一内存空间中运行的多个 
RISC-V 处理器硬件线程之间的同步。提供的两种原子指令形式是：保留加载/条件存储指令和原子取值与
操作内存指令。两种原子指令都支持多种内存一致性顺序，包括无序、一致性获取、一致性释放和顺序一致
性语义。这些指令使 RISC-V 能够支持 RCsc 内存一致性模型。 cite:[Gharachorloo90memoryconsistency]

[NOTE]
====
经过广泛的讨论，语言社区和架构社区最终决定将释放一致性作为标准的内存一致性模型，因此 RISC-V 
的原子支持是围绕这一模型构建的。
====

A 扩展包括 Zaamo 扩展和 Zalrsc 扩展所提供的指令。

=== 用于确定访问顺序的原子指令

基础 RISC-V 指令集采用了松散的内存模型，通过 FENCE 指令来保证额外的顺序约束。地址空间由执行
环境划分为内存和 I/O 两个域，FENCE 指令提供了对这两个地址域访问的顺序控制选项。

为了更高效地支持释放一致性（参考文献：[Gharachorloo90memoryconsistency]），每条原子指令都有两个位，aq_ 和 _rl，
用于指定其他 RISC-V 硬件线程视图中的额外内存顺序约束。这些位用来控制对两个地址域之一（内存
或 I/O）的访问顺序，具体取决于原子指令正在访问哪个地址域。对于访问另一个域的操作，不会强加
顺序约束，若需要在两个域之间进行顺序控制，应使用 FENCE 指令。

如果两个位的值均为 0，则不会对原子内存操作施加额外的顺序约束。如果仅有 _aq_ 位的值为 1，
则该原子内存操作被视为“获取”（acquire）访问，即，在此 RISC-V 核心上的任何后续内存操作都
不能被看作是在获取内存操作之前发生的。如果仅有 _rl_ 位的值为 1，则该原子内存操作被视为“释放”
（release）访问，即，释放内存操作不能被看作是在任何较早的内存操作之前发生的。如果 _aq_ 和 
_rl_两个位的值同时为 1，则该原子内存操作是“顺序一致”的，即，在同一 RISC-V 硬件线程上，不能
观察到这条指令在任何较早的内存操作之前或任何较晚的内存操作之后发生，并且这些操作涉及的地址域
必须相同。

[[sec:lrsc]]
=== "Zalrsc" Extension for Load-Reserved/Store-Conditional Instructions

include::images/wavedrom/load-reserve-st-conditional.adoc[]

在单个内存字或双字上的复杂原子内存操作通过加载保留（LR）和条件存储（SC）指令实现。
LR.W 指令从 rs1 所指的地址加载一个字，符号位扩展后放入 rd 寄存器，并设置一个预留集，
这是一个包含了该寻址字所包含所有字节的字节集合。SC.W 指令有条件地将 rs2 中的字写入
rs1 所指的地址：只有当预留仍然有效且预留集包含正在写入的字节时，SC.W才会成功。如果
SC.W 成功，指令会将 rs2 中的字写入内存，并将零写入 rd 。如果 SC.W 失败，指令不会写
入内存，并且会将一个非零值写入 rd。出于内存保护的目的，失败的 SC.W 可以被视作一次存
储操作。无论成功还是失败，执行 SC.W 指令都会使当前硬件线程所持有的任何预留失效。LR.D
和 SC.D 在双字上以类似方式工作，并且仅在 RV64 架构中可用。对于 RV64 ，LR.W 和 SC.W 
都会对放入 rd 中的值进行符号扩展。

[NOTE]
====

比较与交换（CAS）和加载-保留/条件存储（LR/SC）都可以用于构建无锁数据结构。经过深入讨论，
我们最终选择了 LR/SC，主要基于以下几个原因： 1) CAS 存在 ABA 问题，而 LR/SC 则没有。
这是因为 LR/SC 监控的是所有对该地址的写操作，而 CAS 仅检测数据值的变化； 2) CAS 需要
新的整数指令格式，以支持三个源操作数（地址、比较值、交换值），同时也需要不同的内存系统
消息格式，这会增加微架构的复杂性； 3) 为了解决 ABA 问题，其他系统通常提供双宽度 CAS
（DW-CAS），以便在测试和更新数据字的同时增加一个计数器。然而，这需要一次性读取 5 个寄存
器并写入 2 个寄存器，同时还需要新的、更大的内存系统消息格式，使实现更加复杂；4) LR/SC 
在许多原语的实现上更高效，因为它只需要一次加载，而 CAS 需要两次加载（CAS 之前需要先加
载一次以获取值用于预测性计算，然后在 CAS 指令中再加载一次，以检查值是否未变后再进行更新）。

活锁是 LR/SC 相较于 CAS 的主要缺点。不过，在某些情况下，我们通过架构级的改进来确保能够避免
活锁，具体方案如下所述。另一个潜在问题是，当前 x86 架构对 DW-CAS 的依赖可能会使同步库和其
他假设 DW-CAS 为基本原语的软件移植变得困难。但 x86 近期引入了事务性内存（Transactional Memory）
指令，这可能会减少对 DW-CAS 的依赖，在能够一定程度上缓解这一问题。

总体而言，一个支持多字原子的指令原语是理想的，但目前仍然存在大量争论，特别是如何设计一套能够
保证可扩展性的机制，因为这会增加系统的复杂性。

====

错误代码值为1表示非特定的失败。其他错误代码目前保留。可移植的软件应仅假设错误代码将是非零的。

[NOTE]
====
我们保留错误代码 1 表示“非特定”，这样简单的实现可以使用现有的多路复用器返回该值，这些多路复用
器是 SLT/SLTU 指令所需的。更具体的错误代码可能会在未来版本或 ISA 的扩展中定义。
====

对于 LR 和 SC 指令，Zalrsc 扩展要求寄存器 _rs1_ 中保存的地址必须与操作数的大小自然对齐（即，
对于“双字”，要求按8字节对齐；对于“字”，要求按4字节对齐）。如果地址没有自然对齐，将会生成地址
未对齐异常或访问故障异常。如果内存访问本可以完成，但由于未对齐而无法完成，且该未对齐的访问不应
被仿真，则会生成访问故障异常。
[NOTE]
====
在大多数系统中，模拟未对齐的 LR/SC 序列是不可行的。

未对齐的LR/SC序列还可能导致同时访问多个预留集，而现有的定义并未考虑这种情况。

====

在实现中，可以在每次 LR 操作时注册一个任意大的预留集，只要预留集包含了所寻址数据字或双字的所有
字节。SC 只能与程序顺序中的最近的 LR 配对。SC 只有在 LR 和 SC 之间，不能观察到其他处理器对保留
集的存储操作，并且 LR 和 SC 之间没有其他 SC 的情况下，才能成功。SC 只有在 LR 指令访问的字节之
间，未观察到来自硬件线程之外的设备的写操作时，才可以成功。请注意，这个 LR 可能使用不同的有效地址
和数据大小，但仍将 SC 的地址作为预留集的一部分。


[NOTE]
====
遵循这一模型，在带有内存转换的系统中，如果之前执行的 LR 使用不同的虚拟地址通过别名保留了相同的位置，
则 SC 允许成功，但如果虚拟地址不同，则 SC 也可以失败。

为了兼容传统设备和总线，来自 RISC-V 硬件线程以外设备的写操作仅在它们与 LR 访问的字节重叠时才需要
使保留失效。当它们访问保留集中的其他字节时，不需要使保留失效。
====

如果地址不在程序顺序中最近的LR的保留集中，SC 必须失败。如果另一个硬件线程向预留集的存储操作可以在
LR 和 SC 之间被观察到，SC 必须失败。如果某个其他设备向 LR 访问的字节写入数据，并且该写入操作可以
在 LR 和 SC 之间被观察到，SC 必须失败。（如果该设备写入了预留集，但没有写入 LR 访问的字节，SC 可
能会成功，也可能会失败。）如果在程序顺序中，LR 和 SC 之间存在另一个 SC（无论地址是什么），SC 必须
失败。成功的LR/SC序列的原子性要求的精确定义见<<rvwmo>>中的原子性公理。

[NOTE]
====
平台应提供一种方法来确定预留集的大小和形状。

平台规范可能会对预留集的大小和形状进行约束。

对内存的空闲字执行的 SC 指令应该能够强制使任何现有的 LR 失效：

* 在抢占式上下文切换时
* 如果有必要，在更改虚拟地址到物理地址的映射时，例如在迁移可能包含活动保留的页面时。

当一个内核线程执行 LR 或 SC 时，该内核的预留集会失效。这意味着每个硬件线程一次只能持
有一个保留集，并且 SC 只能与程序顺序中的最近 LR 配对，而 LR 与下一个 SC 配对。这是对
<<rvwmo>>中原子性公理的限制，确保软件在这一手册中预期的常见实现中正确运行。
====

一个 SC 指令在另一个 RISC-V 硬件线程上永远不会被观察到，除非在这一 SC 指令之前之前有
一个 LR 指令建立了预留。

[NOTE]
====
LR/SC 序列可以通过在 LR 指令上将 aq 位置为 1 来赋予获取（acquire）语义。通过在 SC 指令上
将 rl 位置为1，LR/SC 序列可以被赋予释放（release）语义。假设对其他原子操作有适当的映射，
在 LR 指令上将 aq 位置位1，并在 SC 指令上将 rl 位置位1，使得 LR/SC 序列在 C++ 的 memory_order_seq_cst 
语义下是顺序一致的。这样的序列不会作为屏障来排序序列前后的普通加载和存储指令。对于其他 C++ 
原子操作的特定指令映射，或者更强的“顺序一致性”概念，可能需要在 LR 或 SC 指令中的任意一条或
两条上将这两个位都置为1。

如果 LR 或 SC 上的这两个为都置为0，则 LR/SC 序列可能会在同一个 RISC-V 硬件线程上被观察到发
生在周围内存操作之前或之后。这在 LR/SC 序列用于实现并行归约操作时可能是合适的。
====

除非 aq 位被置为1，否则软件不应在 LR 指令上将 rl 位置为1；同样，除非 rl 位被置为1，否则软件
不应在 SC 指令上将 aq 位置为1。LR.rl 和 SC.aq 指令并不保证提供比两者都未设置位时更强的排序，
但可能会导致性能降低。

<<<

[[cas]]
[source,asm]
.Sample code for compare-and-swap function using LR/SC.
        # a0 holds address of memory location
        # a1 holds expected value
        # a2 holds desired value
        # a0 holds return value, 0 if successful, !0 otherwise
    cas:
        lr.w t0, (a0)        # Load original value.
        bne t0, a1, fail     # Doesn't match, so fail.
        sc.w t0, a2, (a0)    # Try to update.
        bnez t0, cas         # Retry if store-conditional failed.
        li a0, 0             # Set return to success.
        jr ra                # Return.
    fail:
        li a0, 1             # Set return to failure.
        jr ra                # Return.


LR/SC 可以用来构建无锁数据结构。以下是一个使用 LR/SC 实现比较和交换（compare-and-swap）
功能的示例，见 <<cas>>。在内联情况下，比较和交换功能仅需要四条指令。

[[sec:lrscseq]]
=== SC 指令的最终成功

Zalrsc 扩展定义了受限的 LR/SC 循环，具有以下特点：

该循环仅包含一个 LR/SC 序列和在失败时重试该序列的代码，并且最多只能包含 16 条指令，这些指令
按顺序放置在内存中。一个 LR/SC 序列以 LR 指令开始，并以 SC 指令结束。LR 和 SC 之间执行的动
态代码只能包含来自基本的 ''I'' 指令集的指令，但是除了加载、存储、向后跳转、被执行的向后分支
、JALR、FENCE 和 SYSTEM 指令。如果支持 ''C'' 扩展，那么上述 ''I'' 指令的压缩形式也是允许的。
用于重试失败的 LR/SC 序列的代码可以包含向后跳转和/或分支以重复执行 LR/SC 序列，但在其他方面
与 LR 和 SC 之间的代码具有相同的约束。LR 和 SC 地址必须位于具有 LR/SC 最终性 属性的内存区域内。
执行环境负责传达哪些区域具有该属性。SC 必须与同一硬件线程最近执行的 LR 使用相同的有效地址和
相同的数据大小。

不属于受限 LR/SC 循环的 LR/SC 序列被称为 不受限的。不受限的 LR/SC 序列可能在某些实现上某些尝
试时成功，但在其他实现上可能永远不会成功。

[NOTE]
====
我们将 LR/SC 循环的长度限制位 64 个连续指令字节，这是对基本指令集指令大小的适配，以避免指令缓存
和 TLB 的大小及关联性的过度限制。类似地，我们禁止在循环内进行其他加载和存储操作，以避免在简单实
现中对数据缓存关联性的限制，特别是在这些实现中，预留是通过私有缓存进行跟踪的。对分支和跳转的限
制则限制了在序列中可花费的时间。浮点运算和整数乘除被禁止，以简化操作系统在没有适当硬件支持的实现
上对这些指令的仿真。

软件并不被禁止使用不受限的 LR/SC 序列，但可移植性软件必须检测到序列反复失败的情况，然后退回到不依
赖于不受限 LR/SC 序列的替代代码序列。实现允许在任何不受限的 LR/SC 序列上无条件失败。
====
如果一个硬件线程 H 进入一个受限的 LR/SC 循环，执行环境必须保证最终发生以下事件之一：

* _H_ 或其他硬件线程执行一个成功的 SC 指令，且该 SC 指令操作的是 H 的受限 LR/SC 循环中的预留集。
* 其他硬件线程执行一个无条件的存储或原子内存操作（AMO）指令，且该指令操作的是 _H_ 的受限 LR/SC 
循环中的预留集合，或者系统中的其他设备向该预留集写入数据。
* _H_ 执行一个跳转或分支，退出受限 LR/SC 循环。
* _H_ 触发陷阱。

[NOTE]
====
请注意，这些定义允许在实现中 SC 指令偶尔因任何原因失败，前提是不会违反上述的保证。

由于要保证最终的结构，如果执行环境中的一些硬件线程正在执行受限的 LR/SC 循环，而执行环境中没有其他
硬件现场或设备向该预留集合执行无条件的存储或 AMO 操作，那么至少有一个硬件线程最终会退出其受限的循环。
相比之下，如果其他硬件线程或设备继续向该预留集合写入数据，则无法保证任何硬件线程会退出其 LR/SC 循环。

加载指令和 LR 指令本身不会妨碍其他硬件线程的 LR/SC 序列进展。请注意，这个约束意味着，除了其他事情之
外，由其他硬件线程执行的加载指令和 LR 指令（可能在同一核心内）不能无限期地妨碍 LR/SC 的进展。例如，
由于另一个硬件线程共享缓存导致的缓存驱逐不能无限期地妨碍 LR/SC 的进展。通常，这意味着预留是独立于
任何共享缓存的驱逐进行跟踪的。类似地，因硬件线程内的推测执行导致的缓存未命中也不能无限期地妨碍 LR/SC 
的进展。

这些定义允许 SC 指令因实现原因而偶尔虚假的发生了失败，只要最终能够继续进行下去。

CAS 的一个优势是，它保证某个硬件线程最终会取得进展，而 LR/SC 原子序列在某些系统上可能会发生无限期的
活锁。为了避免这个问题，我们为某些 LR/SC 序列增加了一个架构保证，确保它们不会发生活锁。

早期版本的规范强制要求提供更强的饥饿自由（starvation-freedom）保证。然而，较弱的活锁自由（livelock-freedom）
保证对于实现 C11 和 C++11 语言来说已经足够，并且在某些微架构风格中提供这一保证要简单得多

====

[[sec:amo]]
=== "Zaamo" 扩展：原子内存操作

include::images/wavedrom/atomic-mem.adoc[]

原子内存操作（AMO）指令执行读-修改-写操作，用于多处理器同步，并采用 R 型指令格式进行编码。这些 AMO 
指令会原子地从 _rs1_ 中的地址加载数据值，并将该值放入寄存器 _rd_，然后将二进制运算符应用于加载的值和 
_rs2_ 中的原始值，最后将结果存回 _rs1_ 中的原始地址。AMO 可以在内存中操作双字（仅限 RV64）或单字。
对于 RV64，32 位 AMO 总是对 _rd_ 中放置的值进行符号扩展，并忽略 _rs2_ 中原始值的高 32 位。

对于 AMO，Zaamo 扩展要求 _rs1_ 中持有的地址必须自然对齐，且对齐方式要符合操作数的大小（即：对于双字
要求 8 字节对齐，对于单字要求 4 字节对齐）。如果地址没有自然对齐，则会生成地址未对齐异常或访问故障异
常。访问故障异常可以在内存访问本可以完成但由于未对齐而无法完成时产生，且如果该未对齐的访问不应被仿真，
则会触发此异常。

本手册第二卷中定义的“未对齐原子性粒度 PMA”可以选择性地放宽此对齐要求。若存在此 PMA，未对齐原子性粒度 PMA 
指定了一个未对齐的原子性粒度的大小，是一个 2 的幂字节数。此未对齐原子性粒度 PMA 仅适用于 AMO、基本 ISA 
中定义的加载和存储，以及 F、D 和 Q 扩展中不超过 XLEN 位的加载和存储操作。

对于该集合中的指令，如果所有访问的字节都位于同一未对齐的原子性粒度内，则该指令不会因为地址对齐问题而
引发异常，并且在 RVWMO 上只会产生一个内存操作——即，它将以原子方式执行。


支持的操作包括交换、整数加法、按位与、按位或、按位异或，以及有符号和无符号整数的最大值和最小值。没有
顺序约束的情况下，这些原子操作（AMO）可以用于实现并行归约操作，在这种情况下，返回值通常会通过写入 
x0 来丢弃。

[NOTE]
====
我们提供了取值并操作（fetch-and-op）风格的原子操作（AMO），因为它们比 LR/SC 或 CAS 更适用于高并发
的系统。一个简单的微架构可以通过使用 LR/SC 原语来实现 AMO ，前提是该实现能够保证 AMO 最终完成。更复
杂的实现可能还会在内存控制器中实现 AMO，并可以在目标是 x0 时优化掉获取原始值的操作。

AMO 的操作集被选择为高效支持 C11/C++11 的原子内存操作，并且能够支持内存中的并行归约操作。AMO 的另一
个用途是在 I/O 空间内为内存映射的设备寄存器提供原子更新（例如，设置、清除或切换位）。

Zaamo 扩展使得微控制器类的实现能够利用 A 扩展中的 AMO 子集提供的原子原语。通常，这类实现没有缓存，因此
可能无法自然地支持 Zalrsc 扩展提供的 LR/SC 指令
====

为了帮助实现多处理器同步，AMO 可选地提供释放一致性语义。如果设置了 _aq_ 位，则在此 RISC-V 内核中，任何
后续的内存操作都不能在 AMO 之前被观察到。相反，如果设置了 _rl_ 位，则其他 RISC-V 内核不会在此内核的 AMO 
之前观察到 AMO ，且 AMO 之前的内存访问会先于 AMO 被观察到。将 _aq_ 和 _rl_ 位都设置在 AMO 上，使得该
序列具有顺序一致性，意味着它不能与同一内核的早期或晚期内存操作重排序。

[NOTE]
====
AMO 被设计为高效地实现 C11 和 C++11 的内存模型。尽管 FENCE R、RW 指令足以实现 acquire 操作，FENCE RW、W指
令足以实现 release 操作，但与设置了相应 _aq_ 或 _rl_ 位的 AMO 相比，这两者都会引入额外的不必要的排序。
====


一个使用测试-测试-设置自旋锁保护的临界区的示例代码序列显示在示例 <<critical>>中。请注意，第一个 AMO 被标记
为 _aq_，用于在进入临界区之前对锁的获取进行排序，而第二个 AMO 被标记为 _rl_，用于在锁释放之前对临界区进行排序。

<<<

[[critical]]
[source,asm]
.Sample code for mutual exclusion. `a0` contains the address of the lock.
        li           t0, 1        # Initialize swap value.
    again:
        lw           t1, (a0)     # Check if lock is held.
        bnez         t1, again    # Retry if held.
        amoswap.w.aq t1, t0, (a0) # Attempt to acquire lock.
        bnez         t1, again    # Retry if held.
        # ...
        # Critical section.
        # ...
        amoswap.w.rl x0, x0, (a0) # Release lock by storing 0.

[NOTE]
====
我们建议使用上面展示的AMO Swap范式来实现锁的获取和释放，以简化推测性锁消除（speculative lock elision）的实现。cite:[Rajwar:2001:SLE]
====

[NOTE]
====
"A"扩展中的指令可以用于提供顺序一致性的加载和存储，但这会比必要的更严格地限制硬件对内存访问的重排序。
C++ 顺序一致性的加载可以通过设置 _aq_ 位的 _LR_ 指令来实现。然而，_LR/SC_ 的最终成功保证可能会减慢来自相同有
效地址的并发加载。顺序一致性的存储可以通过一个 AMOSWAP 指令来实现，该指令将旧值写入 x0 并设置 _rl_ 位。然而，
不必要的加载可能会引入不必要的排序约束，在这个例子中并不需要。特定的编译约定可能要求在 LR 和 AMOSWAP 指令中设
置 _aq_ 和 _rl_ 位，或者两者都设置。
====
