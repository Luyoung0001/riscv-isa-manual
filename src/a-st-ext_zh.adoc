[[atomics]]
== "A" 扩展:  原子指令，版本 2.1

"A" 扩展，即原子指令扩展，包含了一系列用于原子读-修改-写内存操作的指令，旨在支持在同一内存空间内运行的多个 RISC-V 硬件线程之间的同步。 该扩展提供了两种形式的原子指令：加载预留/条件存储指令 以及 原子fetch-and-op内存指令。这两种指令均支持多种内存一致性模型，包括无序、获取一致性、释放一致性和顺序一致性语义。这些指令使得 RISC-V 能够支持 RCsc 内存一致性模型。cite:[Gharachorloo90memoryconsistency]

[NOTE]
====
经过深入的探讨，语言社区和架构社区似乎最终倾向于将释放一致性模型作为标准的内存一致性模型。因此，RISC-V 的原子操作支持也是围绕此模型构建的。
====

A 扩展包括 Zaamo 扩展和 Zalrsc 扩展所提供的指令。

=== 用于确定访问顺序的原子指令

基础 RISC-V 指令集采用了一种弱内存模型。为了施加额外的顺序约束，ISA 提供了 FENCE 指令，执行环境将地址空间划分为内存域和 I/O 域。FENCE 指令允许对这两个地址域的访问进行顺序控制。

为了更高效地支持释放一致性 cite:[Gharachorloo90memoryconsistency]，每条原子指令都配备了 aq 和 rl 两位，用于在其他 RISC-V 硬件线程的视角下，指定额外的内存顺序约束。这两位用于控制原子指令所访问的地址域（内存或 I/O）的访问顺序。对于访问另一域的操作，则不施加任何顺序约束。若需要在不同域之间强制顺序，则应使用 FENCE 指令。

如果 aq 位和 rl 位均为清零状态，则不会对原子内存操作施加额外的顺序约束。反之，若仅设置了 aq 位，则该原子内存操作将被视为 “获取 (acquire)” 访问，这意味着在该 RISC-V 硬件线程上，任何后续的内存操作，都不能被观测到在该获取操作之前发生。类似地，若仅设置了 rl 位，则原子内存操作将被视为 “释放 (release)” 访问，即，释放操作本身不能被观测到发生在同一 硬件线程上任何更早的内存操作之前。当 aq 位和 rl 位同时置位时，该原子内存操作将具备顺序一致性。亦即，在同一 RISC-V 硬件线程上，针对同一地址域的访问，既不能观测到该指令发生在任何更早的内存操作之前，也不能观测到其发生在任何更晚的内存操作之后。

[[sec:lrsc]]
=== "Zalrsc" 扩展，用于Load-Reserved/Store-Conditional指令

include::images/wavedrom/load-reserve-st-conditional.adoc[]

针对单字或双字的复杂原子内存操作，RISC-V 提供了加载预留 (LR) 和条件存储 (SC) 指令来实现。LR.W 指令从寄存器 rs1 所指的内存地址处加载一个字，进行符号扩展后将结果置于寄存器 rd 中，并注册一个预留集——该集合包含了被寻址字所覆盖的所有字节。SC.W 指令则有条件地将寄存器 rs2 中的字写入 rs1  所指的内存地址。仅当预留仍然有效，且预留集的确包含了正要写入的字节时，SC.W 才会执行成功。如果 SC.W 执行成功，指令会将 rs2 中的字写入内存，并将值零写入寄存器 rd。  反之，如果 SC.W 执行失败，指令将不会执行内存写入，而是将非零值写入 rd。出于内存保护机制的考虑，执行失败的 SC.W 指令可以被视为一次存储操作。无论执行成功与否，执行 SC.W 指令都将使当前硬件线程持有的任何预留失效。LR.D 和 SC.D 指令在双字上的操作与之类似，但仅在 RV64 架构中可用。对于 RV64 架构，LR.W 和 SC.W 指令均会对其置入 rd 寄存器的值进行符号扩展。

[NOTE]
====

比较与交换（CAS）和加载-保留/条件存储（LR/SC）均可以用于构建无锁数据结构。经过深入讨论，
我们最终选择了 LR/SC，主要基于以下几个原因： 1) CAS 存在 ABA 问题，而 LR/SC 没有。
这是因为 LR/SC 监控所有对目标地址的写操作，而 CAS 仅检查数据值的变化； 2) CAS 需要新的整数指令格式以支持三个源操作数（地址、比较值、交换值），并且需要不同的内存系统消息格式，这将增加微架构实现的复杂度； 3) 为了缓解 ABA 问题，其他架构通常会提供双字宽度 CAS (DW-CAS)，以便在测试和更新数据字的同时，能够原子地递增计数器。然而，这需要单条指令读取 5 个寄存器并写入 2 个寄存器，同时也需要一种新的、更大的内存系统消息类型，进一步增加了实现的复杂性；4) LR/SC 在许多底层原语的实现上效率更高，因为它只需要一次加载操作。相比之下，CAS 则需要两次加载（一次是在 CAS 指令执行前，为了获取值以进行推测性计算；另一次是作为 CAS 指令的一部分，用于在更新之前检查值是否保持不变）。

活锁是 LR/SC 相对于 CAS 的主要缺点。然而，在特定情况下，我们通过架构层面的保障机制来避免活锁，具体方案将在下文详述。另一个潜在的担忧是，当前 x86 架构对 双字 CAS (DW-CAS) 的依赖，可能会给那些假设 DW-CAS 为基本原语的同步库及其他软件的移植工作带来挑战。不过，x86 架构近期引入了事务性内存 (Transactional Memory) 指令，有望减少对 DW-CAS 的依赖，从而在一定程度上缓解移植难题。

一般来说，多字原子操作原语是理想的，但其具体形式仍存在相当大的争议。特别是如何设计一套既能保证原子性，又能保证前向进度的机制，会显著增加系统的复杂性。

====

错误代码值为 1 表示非特定的失败。其他错误代码目前保留。可移植的软件应仅假设错误代码将是非零的。

[NOTE]
====
我们保留错误代码 1 表示 “非特定”，这样简易的实现方案便可复用 SLT/SLTU 指令所需的多路复用器来返回该值。更具体的错误代码或可在未来版本或 ISA 扩展中定义。
====

对于 LR 和 SC 指令，Zalrsc 扩展要求寄存器 _rs1_ 中保存的地址必须与操作数的大小自然对齐（即，
对于“双字”，要求按8字节对齐；对于“字”，要求按4字节对齐）。如果地址没有自然对齐，将会生成地址
未对齐异常或访问故障异常。如果内存访问本可以完成，但由于未对齐而无法完成，且该未对齐的访问不应
被仿真，则会生成访问故障异常。
[NOTE]
====
在大多数系统中，模拟未对齐的 LR/SC 序列是不可行的。

未对齐的LR/SC序列还可能导致同时访问多个预留集，而现有的规范并未考虑这种情况。

====

在实现层面上，每次执行 LR 操作时，系统可以注册一个尺寸任意大的预留集，前提是该预留集必须包含被寻址数据字或双字的所有字节。SC 指令只能与程序顺序中最近一次执行的 LR 指令配对。仅当在 LR 和 SC 指令之间，没有观测到来自其他硬件线程对预留集的存储操作，且在 LR 和 SC 指令之间，没有其他 SC 指令时，SC 指令方有可能执行成功。仅当在 LR 指令访问的字节范围内，没有观测到来自硬件线程之外的设备的写操作时，SC 指令方有可能执行成功。请注意，前述 LR 指令可能使用了不同的有效地址和数据大小，但仍将本次 SC 指令的地址纳入了其预留集。


[NOTE]
====
遵循此模型，在采用内存地址转换的系统中，若先前执行的 LR 指令曾使用不同的虚拟地址别名预留了同一物理位置，则后续的 SC 指令可以成功；但若虚拟地址确有不同，SC 指令亦可执行失败。

为兼容传统设备和总线，仅当来自 RISC-V 硬件线程之外的设备的写操作，与 LR 指令访问的字节发生重叠时，才要求使预留失效。 当这些写操作访问预留集内的其他字节时，则不强制要求使预留失效
====

如果目标地址不在程序顺序中最近的 LR 指令所建立的预留集内，SC 指令必须执行失败。如果在 LR 和 SC 指令之间，可以观测到来自另一硬件线程对预留集的存储操作，SC 指令必须执行失败。如果在 LR 和 SC 指令之间，可以观测到来自其他设备对 LR 指令访问字节的写操作，SC 指令必须执行失败。（如果该设备写入了预留集，但并未写入 LR 指令访问的字节，则 SC 指令可能成功，也可能失败）。如果在程序顺序中，LR 和 SC 指令之间存在另一条 SC 指令（无论目标地址为何），SC 指令必须执行失败。成功完成的 LR/SC 指令序列的原子性需求，其精确定义见 <<rvwmo>> 中的原子性公理。

[NOTE]
====
平台应提供一种机制来确定预留集的大小和形状。

平台规范或可对预留集的大小和形状进行约束。

应使用对内存空闲字执行的 SC 指令，来强制撤销任何现有的加载预留：

* 在抢占式上下文切换时
* 必要时，在更改虚拟地址到物理地址的映射关系时，例如迁移可能包含活跃预留的页面时。

当硬件线程执行 LR 或 SC 指令时，该硬件线程的预留会被自动撤销。这意味着每个硬件线程在任一时刻仅能持有一个预留，且 SC 指令只能与程序顺序中最近的 LR 指令配对，而 LR 指令则与程序顺序中紧随其后的 SC 指令配对。这是对 <<rvwmo>> 中原子性公理的一项约束，旨在确保软件在符合手册预期的常见实现上能够正确运行。
====

在另一个 RISC-V 硬件线程上，永远无法观测到 SC 指令的执行先于建立预留的 LR 指令。

[NOTE]
====
LR/SC 序列可以通过在 LR 指令上将 aq 位置为 1 来赋予获取（acquire）语义。通过在 SC 指令上
将 rl 位置为1，LR/SC 序列可以被赋予释放（release）语义。假设对其他原子操作有适当的映射，
在 LR 指令上将 aq 位置位1，并在 SC 指令上将 rl 位置位1，使得 LR/SC 序列在 C++ 的 memory_order_seq_cst
语义下是顺序一致的。这样的序列不会作为屏障来排序序列前后的普通加载和存储指令。对于其他 C++
原子操作的特定指令映射，或者更强的“顺序一致性”概念，可能需要在 LR 或 SC 指令中的任意一条或
两条上将这两个位都置为1。

如果在 LR 或 SC 指令中均未设置 aq 位和 rl 位，则可以观测到 LR/SC 序列与同一 RISC-V 硬件线程发出的周围内存操作，在执行顺序上互不约束。当 LR/SC 序列用于实现并行规约操作时，这可能是一种合理的选择。
====

除非 aq 位被置为1，否则软件不应在 LR 指令上将 rl 位置为1；同样，除非 rl 位被置为1，否则软件
不应在 SC 指令上将 aq 位置为1。LR.rl 和 SC.aq 指令并不保证提供比两者都未设置位时更强的排序，
但可能会导致性能降低。

<<<

[[cas]]
[source,asm]
.使用 LR/SC 的比较并交换函数示例代码。
        # a0 寄存器存储内存地址
        # a1 寄存器存储期望值
        # a2 寄存器存储目标值
        # a0 寄存器存储返回值，0 表示成功，非 0 表示失败
    cas:
        lr.w t0, (a0)        # 加载原始值。
        bne t0, a1, fail     # 值不匹配，因此失败。
        sc.w t0, a2, (a0)    # 尝试更新。
        bnez t0, cas         # 如果条件存储失败，则重试。
        li a0, 0             # 设置返回值为成功。
        jr ra                # 返回。
    fail:
        li a0, 1             # 设置返回值为失败。
        jr ra                # 返回。


LR/SC 可以用来构建无锁数据结构。以下是一个使用 LR/SC 实现比较和交换（compare-and-swap）
功能的示例，见 <<cas>>。在内联情况下，比较和交换功能仅需要四条指令。

[[sec:lrscseq]]
=== SC 指令的最终成功

Zalrsc 扩展定义了受限的 LR/SC 循环，具有以下特点：

* 该循环仅包含一个 LR/SC 序列和在失败时重试该序列的代码，并且最多只能包含 16 条指令，这些指令
按顺序放置在内存中。
* 一个 LR/SC 序列以 LR 指令开始，并以 SC 指令结束。LR 和 SC 之间执行的动态代码只能包含来自基本的 ''I'' 指令集的指令，但是除了加载、存储、向后跳转、被执行的向后分支
、JALR、FENCE 和 SYSTEM 指令。如果支持 ''C'' 扩展，那么上述 ''I'' 指令的压缩形式也是允许的。
* 用于重试失败的 LR/SC 序列的代码可以包含向后跳转和/或分支以重复执行 LR/SC 序列，但在其他方面与 LR 和 SC 之间的代码具有相同的约束。
* LR 和 SC 地址必须位于具有 LR/SC 最终性 属性的内存区域内。执行环境负责传达哪些区域具有该属性。
* SC 必须与同一硬件线程最近执行的 LR 使用相同的有效地址和相同的数据大小。

不属于受限 LR/SC 循环的 LR/SC 序列被称为不受限的。不受限的 LR/SC 序列可能在某些实现上某些尝
试时成功，但在其他实现上可能永远不会成功。

[NOTE]
====
我们将 LR/SC 循环的长度限制位 64 个连续指令字节，这是对基本指令集指令大小的适配，以避免指令缓存
和 TLB 的大小及关联性的过度限制。类似地，我们禁止在循环内进行其他加载和存储操作，以避免在简单实
现中对数据缓存关联性的限制，特别是在这些实现中，预留是通过私有缓存进行跟踪的。对分支和跳转的限
制则限制了在序列中可花费的时间。浮点运算和整数乘除被禁止，以简化操作系统在没有适当硬件支持的实现
上对这些指令的仿真。

软件并不被禁止使用不受限的 LR/SC 序列，但可移植性软件必须检测到序列反复失败的情况，然后退回到不依
赖于不受限 LR/SC 序列的替代代码序列。实现允许在任何不受限的 LR/SC 序列上无条件失败。
====
如果一个硬件线程 H 进入一个受限的 LR/SC 循环，执行环境必须保证最终发生以下事件之一：

* _H_ 或其他硬件线程执行一个成功的 SC 指令，且该 SC 指令操作的是 H 的受限 LR/SC 循环中的预留集。
* 其他硬件线程执行一个无条件的存储或原子内存操作（AMO）指令，且该指令操作的是 _H_ 的受限 LR/SC
循环中的预留集合，或者系统中的其他设备向该预留集写入数据。
* _H_ 执行一个跳转或分支，退出受限 LR/SC 循环。
* _H_ 触发陷阱。

[NOTE]
====
请注意，这些定义允许在实现中 SC 指令偶尔因任何原因失败，前提是不会违反上述的保证。

由于要保证最终的结构，如果执行环境中的一些硬件线程正在执行受限的 LR/SC 循环，而执行环境中没有其他
硬件现场或设备向该预留集合执行无条件的存储或 AMO 操作，那么至少有一个硬件线程最终会退出其受限的循环。
相比之下，如果其他硬件线程或设备继续向该预留集合写入数据，则无法保证任何硬件线程会退出其 LR/SC 循环。

加载指令和 LR 指令本身不会妨碍其他硬件线程的 LR/SC 序列进展。请注意，这个约束意味着，除了其他事情之
外，由其他硬件线程执行的加载指令和 LR 指令（可能在同一核心内）不能无限期地妨碍 LR/SC 的进展。例如，
由于另一个硬件线程共享缓存导致的缓存驱逐不能无限期地妨碍 LR/SC 的进展。通常，这意味着预留是独立于
任何共享缓存的驱逐进行跟踪的。类似地，因硬件线程内的推测执行导致的缓存未命中也不能无限期地妨碍 LR/SC
的进展。

这些定义允许 SC 指令因实现原因而偶尔虚假的发生了失败，只要最终能够继续进行下去。

CAS 的一个优势是，它保证某个硬件线程最终会取得进展，而 LR/SC 原子序列在某些系统上可能会发生无限期的
活锁。为了避免这个问题，我们为某些 LR/SC 序列增加了一个架构保证，确保它们不会发生活锁。

早期版本的规范强制要求提供更强的饥饿自由（starvation-freedom）保证。然而，较弱的活锁自由（livelock-freedom）
保证对于实现 C11 和 C++11 语言来说已经足够，并且在某些微架构风格中提供这一保证要简单得多。

====

[[sec:amo]]
=== "Zaamo" 扩展：原子内存操作

include::images/wavedrom/atomic-mem.adoc[]

原子内存操作 (AMO) 指令用于执行读-修改-写操作，以实现多处理器同步，并采用 R 型指令格式编码。这些 AMO 指令会以原子方式从寄存器 rs1  指定的地址加载数据值，并将该值存入寄存器 rd。随后，将某个二进制运算符应用于刚加载的值和寄存器 rs2 中的初始值，并将运算结果存回寄存器 rs1 指定的原始内存地址。AMO 指令可以操作内存中的双字（仅限 RV64 架构）或单字。对于 RV64 架构，32 位 AMO 指令总是对其置入寄存器 rd 的值进行符号扩展，并忽略寄存器 rs2 初始值的高 32 位。

对于 AMO 指令，Zaamo 扩展要求寄存器 rs1 中保存的地址，必须按照操作数大小进行自然对齐（例如，双字需 8 字节对齐，单字需 4 字节对齐）。如果地址未按自然边界对齐，则会触发地址未对齐异常或访问故障异常。当内存访问原本可以成功完成，但因未对齐而无法完成，且该未对齐访问不应被模拟时，便会触发访问故障异常。

本手册第二卷定义的 “未对齐原子性粒度 PMA” 机制，可选择性地放宽上述对对齐的要求。一旦启用 PMA，它将指定一个未对齐原子性粒度的大小，该粒度大小必须是 2 的幂次方字节数。未对齐原子性粒度 PMA 机制 仅适用于以下指令集：AMO 指令、基本 ISA 中定义的加载和存储指令，以及 F、D 和 Q 扩展中定义的、操作数大小不超过 XLEN 位的加载和存储指令。对于属于上述指令集的指令，如果其所有访问的字节都落在同一个未对齐原子性粒度所覆盖的范围内，则该指令将不会因地址对齐问题而触发异常，并且在 RVWMO 内存模型下，该指令将仅产生一次内存操作——换言之，它将以原子方式执行。

支持的操作包括交换、整数加法、按位与、按位或、按位异或，以及有符号和无符号整数的最大值和最小值。没有
顺序约束的情况下，这些原子操作（AMO）可以用于实现并行归约操作，在这种情况下，返回值通常会通过写入
x0 来丢弃。

[NOTE]
====
我们提供了取值并操作（fetch-and-op）风格的原子操作（AMO），因为它们比 LR/SC 或 CAS 更适用于高并发的系统。一个简单的微架构可以通过使用 LR/SC 原语来实现 AMO ，前提是该实现能够保证 AMO 最终完成。更复杂的实现可能还会在内存控制器中实现 AMO，并可以在目标是 x0 时优化掉获取原始值的操作。

AMO 的操作集被选择为高效支持 C11/C++11 的原子内存操作，并且能够支持内存中的并行归约操作。AMO 的另一个用途是在 I/O 空间内为内存映射的设备寄存器提供原子更新（例如，设置、清除或切换位）。

Zaamo 扩展使得微控制器类的实现能够利用 A 扩展中的 AMO 子集提供的原子原语。通常，这类实现没有缓存，因此可能无法自然地支持 Zalrsc 扩展提供的 LR/SC 指令。
====

为了帮助实现多处理器同步，AMO 可选地提供释放一致性语义。如果设置了 _aq_ 位，则在此 RISC-V 内核中，任何后续的内存操作都不能在 AMO 之前被观察到。相反，如果设置了 _rl_ 位，则其他 RISC-V 内核不会在此内核的 AMO 之前观察到 AMO ，且 AMO 之前的内存访问会先于 AMO 被观察到。将 _aq_ 和 _rl_ 位都设置在 AMO 上，使得该序列具有顺序一致性，意味着它不能与同一内核的早期或晚期内存操作重排序。

[NOTE]
====
AMO 被设计为高效地实现 C11 和 C++11 的内存模型。尽管 FENCE R、RW 指令足以实现 acquire 操作，FENCE RW、W 指令足以实现 release 操作，但与设置了相应 _aq_ 或 _rl_ 位的 AMO 相比，这两者都会引入额外的不必要的排序。
====

一个使用测试-测试-设置自旋锁保护的临界区的示例代码序列显示在示例 <<critical>>中。请注意，第一个 AMO 被标记为 _aq_，用于在进入临界区之前对锁的获取进行排序，而第二个 AMO 被标记为 _rl_，用于在锁释放之前对临界区进行排序。

<<<

[[critical]]
[source,asm]
.互斥示例代码。锁地址在 a0 中。
        li           t0, 1        # 初始化交换值为 1。
    again:
        lw           t1, (a0)     # 检查锁是否被持有。
        bnez         t1, again    # 如果已被持有，则重试。
        amoswap.w.aq t1, t0, (a0) # 尝试获取锁。
        bnez         t1, again    # 如果已被持有，则重试。
        # ...
        # 临界区。
        # ...
        amoswap.w.rl x0, x0, (a0) # 通过存储 0 来释放锁。

[NOTE]
====
我们建议使用上面展示的AMO Swap范式来实现锁的获取和释放，以简化推测性锁消除（speculative lock elision）的实现。cite:[Rajwar:2001:SLE]
====

[NOTE]
====
"A"扩展中的指令可以用于提供顺序一致性的加载和存储，但这会比必要的更严格地限制硬件对内存访问的重排序。
C++ 顺序一致性的加载可以通过设置 _aq_ 位的 _LR_ 指令来实现。然而，_LR/SC_ 的最终成功保证可能会减慢来自相同有效地址的并发加载。顺序一致性的存储可以通过一个 AMOSWAP 指令来实现，该指令将旧值写入 x0 并设置 _rl_ 位。然而，不必要的加载可能会引入不必要的排序约束，在这个例子中并不需要。特定的编译约定可能要求在 LR 和 AMOSWAP 指令中设置 _aq_ 和 _rl_ 位，或者两者都设置。
====
