== 引言


RISC-V（发音为“Risk-Five”）是一种新的指令集架构（ISA），最初的设计目的是支持计算机架构的研究和教育，但我们希望它也能成为工业实现中的一个标准化、免费且开放的架构。我们在定义 RISC-V 时的目标包括：

* 一个完全开放的 ISA，提供给学术界和工业界自由使用。
* 一个实际可用的 ISA，适用于直接的原生硬件实现，而不仅仅是用于仿真或二进制翻译。
* 一个能够避免为特定微架构风格（例如微编码、顺序执行、解耦、乱序执行）或实现技术（例如全定制、ASIC、FPGA）“过度设计”* 的 ISA，同时允许在任何这些技术中进行高效实现。
* 一个分离为精简的基础整数 ISA 和可选标准扩展的 ISA。基础整数 ISA 可单独用作定制加速器的基础或用于教学目的，而可选* 扩展则支持通用软件开发。
* 支持 2008 年修订版的 IEEE-754 浮点标准。cite:[ieee754-2008]
* 一个支持广泛 ISA 扩展和专用变体的 ISA。
* 为应用程序、操作系统内核和硬件实现提供 32 位和 64 位地址空间变体。
* 一个支持高度并行的多核或多核集群实现（包括异构多处理器）的 ISA。
* 可选的可变长度指令，既可以扩展可用的指令编码空间，也可以通过可选的密集指令编码来提升性能、减少静态代码大小并提高能* 效。
* 一个完全可虚拟化的 ISA，以简化虚拟机管理程序（Hypervisor）的开发。
* 一个简化了新型特权架构设计实验的 ISA。

[TIP]
====
关于我们设计决策的注释会像本段落这样格式化。如果读者只对规范本身感兴趣，可以跳过这些非规范性内容。
====

[NOTE]
====
RISC-V 这个名称的选择是为了代表加州大学伯克利分校设计的第五代主要 RISC 指令集架构（RISC-I cite:[riscI-isca1981]、RISC-II cite:[Katevenis:1983]、SOAR cite:[Ungar:1984] 和 SPUR cite:[spur-jsscc1989] 是前四代）。我们还利用了罗马数字 "V" 的双关意义，表示 "变体"（variations）和 "向量"（vectors），因为支持各种架构研究（包括不同的数据并行加速器）是该指令集架构设计的明确目标。
====
(((ISA, definition)))
 RISC-V ISA 的定义尽量避免涉及实现细节（尽管其中包含了关于实现驱动决策的注释），应被理解为适用于多种实现的软硬件可见接口，而不是特定硬件设计的说明。RISC-V 手册分为两卷。本卷描述了基础的 非特权 指令设计，包括可选的非特权 ISA 扩展。非特权指令是指在所有特权架构的所有特权模式中通常可用的指令，尽管其行为可能会因特权模式和特权架构的不同而有所变化。第二卷则提供了第一版（“经典”）特权架构的设计。手册采用 IEC 80000-13:2008 标准，其中一个字节等于 8 位。

[TIP]
====
在非特权 ISA 设计中，我们尽量去除对特定微架构特性的依赖（例如缓存行大小），以及对特权架构细节的依赖（例如页表翻译）。这样做的目的是为了简化设计，并为其他微架构或特权架构提供最大的灵活性。
====

=== RISC-V 硬件平台术语


一个 RISC-V 硬件平台可以包含一个或多个兼容 RISC-V 的处理核心，以及其他非 RISC-V 兼容的核心、固定功能的加速器、各种物理内存结构、I/O 设备，以及允许这些组件通信的互连结构。
(((core, component)))

如果一个组件包含一个独立的指令获取单元，它被称为核心 (core)。一个兼容 RISC-V 的核心可能通过多线程支持多个兼容 RISC-V 的硬件线程，称为硬件线程 (hart)。
(((core, extensions, coprocessor)))

一个 RISC-V 核心可能具有额外的专用指令集扩展或一个附加的协处理器 (coprocessor)。我们使用“协处理器”这个术语来指代连接到 RISC-V 核心的单元，它主要由 RISC-V 指令流控制，但包含额外的体系结构状态和指令集扩展，并可能相对于主要 RISC-V 指令流具有一定的有限自主性。

我们使用“加速器” (accelerator) 一词来指代非可编程的固定功能单元，或能够自主运行但专用于特定任务的核心。在 RISC-V 系统中，我们预计许多可编程加速器将是基于 RISC-V 的核心，并具有专用指令集扩展和/或定制的协处理器。RISC-V 加速器中一个重要的类别是 I/O 加速器，用于从主要应用核心中卸载 I/O 处理任务。
(((core, accelerator)))

一个 RISC-V 硬件平台的系统级组织可以从单核微控制器扩展到拥有数千节点的共享内存多核服务器集群。即使是小型片上系统（SoC），也可能通过多计算机和/或多处理器的分层结构进行模块化开发，或者在子系统之间提供安全隔离。
(((core, cluster, multiprocessors)))

=== RISC-V 软件执行环境和 Harts


RISC-V 程序的行为取决于其运行的执行环境。RISC-V 执行环境接口（Execution Environment Interface，简称 EEI）定义了程序的初始状态、环境中 harts 的数量和类型（包括 harts 支持的特权模式）、内存和 I/O 区域的可访问性及属性、每个 hart 执行的所有合法指令的行为（即，ISA 是 EEI 的一个组成部分），以及在执行过程中引发的任何中断或异常（包括环境调用）的处理方式。EEI 的例子包括 Linux 应用程序二进制接口（ABI）或 RISC-V 监督二进制接口（SBI）。RISC-V 执行环境的实现可以是纯硬件、纯软件，或硬件与软件的结合。例如，可以使用操作码陷阱和软件仿真来实现硬件未提供的功能。执行环境实现的示例如下：

* 裸机（Bare metal）硬件平台：在这种环境中，harts 直接由物理处理器线程实现，指令可以完全访问物理地址空间。硬件平台定义了一个从上电复位（power-on reset）开始的执行环境。
* RISC-V 操作系统：这些操作系统通过将用户级 harts 多路复用到可用的物理处理器线程上，并通过虚拟内存控制对内存的访问，提供多个用户级执行环境。
* RISC-V 虚拟机管理程序（Hypervisor）：虚拟机管理程序为来宾操作系统提供多个监督级执行环境。
* RISC-V 仿真器：例如 Spike、QEMU 或 rv8，这些仿真器在底层 x86 系统上仿真 RISC-V 的 harts，可以提供用户级或监督级执行环境。

[TIP]
====
裸硬件平台可以被视为定义了一个执行环境接口（EEI），其中可访问的 harts、内存和其他设备构成了环境，其初始状态为上电复位时的状态。通常，大多数软件被设计为使用硬件的更抽象接口，因为更抽象的 EEI 提供了更大的跨硬件平台的可移植性。EEI 通常是分层的，其中一个高级别的 EEI 使用另一个低级别的 EEI。
====
(((hart, execution environment)))
从运行在特定执行环境中的软件视角来看，hart 是一种资源，它可以在该执行环境中自主获取并执行 RISC-V 指令。从这个意义上讲，即使 hart 是通过执行环境在实际硬件上进行时间复用的，它的行为仍类似于一个硬件线程资源。一些 EEI 支持创建和销毁额外的 harts，例如通过环境调用来派生（fork）新的 harts。

执行环境负责确保其每个 hart 最终能够前进（forward progress）。对于特定的 hart，当它使用某种明确等待事件的机制（例如本规范第二卷中定义的“等待中断”（wait-for-interrupt）指令）时，这一责任会暂时中止；当 hart 被终止时，这一责任则结束。以下事件构成了前进的标志：

* 一条指令的退休（retirement）。
* 一个陷阱（trap），如<<trap-defn, Section 1.6>>中定义的内容.
* 任何由扩展定义为前进的其他事件。

[TIP]
====
术语 hart 最早在 Lithe 的研究中引入 cite:[lithe-pan-hotpar09] 和 cite:[lithe-pan-pldi10]，用来表示一种抽象的执行资源，而不是软件线程的编程抽象。

硬件线程（hart）与软件线程上下文之间的重要区别在于，运行在执行环境中的软件不需要负责使其每个 hart 继续运行；这是外部执行环境的责任。因此，从执行环境内的软件的视角来看，环境提供的 harts 就像硬件线程一样运行。

一个执行环境的实现可能会通过时间复用（time-multiplexing）将一组来宾 harts 映射到更少的由其自身执行环境提供的主机 harts 上，但必须以一种使来宾 harts 像独立硬件线程一样运行的方式进行。特别地，如果来宾 harts 的数量多于主机 harts，则执行环境必须能够抢占（preempt）来宾 harts，而不能无限期地等待运行在某个来宾 hart 上的软件“释放”对该来宾 hart 的控制权。
====

=== RISC-V ISA 概述


RISC-V ISA（指令集架构）由一个基础整数 ISA 和可选扩展组成。基础整数 ISA 必须在任何实现中存在，而可选扩展是基于基础 ISA 的增强部分。RISC-V 的基础整数 ISA 与早期的 RISC 处理器非常相似，但去除了分支延迟槽，并支持可选的可变长度指令编码。基础 ISA 被精心限制为一组最小化的指令集，这些指令足以为编译器、汇编器、链接器和操作系统（包括额外的特权操作）提供一个合理的目标，同时作为一个方便的 ISA 和软件工具链的“骨架”，可以围绕其构建更多定制化的处理器 ISA。

尽管我们通常谈论“RISC-V ISA”，但实际上，RISC-V 是一组相关 ISA 的家族，目前包含四种基础 ISA。每个基础整数指令集的特点在于整数寄存器的宽度、对应的地址空间大小以及整数寄存器的数量。主要有两种基础整数变体：RV32I 和 RV64I，分别提供 32 位和 64 位地址空间，具体描述见 <<rv32>> 和 <<rv64>>。我们使用术语 XLEN 来指代整数寄存器的宽度（以位为单位，取值为 32 或 64）。<<rv32e, 第 6 章>> 描述了 RV32E 和 RV64E，这些是 RV32I 和 RV64I 基础指令集的子集变体，设计用于支持小型微控制器，并且其整数寄存器的数量减半。<<rv128, 第 8 章>> 概述了未来的 RV128I 基础整数指令集变体，该变体支持平坦的 128 位地址空间（XLEN=128）。基础整数指令集使用二进制补码（two's complement）表示有符号整数值。


[TIP]
====
尽管 64 位地址空间对于较大系统是必要的，但我们认为，未来几十年内，32 位地址空间仍然能够满足许多嵌入式设备和客户端设备的需求，并且由于其可以降低内存流量和能耗而被广泛使用。此外，32 位地址空间也完全能够满足教学目的的需求。未来可能需要更大的平坦 128 位地址空间，因此我们确保了 RISC-V ISA 框架能够支持这一扩展。
====

[NOTE]
====
RISC-V 中的四个基础 ISA 被视为独立的基础 ISA。一个常见的问题是，为什么不设计成单一的 ISA？尤其是，为什么 RV32I 不是 RV64I 的严格子集？一些早期的 ISA 设计（例如 SPARC、MIPS）采用了严格的超集策略，以便在扩展地址空间支持新 64 位硬件时能够运行现有的 32 位二进制程序。

显式分离基础 ISA 的主要优势在于，每个基础 ISA 都可以针对自身需求进行优化，而无需支持其他基础 ISA 所需的所有操作。例如，RV64I 可以省略仅用于应对 RV32I 中较窄寄存器的指令和 CSR，而 RV32I 变体则可以利用本来保留给宽地址空间变体指令的编码空间。

不将设计视为单一 ISA 的主要缺点是，在一种基础 ISA 上模拟另一种基础 ISA（例如在 RV64I 上模拟 RV32I）会增加硬件复杂性。然而，由于地址和非法指令异常处理的差异，即使采用完整的超集指令编码，硬件仍然需要某种模式切换。此外，不同的 RISC-V 基础 ISA 十分相似，因此支持多个版本的成本相对较低。虽然一些人提出，严格超集设计可以让遗留的 32 位库与 64 位代码链接，但实际上，由于软件调用约定和系统调用接口的差异，即使编码兼容，这种方式也很难实现。

RISC-V 特权架构在 misa 中提供了字段，用于在每个级别控制无特权 ISA，从而支持在同一硬件上模拟不同的基础 ISA。值得注意的是，更新版本的 SPARC 和 MIPS ISA 修订版已经废弃了在 64 位系统上运行未修改的 32 位代码的支持。

另一个相关的问题是，为什么在 RV32I 中 32 位加法（ADD）和 RV64I 中 32 位加法（ADDW）的编码不同？在 RV32I 中可以使用 ADDW 的操作码实现 32 位加法，而在 RV64I 中使用 ADDD 实现 64 位加法。而当前设计使用相同的操作码 ADD，在 RV32I 中表示 32 位加法，在 RV64I 中表示 64 位加法，同时为 RV64I 中的 32 位加法引入了不同的操作码 ADDW。这一设计与 LW 操作码在 RV32I 和 RV64I 中都表示 32 位加载的用法不一致。

RISC-V ISA 的最初版本确实采用过这种替代设计的变体，但在 2011 年 1 月，RISC-V 设计更改为当前选择。我们的关注点是支持 64 位 ISA 中的 32 位整数操作，而不是与 32 位 ISA 的兼容性。其动机是消除 RV32I 中不是所有操作码都有 *W 后缀（例如 ADDW，而 AND 没有 ANDW）所带来的不对称性。从结果来看，这种设计可能并不完全合理，主要是因为两种 ISA 同时设计，而不是一个在另一个基础上添加。此外，我们曾认为需要将平台需求纳入 ISA 规范，这意味着 RV64I 必须支持所有 RV32I 指令。现在修改编码已经太迟，但基于上述原因，这对实际应用几乎没有影响。

有观点认为，可以为 RV32I 系统启用 *W 变体作为扩展，以提供 RV64I 和未来 RV32 变体之间的通用编码。
====

RISC-V 被设计为支持广泛的定制化和专用化。每个基础整数 ISA 都可以通过一个或多个可选的指令集扩展来增强。扩展可以分为三类：标准扩展、自定义扩展和不符合规范的扩展。为此，我们将每个 RISC-V 指令集编码空间（以及相关的编码空间，例如 CSR）划分为三个不相交的类别：标准编码、保留编码 和 自定义编码。标准扩展和编码由 RISC-V 国际组织定义；任何未由 RISC-V 国际组织定义的扩展均为 非标准扩展。每个基础 ISA 及其标准扩展仅使用标准编码，并且在使用这些编码时相互不冲突。保留编码 当前未定义，但保留用于未来的标准扩展；一旦被使用，它们将成为标准编码。自定义编码 永远不得用于标准扩展，而是提供给厂商特定的非标准扩展使用。非标准扩展 可以是只使用自定义编码的自定义扩展，或者是使用任何标准或保留编码的不符合规范的扩展。指令集扩展通常是共享的，但可能根据基础 ISA 提供略微不同的功能。<<extending>> 描述了扩展 RISC-V ISA 的各种方法。此外，我们还制定了 RISC-V 基础指令和指令集扩展的命名规范，具体描述请参见 <<naming>>。

为了支持更广泛的通用软件开发，定义了一组标准扩展，以提供整数乘法/除法、原子操作以及单精度和双精度浮点运算。基础整数 ISA 被命名为 “I”（根据整数寄存器宽度加上 RV32 或 RV64 前缀），包含整数计算指令、整数加载、整数存储和控制流指令。标准整数乘法和除法扩展命名为 “M”，增加了在整数寄存器中进行乘法和除法操作的指令。标准原子指令扩展，记为 “A”，增加了用于多处理器同步的原子读取、修改和写入内存的指令。标准单精度浮点扩展，记为 “F”，增加了浮点寄存器、单精度计算指令以及单精度加载和存储。标准双精度浮点扩展，记为 “D”，扩展了浮点寄存器，并增加了双精度计算指令、加载和存储。标准 “C” 压缩指令扩展提供了常用指令的更窄的 16 位形式。

超越基础整数 ISA 和这些标准扩展，我们认为很少有新的指令能够对所有应用程序提供显著的优势，但它可能对某些特定领域非常有益。由于能源效率问题迫使我们进行更大的专用化，我们认为简化 ISA 规范的必需部分非常重要。与其他架构通常将其 ISA 视为单一实体，并随着时间的推移通过添加指令更改为新版本不同，RISC-V 力求保持基础 ISA 和每个标准扩展的稳定性，并通过分层添加新的指令作为进一步的可选扩展。例如，基础整数 ISA 将继续作为完全支持的独立 ISA，无论后续扩展如何。

=== 内存


RISC-V 的一个 hart 拥有一个单一的字节可寻址地址空间，大小为 latexmath:[$2^{\text{XLEN}}$] 字节，用于所有内存访问。内存中的一个 字（word）被定义为 32 位（4 字节）。相应地，半字（halfword）为 16 位（2 字节），双字（doubleword）为 64 位（8 字节），四字（quadword）为 128 位（16 字节）。内存地址空间是循环的，因此地址为 latexmath:[$2^{\text{XLEN}}-1$] 的字节与地址为零的字节相邻。因此，硬件执行的内存地址计算会忽略溢出，并以 latexmath:[$2^{\text{XLEN}}$] 为模进行循环。

执行环境决定硬件资源在 hart 地址空间中的映射。hart 地址空间的不同地址范围可能：(1) 空置，(2) 包含主存，或 (3) 包含一个或多个I/O 设备。对 I/O 设备的读写可能会产生可见的副作用，而对主存的访问则不会。尽管执行环境可以将 hart 地址空间中的所有内容都视为 I/O 设备，但通常期望将一部分地址范围指定为主存。

当一个 RISC-V 平台包含多个 hart 时，任意两个 hart 的地址空间可以完全相同、完全不同，或者部分不同但共享某些资源，这些资源可以映射到相同或不同的地址范围中。

[TIP]
====
对于一个完全的“裸机”环境，所有的 hart 可能会看到相同的地址空间，并完全通过物理地址进行访问。然而，当执行环境包含一个使用地址转换的操作系统时，通常每个 hart 会被分配一个几乎完全独立的虚拟地址空间。
====
(((memory access, implicit and explicit)))
每条 RISC-V 机器指令的执行都涉及一个或多个内存访问，这些访问分为隐式和显式两类。对于每条被执行的指令，都会进行一次隐式内存读取（指令取值）以获取要执行的编码指令。许多 RISC-V 指令在指令取值之外不再进行额外的内存访问。特定的加载（load）和存储（store）指令会显式地读取或写入由指令确定地址的内存。执行环境可能要求指令执行期间除了无特权 ISA 文档中记录的内容外，还进行其他隐式内存访问（例如地址转换的实现）。

执行环境决定非空地址空间的哪些部分可用于每种内存访问。例如，指令取值可以隐式读取的地址范围可能与加载指令显式读取的地址范围完全不同；而存储指令可以显式写入的地址范围可能只是可读取地址范围的一个子集。通常，如果一条指令试图访问一个不可访问的地址，则会引发该指令的异常。地址空间中的空白位置永远不可访问。

除非另有说明，否则没有引发异常且无副作用的隐式读取可以任意提前执行，即使机器在逻辑上尚未证明需要该读取。例如，一个合法的实现可以在尽早的时机尝试读取整个主存，将尽可能多的可取值（可执行）字节缓存起来以供后续指令取值使用，并避免为指令取值再次读取主存。为了确保某些隐式读取在写入同一内存位置之后才进行，软件必须执行为此目的定义的特定屏障（fence）或缓存控制指令（例如 <<zifencei>> 中定义的 FENCE.I 指令）。
(((memory access, implicit and explicit)))

一个 hart 执行的内存访问（隐式或显式）在其他 hart 或可以访问相同内存的任何其他代理看来，可能呈现出不同的顺序。然而，这种感知到的内存访问重排序始终受到适用的内存一致性模型的约束。RISC-V 的默认内存一致性模型是 RISC-V 弱内存排序（RVWMO），其定义见 <<memorymodel>> 及相关附录。可选地，一个实现可以采用更强的完全存储排序模型（Total Store Ordering），定义见 <<ztso>>。执行环境也可能增加限制，进一步约束感知到的内存访问重排序。由于 RVWMO 模型是所有 RISC-V 实现允许的最弱模型，为此模型编写的软件与所有 RISC-V 实现的实际内存一致性规则兼容。与隐式读取一样，软件必须执行屏障或缓存控制指令，以确保超出默认内存一致性模型和执行环境要求的内存访问顺序。

=== 基础指令长度编码

基础 RISC-V ISA 使用固定长度的 32 位指令，这些指令必须自然对齐到 32 位边界。然而，标准 RISC-V 编码方案被设计为支持具有可变长度指令的 ISA 扩展，其中每条指令可以由任意数量的 16 位指令段（parcels）组成，而这些段自然对齐到 16 位边界。<<compressed>> 中描述的标准压缩 ISA 扩展通过提供压缩的 16 位指令来减少代码大小，并放宽对齐约束，允许所有指令（16 位和 32 位）对齐到任意 16 位边界，从而提升代码密度。

我们使用术语 IALIGN（以位为单位）来表示实现强制执行的指令地址对齐约束。在基础 ISA 中，IALIGN 是 32 位，但某些 ISA 扩展（包括压缩 ISA 扩展）将 IALIGN 放宽到 16 位。IALIGN 仅允许取值 16 或 32。
(((ILEN)))

我们使用术语 ILEN（以位为单位）来表示实现支持的最大指令长度，并且该值始终是 IALIGN 的倍数。对于仅支持基础指令集的实现，ILEN 是 32 位。支持更长指令的实现会有更大的 ILEN 值。

<<instlengthcode>> 展示了标准 RISC-V 指令长度编码约定。基础 ISA 中的所有 32 位指令的最低两位被设置为 11。可选的压缩 16 位指令集扩展的最低两位为 00、01 或 10。

==== 扩展指令长度编码
一部分 32 位指令编码空间已被暂时分配用于长度超过 32 位的指令。目前，这部分空间完全保留，而以下针对超过 32 位指令的编码提案尚未冻结。
(((instruction length encoding)))

使用超过 32 位编码的标准指令集扩展在低位中额外设置为 1，其中 48 位和 64 位长度的编码约定如 <<instlengthcode>> 所示。指令长度在 80 位到 176 位之间的编码使用位 [14:12] 的 3 位字段来表示比初始的 5latexmath:[$\times$]16 位字多出的 16 位字的数量。位 [14:12] 设置为 "111" 的编码保留用于未来更长指令的编码。

[[instlengthcode, Table 1]]
.RISC-V 指令长度编码

.RISC-V 指令长度编码。当前仅冻结了 16 位和 32 位编码。
[%autowidth,cols="^2,^2,^3,^3,<4"]
|===
||||xxxxxxxxxxxxxxaa |16-bit (aa&#8800;11)

|||xxxxxxxxxxxxxxxx |xxxxxxxxxxxbbb11 |32-bit (bbb&#8800;111)

||latexmath:[$\cdot\cdot\cdot$]xxxx |xxxxxxxxxxxxxxxx
|xxxxxxxxxx011111 |48-bit

||latexmath:[$\cdot\cdot\cdot$]xxxx |xxxxxxxxxxxxxxxx
|xxxxxxxxx0111111 |64-bit

||latexmath:[$\cdot\cdot\cdot$]xxxx |xxxxxxxxxxxxxxxx
|xnnnxxxxx1111111 |(80+16*nnn)-bit, nnn&#8800;111

||latexmath:[$\cdot\cdot\cdot$]xxxx |xxxxxxxxxxxxxxxx
|x111xxxxx1111111 |Reserved for &#8805;192-bits

|Byte Address: >|base+4 >|base+2 >|base |
|===

[NOTE]
====
考虑到压缩格式在代码大小和能量节约上的优势，我们希望在 ISA 编码方案中内置对压缩格式的支持，而不是事后补充。但为了简化实现，我们不想强制要求使用压缩格式。我们还希望可以选择支持更长的指令，以便于实验和更大的指令集扩展。尽管我们的编码约定要求对核心 RISC-V ISA 进行更紧凑的编码，但这带来了多个有利的效果。
(((IMAFD)))

对于标准 IMAFD ISA 的实现，指令缓存中只需存储指令的最高 30 位（节省 6.25%）。在指令缓存重新填充时，任何遇到的低位被清除的指令都应在存储到缓存之前被重新编码为非法的 30 位指令，以保留非法指令异常行为。

更重要的是，通过将基础 ISA 压缩到 32 位指令字的一部分，我们为非标准和自定义扩展留出了更多的编码空间。具体来说，基础 RV32I ISA 在 32 位指令字中使用的编码空间不到 1/8。如 <<extending>> 所述，对于不需要支持标准压缩指令扩展的实现，可以将 3 个额外的不符合规范的 30 位指令空间映射到 32 位固定宽度格式，同时保留对标准 ≥32 位指令集扩展的支持。此外，如果实现也不需要支持超过 32 位的指令长度，还可以额外恢复 4 个主操作码供不符合规范的扩展使用。
====

所有位 [15:0] 都为零的编码被定义为非法指令。这些指令被认为是最小长度：如果存在任何 16 位指令集扩展，则为 16 位；否则为 32 位。位 [ILEN-1:0] 全为 1 的编码也非法；这条指令被认为是 ILEN 位长。

[TIP]
====
我们认为，任何全零位的指令长度被定义为非法是一种特性，因为它可以快速捕获跳转到全零内存区域的错误跳转。同样，我们也将全一位的指令编码保留为非法指令，以捕获非编程的非易失性存储设备、断开的内存总线或损坏的内存设备中常见的这种模式。

软件可以依赖于一个自然对齐的 32 位全零字，在所有 RISC-V 实现上将其视为非法指令，以在需要显式非法指令的情况下使用。为全一位定义对应的非法值更为困难，因为存在可变长度编码。软件通常不能使用 ILEN 位全为 1 的非法值，因为软件可能无法确定最终目标机器的 ILEN（例如，当软件被编译为供多种不同机器使用的标准二进制库时）。我们曾考虑定义一个 32 位全一字为非法，因为所有机器都必须支持 32 位指令长度，但这会要求在 ILEN > 32 的机器上，指令取值单元在此类指令位于保护边界时报告非法指令异常，而不是访问错误异常，从而复杂化了可变指令长度的取值和解码。
====
(((endian, little and big)))
RISC-V 基础 ISA 支持小端（little-endian）或大端（big-endian）内存系统，而特权架构进一步定义了双端操作（bi-endian）。无论内存系统的字节序如何，指令都以 16 位小端格式的段（parcels）存储在内存中。这些段组成一条指令，并按增加的半字地址存储，其中最低地址的段包含指令规格中最低编号的位。
(((bi-endian)))
(((endian, bi-)))

[TIP]
====
我们最初为 RISC-V 内存系统选择小端（little-endian）字节序，是因为目前小端系统在商业上占主导地位（例如所有 x86 系统，以及 iOS、Android 和 Windows 的 ARM 系统）。一个小细节是，我们还发现小端内存系统对硬件设计者来说更为自然。然而，某些应用领域（例如 IP 网络）操作的是大端（big-endian）数据结构，而某些遗留代码库是基于大端处理器构建的，因此我们为 RISC-V 定义了大端和双端（bi-endian）变体。

我们必须固定指令段在内存中的存储顺序，与内存系统的字节序无关，以确保长度编码位始终在半字地址顺序中首先出现。这使得指令取值单元只需检查第一条 16 位指令段的前几位即可快速确定可变长度指令的长度。

此外，我们将指令段本身设计为小端，以完全将指令编码与内存系统的字节序解耦。这种设计对软件工具和双端硬件都有好处。例如，如果不这么做，RISC-V 的汇编器或反汇编器将始终需要知道当前活动的字节序模式，即使在双端系统中，这种模式可能会在执行期间动态改变。相比之下，通过为指令指定固定的字节序，有时可以使经过仔细编写的软件即使在二进制形式下也不依赖字节序，就像位置无关代码一样。

然而，选择仅支持小端的指令确实会对 RISC-V 软件带来一些影响，特别是涉及对机器指令进行编码或解码的情况。例如，大端的即时编译器（JIT）在将指令存储到指令内存时必须交换字节顺序。

当我们决定采用小端的指令编码时，这自然导致将长度编码位放在指令格式的最低有效位（LSB）位置，以避免打断操作码字段。
====

[[trap-defn]]
=== 异常、陷阱和中断

我们使用术语“异常”（exception）来指当前 RISC-V hart 上与一条指令相关联的运行时异常情况。术语“中断”（interrupt）则指外部的异步事件，它可能导致 RISC-V hart 发生意外的控制转移。术语“陷阱”（trap）指由异常或中断引发的控制转移到陷阱处理程序的过程。
(((exceptions)))
(((traps)))
(((interrupts)))

以下章节中的指令描述说明了执行过程中可能引发异常的条件。在大多数 RISC-V 执行环境接口（EEI）中，当指令上信号触发异常时，通常会发生陷阱并转移到某个处理程序（标准浮点扩展中的浮点异常除外，这些异常不会引发陷阱）。中断的生成、路由和启用方式取决于 EEI。

[NOTE]
====
我们对“异常”和“陷阱”的使用与 IEEE-754 浮点标准中的定义兼容。
====

陷阱的处理方式及其对运行在 hart 上的软件的可见性取决于所处的执行环境。从运行在某个执行环境中的软件角度来看，hart 在运行时遇到的陷阱可能有以下四种效果：

受控陷阱（Contained Trap）:::
  陷阱对运行在执行环境内的软件可见，并由其处理。例如，在一个提供 supervisor 模式和 user 模式的 EEI 中，user 模式 hart 的 ECALL 通常会导致控制转移到在同一 hart 上运行的 supervisor 模式处理程序。同样，在相同的环境中，当 hart 被中断时，中断处理程序将在 hart 的 supervisor 模式下运行。
请求陷阱（Requested Trap）:::
  这种陷阱是一个同步异常，明确请求执行环境为执行环境内的软件执行某项操作。例如，系统调用（system call）就是一个例子。在这种情况下，请求操作完成后，执行可能会也可能不会在 hart 上恢复。例如，一个系统调用可能移除该 hart，或导致整个执行环境的有序终止。
不可见陷阱（Invisible Trap）:::
  陷阱由执行环境透明处理，处理完成后执行正常恢复。例子包括模拟缺失的指令、在按需分页虚拟内存系统中处理非驻留页面错误，或在多任务机器中处理其他作业的设备中断。在这些情况下，运行在执行环境内的软件不会意识到陷阱的发生（在这些定义中忽略了时间效应）。
致命陷阱（Fatal Trap）:::
  陷阱代表致命失败，导致执行环境终止执行。例如，未通过虚拟内存页面保护检查，或允许看门狗计时器超时。每个 EEI 应定义如何终止执行以及如何向外部环境报告。

<<trapcharacteristics>> 显示了每种陷阱的特性。

[[trapcharacteristics, Table 2]]

[%autowidth,float="center",align="center",cols="<,^,^,^,^",options="header",]
|===
| |Contained |Requested |Invisible |Fatal
|Execution terminates |No |No^1^|No |Yes
|Software is oblivious |No |No |Yes |Yes^2^|Handled by environment |No |Yes |Yes |Yes
|===
<<trapcharacteristics>> 陷阱特性说明：1）执行终止可能是通过请求产生的。2）非精确的致命陷阱可能会被软件观察到。

EEI（执行环境接口）定义了每种陷阱是否需要精确处理，但建议尽可能保持精确性。在执行环境内部的软件中，受控陷阱和请求陷阱可能被观察为非精确的。根据定义，不可见陷阱无法被执行环境中的软件观察为精确或非精确的。如果已知错误的指令不会导致立即终止，执行环境内的软件可能观察到致命陷阱是非精确的。

由于本文档描述的是非特权指令，因此很少提及陷阱。用于处理受控陷阱的架构方法在特权架构手册中定义，同时还包括支持更丰富 EEI 的其他特性。专门为了引发请求陷阱而定义的非特权指令会在本文档中记录。不可见陷阱根据其性质不在本文档范围内。未在本文档中定义或通过其他方式未定义的指令编码可能会引发致命陷阱。

=== UNSPECIFIED 的行为和值
架构全面描述了实现中必须遵守的内容以及任何可能的约束。在某些情况下，架构有意不约束实现，此时会明确使用术语 UNSPECIFIED。
(((unspecified, behaviors)))
(((unspecified, values)))

术语 UNSPECIFIED 指的是有意不约束的行为或值。这些行为或值的定义可以由扩展、平台标准或具体实现来确定。扩展、平台标准或实现文档可以提供规范内容，以进一步约束基本架构定义为 UNSPECIFIED 的情况。

与基本架构类似，扩展应完全描述允许的行为和值，并在有意不约束的情况下使用术语 UNSPECIFIED。这些未约束的情况可以由其他扩展、平台标准或具体实现进一步约束或定义。
