[[counters]]  
== "Zicntr" 和 "Zihpm" 计数器扩展，版本 2.0  

RISC-V ISA 提供了一组最多 32 个 64 位的性能计数器和定时器，可通过非特权的 XLEN 位只读 CSR 寄存器 `0xC00`–`0xC1F` 访问（当 XLEN=32 时，上 32 位可通过 CSR 寄存器 `0xC80`–`0xC9F` 访问）。这些计数器被划分为 "Zicntr" 和 "Zihpm" 扩展。  

=== "Zicntr" 基本计数器和定时器扩展  

Zicntr 标准扩展包括前三个基本计数器（CYCLE、TIME 和 INSTRET），分别用于 CPU 周期计数、实时时钟和已提交指令数。Zicntr 扩展依赖于 Zicsr 扩展。  

[TIP]  
====  
我们建议在实现中提供这些基本计数器，因为它们对于基本性能分析、自适应和动态优化至关重要，并且允许应用程序处理实时数据流。Zihpm 扩展中的额外计数器有助于诊断性能问题，且应以低开销的方式向用户级应用程序代码开放访问。  

某些执行环境可能会禁止访问计数器，例如，为了防止时间侧信道攻击。  
====  

include::images/wavedrom/counters-diag.adoc[]  

对于 XLEN&#8805;64 的基本 ISA，CSR 指令可直接访问完整的 64 位 CSR。特别是，RDCYCLE、RDTIME 和 RDINSTRET 伪指令可读取 `cycle`、`time` 和 `instret` 计数器的完整 64 位数据。

[TIP]
====
计数器伪指令映射到只读的 `csrrs rd, counter, x0` 规范形式，但其他只读 CSR 指令形式（基于 CSRRC/CSRRSI/CSRRCI）也是读取这些 CSR 的合法方式。
====
对于 XLEN=32 的基本 ISA，Zicntr 扩展使这三个 64 位只读计数器可以以 32 位片段访问。RDCYCLE、RDTIME 和 RDINSTRET 伪指令提供低 32 位，而 RDCYCLEH、RDTIMEH 和 RDINSTRETH 伪指令提供各自计数器的高 32 位。
[TIP]
====
我们要求计数器即使在 XLEN=32 时也要有 64 位宽度，否则软件很难确定值是否溢出。对于低端实现，每个计数器的高 32 位可以使用由下 32 位溢出触发的陷阱处理程序递增的软件计数器来实现。下面的示例代码展示了如何使用单个 32 位宽度的伪指令安全地读取完整的 64 位宽度值。
====

RDCYCLE 伪指令读取 `cycle` CSR 的低 XLEN 位，该 CSR 保存处理器核心从过去某个任意起始时间执行的时钟周期数。当 XLEN=32 时，RDCYCLEH 仅存在并读取相同周期计数器的 63-32 位。基础 64 位计数器在实践中不应溢出。周期计数器前进的速率将取决于实现和操作环境。执行环境应提供一种方法来确定周期计数器递增的当前速率（周期/秒）。
[TIP]
====
RDCYCLE 旨在返回处理器核心执行的周期数，而不是硬件线程。由于某些实现选择（例如，AMD Bulldozer），精确定义什么是“核心”是困难的。精确定义什么是“时钟周期”也很困难，因为实现范围很广（包括软件仿真），但 RDCYCLE 的目的是与其他性能计数器一起用于性能监控。特别是，当一个硬件线程/核心时，人们会期望周期计数/指令退休来衡量硬件线程的 CPI。

核心不必完全暴露给软件，实施者可能会选择假装一个物理核心上的多个硬件线程在单独的核心上运行，每个硬件线程/核心提供单独的周期计数器。这在一个简单的桶式处理器（例如，CDC 6600 外围处理器）中可能有意义，其中硬件线程之间的时间交互是不存在或最小的。

当有多个硬件线程/核心和动态多线程时，通常不可能分离出每个硬件线程的周期数（尤其是 SMT）。可能定义一个单独的性能计数器来尝试捕获特定硬件线程运行的周期数，但这个定义必须非常模糊，以涵盖所有可能的线程实现。例如，我们是否只计算为该硬件线程执行的任何指令发出的周期，和/或任何指令退休的周期，或者包括该硬件线程占用机器资源但由于其他硬件线程进入执行而无法执行的周期？可能，“以上所有”都需要有可理解的性能统计数据。这种定义每个硬件线程周期计数的复杂性，以及在调整多线程代码时无论如何都需要一个总的每核心周期计数，导致只标准化每核心周期计数，这也恰好适用于常见的单硬件线程/核心情况。

标准化“睡眠”期间发生的事情是不切实际的，因为“睡眠”的含义在不同的执行环境中并不统一，但如果整个核心暂停（完全时钟门控或在深度睡眠中断电），那么它就不会执行时钟周期，并且周期计数不应根据规范增加。有许多细节，例如，唤醒后重置处理器所需的时钟周期是否应计数，这些被认为是执行环境特定的细节。

即使没有适用于所有平台的精确定义，这对于大多数平台来说仍然是一个有用的功能，一个不精确的、常见的、“通常正确”的标准比没有标准要好。RDCYCLE 的目的是主要用于性能监控/调优，规范是以此为目标编写的。
====
RDTIME 伪指令读取“time” CSR 的低 XLEN 位，该 CSR 计算从过去某个任意起始时间起经过的挂钟时间。当 XLEN=32 时，RDTIMEH 仅存在并读取相同实时计数器的 63-32 位。基础 64 位计数器随着每个实时时钟的节拍递增，对于现实的实时时钟频率，实际上不应溢出。执行环境应提供一种方法来确定计数器节拍的周期（秒/节拍）。该周期应在一个小的误差范围内保持恒定。环境应提供一种方法来确定时钟的准确性（即，标称和实际实时时钟周期之间的最大相对误差）。
[TIP]
====
在一些简单的平台上，周期计数可能是 RDTIME 的有效实现，在这种情况下，RDTIME 和 RDCYCLE 可能返回相同的结果。

鉴于可能的实现平台种类繁多，很难对时钟周期进行严格的规定。最大误差范围应根据平台的要求设定。
====

所有硬件线程的实时时钟必须同步到实时时钟的一个节拍内。
[TIP]
====
与其他架构规定一样，只要看起来“好像”硬件线程同步到实时时钟的一个节拍内即可，即软件无法观察到两个硬件线程上观察到的实时时钟值之间存在更大的差异。
====
RDINSTRET 伪指令读取 `instret` CSR 的低 XLEN 位，该 CSR 计算从过去某个任意起始点起该硬件线程退休的指令数。当 XLEN=32 时，RDINSTRETH 仅存在并读取相同指令计数器的 63-32 位。基础 64 位计数器在实践中不应溢出。
[TIP]
====
引起同步异常的指令，包括 ECALL 和 EBREAK，不被视为退休，因此不会增加 `instret` CSR。
====
以下代码序列将读取一个有效的 64 位周期计数器值到 `x3:x2` 中，即使计数器在读取其高半部分和低半部分之间溢出。

[source,asm.]
.当 XLEN=32 时读取 64 位周期计数器的示例代码。
    again:
        rdcycleh     x3
        rdcycle      x2
        rdcycleh     x4
        bne          x3, x4, again


=== "Zihpm" 扩展用于硬件性能计数器

Zihpm 扩展包括多达 29 个额外的非特权 64 位硬件性能计数器，`hpmcounter3-hpmcounter31`。当 XLEN=32 时，这些性能计数器的高 32 位可以通过额外的 CSR `hpmcounter3h-hpmcounter31h` 访问。Zihpm 扩展依赖于 Zicsr 扩展。
[TIP]
====
在某些应用中，能够在同一时间读取多个计数器是很重要的。当在多任务环境下运行时，用户线程在尝试读取计数器时可能会遭遇上下文切换。解决方案之一是用户线程在读取其他计数器之前和之后读取实时计数器，以确定在读取序列中是否发生了上下文切换，在这种情况下可以重试读取。我们曾考虑添加输出锁存器以允许用户线程原子地快照计数器值，但这会增加用户上下文的大小，特别是对于具有更多计数器集的实现。
====

这些额外计数器的实现数量与宽度，以及它们计数的事件集，是平台相关的。访问未实现或配置错误的计数器可能会导致非法指令异常或返回常数值。

执行环境应提供一种方法来确定已实现计数器的数量和宽度，以及配置每个计数器要计数的事件的接口。
[TIP]
====
对于在 RISC-V 特权平台上实现的执行环境，特权架构手册描述了控制低特权模式访问这些计数器的特权 CSR，并设置要计数的事件。

替代执行环境（例如：仅用户级的软件性能模型）可能提供替代机制来配置性能计数器计数的事件。

最终标准化事件设置以计数 ISA 级别的指标，例如执行的浮点指令数量，以及一些可能常见的微架构指标，例如“L1 指令缓存未命中”，将非常有用。
====