[[counters]]  
== "Zicntr" 和 "Zihpm" 计数器扩展，版本 2.0  

RISC-V ISA 提供了一组最多 32 个 64 位的性能计数器和定时器，用户可以通过非特权的 XLEN 位只读 CSR 寄存器 `0xC00`–`0xC1F` 进行访问（当 XLEN=32 时，上 32 位可通过 CSR 寄存器 `0xC80`–`0xC9F` 访问）。这些计数器被划分为 "Zicntr" 和 "Zihpm" 扩展。  

=== "Zicntr" 基本计数器和定时器扩展  

Zicntr 标准扩展包括前三个基本计数器（CYCLE、TIME 和 INSTRET），分别用于 CPU 周期计数、实时时钟和已提交指令数。Zicntr 扩展依赖于 Zicsr 扩展。  

[TIP]  
====  
我们建议在实现中提供这些基本计数器，因为它们对于基本性能分析、自适应和动态优化至关重要，并且允许应用程序处理实时数据流。Zihpm 扩展中的额外计数器有助于诊断性能问题，且应以低开销的方式向用户级应用程序代码开放访问。  

某些执行环境可能会禁止访问计数器，例如，为了防止时间侧信道攻击。  
====  

include::images/wavedrom/counters-diag.adoc[]  

对于 XLEN ≥ 64 的基本 ISA，CSR 指令可直接访问完整的 64 位 CSR。特别地，RDCYCLE、RDTIME 和 RDINSTRET 伪指令可读取 `cycle`、`time` 和 `instret` 计数器的完整 64 位数据。

[TIP]
====  
计数器伪指令映射到只读的 `csrrs rd, counter, x0` 规范形式，但其他只读 CSR 指令形式（基于 CSRRC/CSRRSI/CSRRCI）也是读取这些 CSR 的合法方式。
====  
对于 XLEN=32 的基本 ISA，Zicntr 扩展使得这三个 64 位只读计数器可以以 32 位片段进行访问。RDCYCLE、RDTIME 和 RDINSTRET 伪指令提供低 32 位，而 RDCYCLEH、RDTIMEH 和 RDINSTRETH 伪指令提供各自计数器的高 32 位。  

[TIP]  
====  
我们要求计数器即使在 XLEN=32 时也必须具有 64 位宽度，否则软件很难判断值是否溢出。对于低端实现，每个计数器的高 32 位可以通过由低 32 位溢出触发的陷阱处理程序递增的软件计数器来实现。下面的示例代码展示了如何使用单个 32 位宽度的伪指令安全地读取完整的 64 位值。
====  

RDCYCLE 伪指令读取 `cycle` CSR 的低 XLEN 位，该 CSR 保存处理器核心从某个任意起始时间开始执行的时钟周期数。当 XLEN=32 时，RDCYCLEH 仅存在并读取相同周期计数器的 63-32 位。基础 64 位计数器不应溢出。周期计数器的递增速率将取决于实现和操作环境。执行环境应提供一种方法来确定周期计数器递增的当前速率（周期/秒）。  

[TIP]  
====  
RDCYCLE 的目的是返回处理器核心执行的周期数，而非硬件线程的周期数。由于某些实现（例如 AMD Bulldozer），精确定义“核心”是困难的。精确定义“时钟周期”同样具有挑战性，因为实现方式差异较大（包括软件仿真）。然而，RDCYCLE 的主要目的是与其他性能计数器一起用于性能监控。特别地，当只有一个硬件线程/核心时，周期计数/指令退休可用来衡量硬件线程的 CPI。

核心不必完全暴露给软件，实施者可能会选择将一个物理核心上的多个硬件线程伪装成运行在独立核心上的线程，每个硬件线程/核心提供独立的周期计数器。这在某些简单的桶式处理器（例如 CDC 6600 外围处理器）中可能有意义，在这种架构中，硬件线程之间的时间交互要么不存在，要么非常小。

当有多个硬件线程/核心以及动态多线程时，通常无法准确区分每个硬件线程的周期数（尤其是在 SMT 中）。可能会定义一个单独的性能计数器来捕获特定硬件线程执行的周期数，但这种定义必须非常模糊，以适应所有可能的线程实现。例如，我们是否仅计算该硬件线程执行的任何指令所经历的周期，或者包括指令退休时的周期，抑或是包括该硬件线程因其他硬件线程执行而无法执行的周期？可能需要考虑“以上所有情况”才能提供可理解的性能统计数据。这种定义每个硬件线程周期计数的复杂性，以及调整多线程代码时对每核心周期计数的需求，导致标准化每核心周期计数成为最佳选择，这对于常见的单硬件线程/核心情况也同样适用。

标准化“睡眠”期间发生的情况并不现实，因为“睡眠”在不同的执行环境中并没有统一定义。但如果整个核心进入暂停状态（完全时钟门控或深度睡眠中断电），则核心不会执行时钟周期，周期计数应按照规范保持不变。细节部分，如是否应计数唤醒后处理器恢复所需的时钟周期等，视为特定执行环境的细节。

尽管没有适用于所有平台的精确定义，但对大多数平台而言，这仍然是一个有用的功能。一个不精确、常见的、通常正确的标准比没有标准要好。RDCYCLE 的设计初衷是用于性能监控和调优，规范的编写目标正是围绕这一点展开的。  

====  
RDTIME 伪指令读取 "time" CSR 的低 XLEN 位，该 CSR 计算从过去某个任意起始时间起经过的实际时间。当 XLEN=32 时，RDTIMEH 仅存在并读取相同实时计数器的 63-32 位。基础 64 位计数器随着每个实时时钟的节拍递增，对于实际的实时时钟频率，实际上不应溢出。执行环境应提供一种方法来确定计数器节拍的周期（秒/节拍）。该周期应在一个小的误差范围内保持恒定。环境应提供一种方法来确定时钟的准确性（即标称和实际实时时钟周期之间的最大相对误差）。  

[TIP]  
====  
在一些简单的平台上，周期计数可能是 RDTIME 的有效实现，在这种情况下，RDTIME 和 RDCYCLE 可能返回相同的结果。

鉴于可能的实现平台种类繁多，很难对时钟周期进行严格的规定。最大误差范围应根据平台的要求设定。
====  

所有硬件线程的实时时钟必须同步到实时时钟的一个节拍内。  

[TIP]  
====  
与其他架构规定一样，只要看起来“好像”硬件线程同步到实时时钟的一个节拍内即可，即软件无法观察到两个硬件线程上观察到的实时时钟值之间存在更大的差异。
====  

RDINSTRET 伪指令读取 `instret` CSR 的低 XLEN 位，该 CSR 计算从过去某个任意起始点起该硬件线程退休的指令数。当 XLEN=32 时，RDINSTRETH 仅存在并读取相同指令计数器的 63-32 位。基础 64 位计数器在实践中不应溢出。  

[TIP]  
====  
引起同步异常的指令，包括 ECALL 和 EBREAK，不被视为退休，因此不会增加 `instret` CSR。
====  

以下代码序列将读取一个有效的 64 位周期计数器值到 `x3:x2` 中，即使计数器在读取其高半部分和低半部分之间溢出。  

[source,asm.]  
.当 XLEN=32 时读取 64 位周期计数器的示例代码。  
    again:  
        rdcycleh     x3  
        rdcycle      x2  
        rdcycleh     x4  
        bne          x3, x4, again  

=== "Zihpm" 扩展用于硬件性能计数器  

Zihpm 扩展包括多达 29 个额外的非特权 64 位硬件性能计数器，`hpmcounter3-hpmcounter31`。当 XLEN=32 时，这些性能计数器的高 32 位可以通过额外的 CSR `hpmcounter3h-hpmcounter31h` 访问。Zihpm 扩展依赖于 Zicsr 扩展。  

[TIP]  
====  
在某些应用中，能够在同一时间读取多个计数器是很重要的。当在多任务环境下运行时，用户线程在尝试读取计数器时可能会遭遇上下文切换。解决方案之一是用户线程在读取其他计数器之前和之后读取实时计数器，以确定在读取序列中是否发生了上下文切换，在这种情况下可以重试读取。我们曾考虑添加输出锁存器以允许用户线程原子地快照计数器值，但这会增加用户上下文的大小，特别是对于具有更多计数器集的实现。
====  

这些额外计数器的实现数量与宽度，以及它们计数的事件集，是平台相关的。访问未实现或配置错误的计数器可能会导致非法指令异常或返回常数值。

执行环境应提供一种方法来确定已实现计数器的数量和宽度，以及配置每个计数器要计数的事件的接口。  

[TIP]  
====  
对于在 RISC-V 特权平台上实现的执行环境，特权架构手册描述了控制低特权模式访问这些计数器的特权 CSR，并设置要计数的事件。  

替代执行环境（例如：仅用户级的软件性能模型）可能提供替代机制来配置性能计数器计数的事件。  

最终标准化事件设置在计数 ISA 级别的指标方面非常重要，例如执行的浮点指令数量，以及一些可能常见的微架构指标，例如“L1 指令缓存未命中”。
====
