== “Zawrs”扩展：等待预留集指令, 版本 1.01

Zawrs 扩展定义了一对用于轮询的指令，进入低功耗的暂停执行状态并等待对内存位置的存储操作。等待某一内存的数据被更新是很常见的情况，例如：

. 某个尝试获取锁的线程正在等待锁变量的更新。

. 消费者正在等待生产者将工作/数据加入一个空的等待队列。在 RISC-V 硬件线程中，生产者可能是硬件线程上正在执行的代码，加速器设备或者外部 I/O 代理等。

. 代码正在等待内存中的标志位被设置，以指示某个事件的发生。例如，RISC-V 处理器硬件线程上的软件可能等待加速器设备在内存中设置“完成”标志，以指示之前提交给设备的作业已完成。

这些例子涉及对内存位置的轮询，在这些情况下采用忙等待循环可能会浪费大量能源。为了减轻此类用法中的浪费循环，提供了 WRS.NTO（无超时的 WRS）指令。与轮询特定内存位置的存储不同，软件会使用 LR 指令注册一个包含某一内存位置所有字节的预留集。然后，WRS.NTO 指令会使得硬件线程暂时停止执行并进入低功耗状态，直到发生对预留集的存储操作或观察到中断。

有时，等待内存更新的程序可能还需要在未来执行任务或对等待时间设置上限。为了支持这类情况，该扩展还提供了另一条指令 WRS.STO（带短超时的 WRS），其工作方式类似于 WRS.NTO ，但将停顿持续时间限制在一个由指令具体实现定义的短超时时间，使得如果没有其他终止停顿的条件，停顿将在超时时终止。使用此指令的程序可以随后确定是否已达到其截止时间。

[NOTE]
====
Zawrs 扩展中的指令只有在配合 LR 指令时才能起作用，后者由 A 扩展的 Zalrsc 部分提供。
====
[[Zawrs]]
=== 等待预留集指令

WRS.NTO 和 WRS.STO 指令会使得硬件线程在预留集有效且未观察到待处理中断（即使是中断已经被禁用）的情况下，暂时停止执行并进入低功耗状态。对于 WRS.STO 指令而言，停顿持续时间被一个由指令具体的实现定义的短超时时间限制。这些指令在所有特权模式下都可用。这些指令在受限的 LR/SC循环中不被支持。

[wavedrom, ,svg]
....
{reg: [
  {bits: 7, name: 'opcode', attr: ['SYSTEM(0x73)'] },
  {bits: 5, name: 'rd', attr: ['0'] },
  {bits: 3,  name: 'funct3', attr: ['0'] },
  {bits: 5,  name: 'rs1', attr: ['0'] },
  {bits: 12,  name: 'funct12', attr:['WRS.NTO(0x0d)', 'WRS.STO(0x1d)'] },
], config:{lanes: 1, hspace:1024}}
....

<<<

当以下所有条件同时成立时，硬件线程的执行可能进入暂停状态：
[loweralpha]
    . 预留集有效
    . 对于 `WRS.STO` 而言，从停顿到现在尚未超过短超时时间的限制
    . 未观察到待处理的中断（具体规则见下）

在停顿期间，允许实现偶尔终止停顿，并因任何原因完成执行。

WRS.NTO 和 WRS.STO 指令遵循 WFI 指令的规则，当有挂起的中断时，恢复执行。

当 mstatus 中的 TW （超时等待）位为 1 ，而 WRS.NTO 正在 M 模式以外的任何特权模式下执行，并且在实现所特别规定的有界时间限制内未完成，WRS.NTO 指令将导致非法指令异常。

在 VS 或 VU 模式下执行时，如果 hstatus 寄存器中的 VTW 位被设置， mstatus 寄存器中的 TW 位值为 0 ，且 WRS.NTO 在实现特定的有界时间限制内未完成，WRS.NTO 指令将导致虚拟指令异常。

[NOTE]
====
由于 WRS.STO 和 WRS.NTO 指令可能由于除预留集存储以外的原因完成执行，软件可能需要一种循环方法，直到所需的存储操作已发生。

WRS.STO 指令超时的持续时间可能在不同实现中以及同一实现的不同情况下有显著变化。在典型的实现中，这个持续时间应该大致处于片上缓存未命中延迟或无缓存访问主内存延迟的 10 到 100 倍范围。

与 WFI 指令不同，即使在 U 模式下执行且对应的 TW 位为 0 时，WRS.NTO 指令也不会被定义为引发非法指令异常。WFI 指令通常不适用于 U 模式，在许多系统中，于 U 模式下使用 WFI 指令可能会立即导致非法指令异常。与 WFI 不同，WRS.NTO 更适用于软件在 U 模式下进行无截止时间的内存等待。
====
