[[csrinsts]]
== "Zicsr", 控制和状态寄存器（CSR）指令扩展，版本 2.0

RISC-V 为每个硬件线程定义了一个独立的 4096 个控制和状态寄存器（CSR）的地址空间。本章定义了操作这些 CSR 的完整指令集。

[NOTE]
====
虽然 CSR 主要用于特权架构，但在非特权代码中也有多种用途，包括计数器和定时器，以及浮点状态。

计数器和定时器不再被视为标准基本 ISA 的强制部分，因此访问它们所需的 CSR 指令已从 <<rv32>> 移至本章。
====

=== CSR 指令

所有 CSR 指令都原子性地读-修改-写单个 CSR，其 CSR 指定符编码在指令的 12 位 _csr_ 字段中，位于 31-20 位。立即数格式采用 rs1 字段中编码的 5 位零扩展立即数。

include::images/wavedrom/csr-instr.adoc[]

CSRRW（原子读/写 CSR）指令原子性地交换 CSR 和整数寄存器中的值。CSRRW 读取 CSR 的旧值，将其零扩展到整数寄存器字长位，然后写入整数寄存器 _rd_。初始值在 _rs1_ 中写入 CSR。如果 _rd_=`x0`，则指令不读取 CSR，也不会引起任何可能在 CSR 读取时发生的副作用。

CSRRS（原子读和设置 CSR 中的位）指令读取 CSR 的值，将其零扩展到整数寄存器字长位，并写入整数寄存器 _rd_。整数寄存器 _rs1_ 中的初始值被视为一个位掩码，指定要在 CSR 中设置的位位置。_rs1_ 中的任何高位将导致相应的 CSR 位被设置，如果该 CSR 位是可写的。

CSRRC（原子读和清除 CSR 中的位）指令读取 CSR 的值，将其零扩展到整数寄存器字长位，并写入整数寄存器 _rd_。整数寄存器 _rs1_ 中的初始值被视为一个位掩码，指定要在 CSR 中清除的位位置。_rs1_ 中的任何高位将导致相应的 CSR 位被清除，如果该 CSR 位是可写的。

对于 CSRRS 和 CSRRC，如果 _rs1_=`x0`，则指令不会写入 CSR，因此不会引起任何可能在 CSR 写入时发生的副作用，也不会在访问只读 CSR 时引发非法指令异常。无论 _rs1_ 和 _rd_ 字段如何，CSRRS 和 CSRRC 总是读取指定的 CSR 并引起任何读取副作用。注意，如果 _rs1_ 指定了一个非 `x0` 的寄存器，并且该寄存器持有零值，则指令不会执行任何字段级别的副作用，但会执行写入整个 CSR 时的任何副作用。

CSRRW 与 _rs1_=`x0` 将尝试将零写入目标 CSR。

CSRRWI、CSRRSI 和 CSRRCI 变体类似于 CSRRW、CSRRS 和 CSRRC，只是它们使用在 _rs1_ 字段中编码的 5 位无符号立即数（uimm[4:0]）零扩展得到的整数寄存器字长位值来更新 CSR，而不是来自整数寄存器的值。对于 CSRRSI 和 CSRRCI，如果 uimm[4:0] 字段为零，则这些指令不会写入 CSR，并且不会引起任何可能在 CSR 写入时发生的副作用，也不会在访问只读 CSR 时引发非法指令异常。对于 CSRRWI，如果 _rd_=`x0`，则指令不会读取 CSR，也不会引起任何可能在 CSR 读取时发生的副作用。无论 _rd_ 和 _rs1_ 字段如何，CSRRSI 和 CSRRCI 总是读取 CSR 并引起任何读取副作用。

[[csrsideeffects]]
.确定 CSR 指令是否读取或写入指定 CSR 的条件。
[%autowidth,float="center",align="center",cols="<,^,^,^,^",options="header",]
|===
5+^|*寄存器操作数* 
|指令 |_rd_为 `x0` |_rs1_为 `x0` |读取 CSR |写入 CSR

|CSRRW |是 |- |否 |是

|CSRRW |否 |- |是 |是

|CSRRS/CSRRC |- |是 |是 |否

|CSRRS/CSRRC |- |否 |是 |是

5+^|*立即数操作数* 

|指令 |_rd_为 `x0` |__uimm__latexmath:[$=$]0 |读取 CSR |写入 CSR

|CSRRWI |是 |- |否 |是

|CSRRWI |否 |- |是 |是

|CSRRSI/CSRRCI |- |是 |是 |否

|CSRRSI/CSRRCI |- |否 |是 |是
|===

<<csrsideeffects>>总结了 CSR 指令在读取和/或写入 CSR 方面的行为。

除了由于读取或写入 CSR 而发生的副作用外，CSR 中的各个字段在写入时可能会有副作用。CSRRW[I] 指令对写入的 CSR 中的所有此类字段执行副作用。CSRRS[I] 和 CSRRC[I] 指令仅对 _rs1_ 或 _uimm_ 参数中至少有一个位设置对应字段的字段执行副作用。
[NOTE]
====
截至本文撰写时，没有标准 CSR 在字段写入时有副作用。因此，标准 CSR 访问是否有任何副作用可以仅从操作码确定。

不建议定义在字段写入时有副作用的 CSR。
====

对于由于 CSR 具有特定值而发生的任何事件或结果，如果写入 CSR 使其具有该值，则该写入的结果事件或结果被称为该写入的 _间接效果_。CSR 写入的间接效果不被 RISC-V ISA 视为该写入的副作用。
[NOTE]
====
CSR 访问副作用的一个例子是，如果从特定 CSR 读取会导致灯泡亮起，而写入奇数值会导致灯泡熄灭。假设写入偶数值没有效果。在这种情况下，读取和写入都有控制灯泡是否点亮的副作用，因为这种情况不仅仅由 CSR 值决定。（注意，在写入奇数值以关闭灯泡后，再次读取以点亮灯泡，再次写入相同的奇数值会导致灯泡再次熄灭。因此，在最后一次写入时，不是 CSR 值的变化导致灯泡熄灭。）

另一方面，如果灯泡被设置为在特定 CSR 值为奇数时点亮，则点亮和熄灭灯泡不被视为写入 CSR 的副作用，而仅仅是这种写入的间接效果。

更具体地说，RISC-V 特权架构在第二卷中规定，某些 CSR 值组合会导致陷阱发生。当显式写入 CSR 创建触发陷阱的条件时，陷阱不被视为写入的副作用，而仅仅是这种写入的间接效果。

标准 CSR 在读取时没有任何副作用。标准 CSR 在写入时可能有副作用。自定义扩展可能会添加在读取或写入时有副作用的 CSR。
====
某些 CSR，例如指令退休计数器 `instret`，可能会作为指令执行的副作用而被修改。在这些情况下，如果 CSR 访问指令读取 CSR，它会读取指令执行前的值。如果 CSR 访问指令写入此类 CSR，则写入将代替递增。特别是，一条指令写入的值将是下一条指令读取的值。

汇编伪指令读取 CSR，CSRR _rd, csr_，编码为 CSRRS _rd, csr, x0_。汇编伪指令写入 CSR，CSRW _csr, rs1_，编码为 CSRRW _x0, csr, rs1_，而 CSRWI _csr, uimm_，编码为 CSRRWI _x0, csr, uimm_。

进一步的汇编伪指令定义为在不需要旧值时设置和清除 CSR 中的位：CSRS/CSRC _csr, rs1_; CSRSI/CSRCI _csr, uimm_。

每个 RISC-V 硬件线程通常按程序顺序观察其自己的 CSR 访问，包括其隐式 CSR 访问。特别是，除非另有规定，CSR 访问在程序顺序中任何先前指令执行之后执行，这些指令的行为修改或被 CSR 状态修改，并且在程序顺序中任何后续指令执行之前执行，这些指令的行为修改或被 CSR 状态修改。此外，显式 CSR 读取返回指令执行前的 CSR 状态，而显式 CSR 写入抑制并覆盖同一指令对同一 CSR 的任何隐式写入或修改。

同样，显式 CSR 访问的任何副作用通常按程序顺序同步观察。除非另有规定，任何此类副作用的全部后果在下一条指令中可观察到，并且前面的指令不会观察到任何乱序的后果。（注意前面提到的 CSR 写入的副作用和间接效果之间的区别。）

对于 RVWMO 内存一致性模型（<<memorymodel>>），CSR 访问默认是弱排序的，因此其他硬件线程或设备可能会以不同于程序顺序的顺序观察 CSR 访问。此外，除非 CSR 访问修改执行显式内存访问的指令的行为，或者 CSR 访问和显式内存访问由内存模型定义的语法依赖关系或本手册第二卷中定义的内存排序 PMA 要求排序，否则 CSR 访问与显式内存访问之间没有排序。为了在所有其他情况下强制排序，软件应在相关访问之间执行 FENCE 指令。对于 FENCE 指令的目的，CSR 读取访问被分类为设备输入（I），CSR 写入访问被分类为设备输出（O）。
[NOTE]
====
非正式地，CSR 空间充当弱排序的内存映射 I/O 区域，如本手册第二卷中内存排序 PMA 部分定义的那样。因此，CSR 访问与所有其他访问的顺序由约束内存映射 I/O 访问到此类区域的相同机制约束。

这些 CSR 排序约束旨在支持与设备或其他硬件线程可见的 CSR 访问相关的主内存和内存映射 I/O 访问的排序。示例包括 `time`、`cycle` 和 `mcycle` CSR，以及反映挂起中断的 CSR，如 `mip` 和 `sip`。注意，此类 CSR 的隐式读取（例如，由于 `mip` 的变化而中断）也按设备输入排序。

大多数 CSR（包括例如 `fcsr`）对其他硬件线程不可见；它们的访问可以在全局内存顺序中自由重新排序，而不会违反本规范。
====
硬件平台可以定义某些 CSR 访问是强排序的，如本手册第二卷中内存排序 PMA 部分定义的那样。对强排序 CSR 的访问在与弱排序 CSR 和内存映射 I/O 区域的访问方面具有更强的排序约束。

[NOTE]
====
CSR 访问在全局内存顺序中的重新排序规则可能应移至 <<memorymodel>> 中有关 RVWMO 内存一致性模型的部分。
====
