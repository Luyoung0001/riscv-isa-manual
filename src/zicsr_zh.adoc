[[csrinsts]]
== "Zicsr" 拓展： 控制状态寄存器（CSR）指令，版本 2.0

RISC-V 定义了一个与每个硬件线程相关联的 4096 个控制状态寄存器（CSR）的独立地址空间。本章定义了操作这些 CSR 的完整 CSR 指令集。

[NOTE]
====
虽然控制状态寄存器（CSR）主要用于特权架构，但在非特权代码中也有多种应用，包括计数器、定时器以及浮点状态。

计数器和定时器不再是标准基本指令集（ISA）中的必需部分，因此访问这些寄存器的相关 CSR 指令已从 <<rv32>> 中移出，并单独归入本章。
====

=== 控制状态寄存器指令

所有控制状态寄存器指令都原子性地读-修改-写单个控制状态寄存器，其控制状态寄存器指定符编码在指令的 12 位 _csr_ 字段中，位于 31-20 位。立即数格式采用 rs1 字段中编码的 5 位零扩展立即数。

include::images/wavedrom/csr-instr.adoc[]

CSRRW（原子读/写控制状态寄存器）指令原子性地交换控制状态寄存器和整数寄存器中的值。CSRRW 首先读取控制状态寄存器的旧值，将其零扩展到 XLEN 位，然后将扩展后的值写入整数寄存器 _rd_。紧接着，_rs1_ 中的初始值被写入控制状态寄存器。如果 _rd_=`x0`，则该指令不会读取控制状态寄存器，也不会引发任何可能在读取控制状态寄存器时产生的副作用。

CSRRS（原子读并设置控制状态寄存器中的位）指令读取控制状态寄存器的值，将其零扩展到 XLEN 位，并将结果写入整数寄存器 _rd_。整数寄存器 _rs1_ 中的初始值被视为位掩码，指定要设置的控制状态寄存器中的位位置。_rs1_ 中的任何高位都会导致相应的控制状态寄存器位被设置，前提是该位是可写的。

CSRRC（原子读并清除控制状态寄存器中的位）指令读取控制状态寄存器的值，将其零扩展到 XLEN 位，并将结果写入整数寄存器 _rd_。整数寄存器 _rs1_ 的初始值作为位掩码，指定在控制状态寄存器中需要清除的位。_rs1_ 中的任何非零位会清除相应控制寄存器中的位，前提是该位可写。

对于 CSRRS 和 CSRRC，如果 _rs1_=`x0`，则指令不会写入控制状态寄存器，因此不会引起任何可能在控制状态寄存器写入时发生的副作用，也不会在访问只读控制寄存器时引发非法指令异常。无论 _rs1_ 和 _rd_ 的值如何，CSRRS 和 CSRRC 总是读取指定的控制状态寄存器，并引起任何读取时的副作用。注意，如果 _rs1_ 指定的是一个非 `x0` 的寄存器，且该寄存器的值为零，则指令不会触发任何字段级副作用，但会执行写入整个控制寄存器时产生的副作用。

CSRRW 与 _rs1_=`x0` 将尝试将零写入目标控制状态寄存器。

CSRRWI、CSRRSI 和 CSRRCI 变体类似于 CSRRW、CSRRS 和 CSRRC，但它们使用通过零扩展 _rs1_ 字段中编码的 5 位无符号立即数（uimm[4:0]）得到的 XLEN 位值来更新控制状态寄存器，而非来自整数寄存器的值。对于 CSRRSI 和 CSRRCI，如果 uimm[4:0] 字段为零，这些指令将不写入控制寄存器，也不会引发任何副作用，也不会在访问只读控制状态寄存器时触发非法指令异常。对于 CSRRWI，如果 _rd_=`x0`，则指令不会读取状态控制寄存器，也不会引发任何与读取控制寄存器相关的副作用。无论 _rd_ 和 _rs1_ 字段如何，CSRRSI 和 CSRRCI 始终会读取控制状态寄存器并引发读取副作用。

[[csrsideeffects]]
.确定控制状态寄存器指令是否读取或写入指定控制状态寄存器的条件。
[%autowidth,float="center",align="center",cols="<,^,^,^,^",options="header",]
|===
5+^|*寄存器操作数*
|指令 |_rd_为 `x0` |_rs1_为 `x0` |读取控制状态寄存器 |写入控制状态寄存器

|CSRRW |是 |- |否 |是

|CSRRW |否 |- |是 |是

|CSRRS/CSRRC |- |是 |是 |否

|CSRRS/CSRRC |- |否 |是 |是

5+^|*立即数操作数*

|指令 |_rd_为 `x0` |__uimm__latexmath:[$=$]0 |读取控制状态寄存器 |写入控制状态寄存器

|CSRRWI |是 |- |否 |是

|CSRRWI |否 |- |是 |是

|CSRRSI/CSRRCI |- |是 |是 |否

|CSRRSI/CSRRCI |- |否 |是 |是
|===

<<csrsideeffects>>总结了控制状态寄存器指令在读取和/或写入控制状态寄存器方面的行为。

除了由于读取或写入控制状态寄存器而发生的副作用外，控制状态寄存器中的各个字段在写入时可能会产生副作用。CSRRW[I] 指令对写入的控制状态寄存器中的所有此类字段执行副作用。CSRRS[I] 和 CSRRC[I] 指令仅对 _rs1_ 或 _uimm_ 参数中至少有一个位设置对应字段的字段执行副作用。
[NOTE]
====
截至本文撰写时，没有标准控制状态寄存器在字段被写入的时候有副作用。因此，标准控制状态寄存器访问是否有任何副作用可以仅从操作码确定。

不推荐定义在字段写入时会引发副作用的控制状态寄存器。
====

对于由于控制状态寄存器具有特定值而发生的任何事件或结果，如果通过写入控制状态寄存器使其获得该值，那么所产生的事件或后果被称为该写入的 _间接效果_。控制状态寄存器写入的 _间接效果_ 不被 RISC-V ISA 视为该写入的副作用。
[NOTE]
====
控制状态寄存器访问副作用的一个例子是，如果从特定控制状态寄存器读取会导致灯泡亮起，而写入奇数值会导致灯泡熄灭，假设写入偶数值没有效果。在这种情况下，读取和写入都会控制灯泡是否点亮，因此这两个操作都有副作用，因为灯泡的状态不仅由控制状态寄存器的值决定。（注意，在写入奇数值使灯泡熄灭后，读取控制状态寄存器会使灯泡重新点亮，再次写入相同的奇数值会导致灯泡再次熄灭。因此，最后一次写入时，灯泡熄灭并非由于控制状态寄存器值的变化。）

另一方面，如果灯泡的亮灭与特定控制状态寄存器值是否为奇数相关，则点亮和熄灭灯泡不被视为写入控制状态寄存器的副作用，而仅仅是这种写入的间接效果。

更具体地说，RISC-V 特权架构在第二卷中规定，某些控制状态寄存器值组合会导致陷阱触发。当显式写入控制状态寄存器触发陷阱时，这个陷阱不被视为写入的副作用，而仅仅是该写入的间接效果。

标准控制状态寄存器在读取时没有副作用。标准控制状态寄存器在写入时可能有副作用。自定义扩展可能会添加在读取或写入时会引发副作用的控制状态寄存器。
====
某些控制状态寄存器，例如指令退休计数器 `instret`，可能会作为指令执行的副作用而被修改。在这种情况下，控制状态寄存器访问指令读取时会获取执行前的值。如果写入此类控制状态寄存器，写入操作会替代递增。特别地，一条指令写入的值将成为下一条指令读取的值。

汇编伪指令读取控制状态寄存器，CSRR _rd, csr_，编码为 CSRRS _rd, csr, x0_。汇编伪指令写入控制状态寄存器，CSRW _csr, rs1_，编码为 CSRRW _x0, csr, rs1_，而 CSRWI _csr, uimm_，编码为 CSRRWI _x0, csr, uimm_。

进一步的汇编伪指令定义为在不需要旧值时设置和清除控制状态寄存器中的位：CSRS/CSRC _csr, rs1_; CSRSI/CSRCI _csr, uimm_。

==== 控制状态寄存器访问顺序

每个 RISC-V 硬件线程通常按程序顺序观察其自己的控制状态寄存器访问，包括隐式的控制状态寄存器访问。特别是，除非另有规定，控制状态寄存器访问会在程序顺序中，先执行任何修改或受控状态寄存器状态的指令，然后再执行任何修改或受控状态寄存器状态的后续指令。此外，显式控制状态寄存器读取会返回指令执行前的控制状态寄存器状态，而显式控制状态寄存器写入则会抑制并覆盖同一指令对同一控制状态寄存器的任何隐式写入或修改。

同样，显式控制状态寄存器访问的副作用通常是按程序顺序同步观察的。除非另有规定，任何此类副作用的全部后果将在下一条指令中可观察到，且前面的指令不会观察到任何乱序的后果。（注意前面提到的控制状态寄存器写入的副作用和间接效果之间的区别。）

对于 RVWMO 内存一致性模型（<<memorymodel>>），控制状态寄存器访问默认是弱序的，因此其他硬件线程或设备可能会以不同于程序顺序的顺序观察控制状态寄存器访问。此外，控制状态寄存器访问与显式内存访问之间默认没有排序，除非控制状态寄存器访问修改执行显式内存访问的指令行为，或控制状态寄存器访问与显式内存访问由内存模型定义的语法依赖关系或本手册第二卷中定义的内存排序 PMA 要求排序。为了在其他情况下强制排序，软件应在相关访问之间执行 FENCE 指令。对于 FENCE 指令的目的，控制状态寄存器读取访问被分类为设备输入（I），控制状态寄存器写入访问被分类为设备输出（O）。
[NOTE]
====
非正式地，控制状态寄存器空间被视为弱排序的内存映射 I/O 区域，具体定义参见本手册第二卷中的内存排序 PMA 部分。因此，控制状态寄存器访问的顺序与所有其他访问的顺序受到与内存映射 I/O 区域访问顺序相同的机制约束。

这些控制状态寄存器排序限制旨在支持与设备或其他硬件线程可见的控制状态寄存器访问相关的主内存和内存映射 I/O 访问顺序。例如 `time`、`cycle` 和 `mcycle` 控制状态寄存器，以及反映挂起中断的控制状态寄存器，如 `mip` 和 `sip`。注意，此类控制状态寄存器的隐式读取（例如，由于 `mip` 的变化而中断）也按设备输入排序。

大多数控制状态寄存器（如 fcsr）对其他硬件线程不可见；它们的访问可以在全局内存顺序中自由重排序，而不会违反本规范。
====
硬件平台可以定义某些控制状态寄存器为强排序的，具体定义见本手册第二卷中的内存排序 PMA 部分。对强排序控制状态寄存器的访问，具有比弱排序控制状态寄存器和内存映射 I/O 区域访问更严格的排序约束。

[NOTE]
====
控制状态寄存器在全局内存顺序中的重新排序规则，可能应该移至 <<memorymodel>> 中与 RVWMO 内存一致性模型相关的部分。
====
