[[csrinsts]]
== "Zicsr", 控制和状态寄存器（CSR）指令扩展，版本 2.0

RISC-V 为每个硬件线程定义了一个独立的 4096 个控制和状态寄存器（CSR）的地址空间。本章定义了操作这些控制状态寄存器的完整指令集。

[NOTE]
====
虽然控制状态寄存器主要用于特权架构，但在非特权代码中也有多种用途，包括计数器和定时器，以及浮点状态。

计数器和定时器不再被视为标准基本 ISA 的强制部分，因此访问它们所需的控制状态寄存器指令已从 <<rv32>> 移至本章。
====

=== 控制状态寄存器指令

所有控制状态寄存器指令都原子性地读-修改-写单个控制状态寄存器，其控制状态寄存器指定符编码在指令的 12 位 _csr_ 字段中，位于 31-20 位。立即数格式采用 rs1 字段中编码的 5 位零扩展立即数。

include::images/wavedrom/csr-instr.adoc[]

CSRRW（原子读/写控制状态寄存器）指令原子性地交换控制状态寄存器和整数寄存器中的值。CSRRW 读取控制状态寄存器的旧值，将其零扩展到 XLEN 位，然后写入整数寄存器 _rd_。初始值在 _rs1_ 中写入控制状态寄存器。如果 _rd_=`x0`，则指令不读取控制状态寄存器，也不会引起任何可能在控制状态寄存器读取时发生的副作用。

CSRRS（原子读和设置控制状态寄存器中的位）指令读取控制状态寄存器的值，将其零扩展到 XLEN 位，并写入整数寄存器 _rd_。整数寄存器 _rs1_ 中的初始值被视为一个位掩码，指定要在控制状态寄存器中设置的位位置。_rs1_ 中的任何高位将导致相应的控制状态寄存器位被设置，如果该控制状态寄存器位是可写的。

CSRRC（原子读和清除控制状态寄存器中的位）指令读取控制状态寄存器的值，将其零扩展到 XLEN 位，并写入整数寄存器 _rd_。整数寄存器 _rs1_ 中的初始值被视为一个位掩码，指定要在控制状态寄存器中清除的位位置。_rs1_ 中的任何高位将导致相应的控制状态寄存器位被清除，如果该控制状态寄存器位是可写的。

对于 CSRRS 和 CSRRC，如果 _rs1_=`x0`，则指令不会写入控制状态寄存器，因此不会引起任何可能在控制状态寄存器写入时发生的副作用，也不会在访问只读控制状态寄存器时引发非法指令异常。无论 _rs1_ 和 _rd_ 字段如何，CSRRS 和 CSRRC 总是读取指定的 控制状态寄存器并引起任何读取副作用。注意，如果 _rs1_ 指定了一个非 `x0` 的寄存器，并且该寄存器持有零值，则指令不会执行任何字段级别的副作用，但会执行写入整个控制状态寄存器时的任何副作用。

CSRRW 与 _rs1_=`x0` 将尝试将零写入目标控制状态寄存器。

CSRRWI、CSRRSI 和 CSRRCI 变体类似于 CSRRW、CSRRS 和 CSRRC，只是它们使用在 _rs1_ 字段中编码的 5 位无符号立即数（uimm[4:0]）零扩展得到的 XLEN 位值来更新控制状态寄存器，而不是来自整数寄存器的值。对于 CSRRSI 和 CSRRCI，如果 uimm[4:0] 字段为零，则这些指令不会写入控制状态寄存器，并且不会引起任何可能在控制状态寄存器写入时发生的副作用，也不会在访问只读 控制状态寄存器时引发非法指令异常。对于 CSRRWI，如果 _rd_=`x0`，则指令不会读取控制状态寄存器，也不会引起任何可能在控制状态寄存器读取时发生的副作用。无论 _rd_ 和 _rs1_ 字段如何，CSRRSI 和 CSRRCI 总是读取控制状态寄存器并引起任何读取副作用。

[[csrsideeffects]]
.确定控制状态寄存器指令是否读取或写入指定控制状态寄存器的条件。
[%autowidth,float="center",align="center",cols="<,^,^,^,^",options="header",]
|===
5+^|*寄存器操作数* 
|指令 |_rd_为 `x0` |_rs1_为 `x0` |读取控制状态寄存器 |写入控制状态寄存器

|CSRRW |是 |- |否 |是

|CSRRW |否 |- |是 |是

|CSRRS/CSRRC |- |是 |是 |否

|CSRRS/CSRRC |- |否 |是 |是

5+^|*立即数操作数* 

|指令 |_rd_为 `x0` |__uimm__latexmath:[$=$]0 |读取控制状态寄存器 |写入控制状态寄存器

|CSRRWI |是 |- |否 |是

|CSRRWI |否 |- |是 |是

|CSRRSI/CSRRCI |- |是 |是 |否

|CSRRSI/CSRRCI |- |否 |是 |是
|===

<<csrsideeffects>>总结了控制状态寄存器指令在读取和/或写入控制状态寄存器方面的行为。

除了由于读取或写入控制状态寄存器而发生的副作用外，控制状态寄存器中的各个字段在写入时可能会有副作用。CSRRW[I] 指令对写入的控制状态寄存器中的所有此类字段执行副作用。CSRRS[I] 和 CSRRC[I] 指令仅对 _rs1_ 或 _uimm_ 参数中至少有一个位设置对应字段的字段执行副作用。
[NOTE]
====
截至本文撰写时，没有标准控制状态寄存器在字段被写入时有副作用。因此，标准控制状态寄存器访问是否有任何副作用可以仅从操作码确定。

不建议定义在字段写入时有副作用的控制状态寄存器。
====

对于由于控制状态寄存器具有特定值而发生的任何事件或结果，如果写入控制状态寄存器使其具有该值，则该写入的结果事件或结果被称为该写入的 _间接效果_。控制状态寄存器写入的间接效果不被 RISC-V ISA 视为该写入的副作用。
[NOTE]
====
控制状态寄存器访问副作用的一个例子是，如果从特定控制状态寄存器读取会导致灯泡亮起，而写入奇数值会导致灯泡熄灭。假设写入偶数值没有效果。在这种情况下，读取和写入都有控制灯泡是否点亮的副作用，因为这种情况不仅仅由控制状态寄存器值决定。（注意，在写入奇数值以关闭灯泡后，再次读取以点亮灯泡，再次写入相同的奇数值会导致灯泡再次熄灭。因此，在最后一次写入时，不是控制状态寄存器值的变化导致灯泡熄灭。）

另一方面，如果灯泡被设置为在特定控制状态寄存器值为奇数时点亮，则点亮和熄灭灯泡不被视为写入控制状态寄存器的副作用，而仅仅是这种写入的间接效果。

更具体地说，RISC-V 特权架构在第二卷中规定，某些控制状态寄存器值组合会导致陷阱触发。当显式写入控制状态寄存器创建触发陷阱的条件时，陷阱不被视为写入的副作用，而仅仅是这种写入的间接效果。

标准控制状态寄存器在被读取时没有任何副作用。标准控制状态寄存器在被写入时可能有副作用。自定义扩展可能会添加在被读取或被写入时有副作用的控制状态寄存器。
====
某些控制状态寄存器，例如指令退休计数器 `instret`，可能会作为指令执行的副作用而被修改。在这些情况下，如果控制状态寄存器访问指令读取控制状态寄存器，它会读取指令执行前的值。如果控制状态寄存器访问指令写入此类控制状态寄存器，则写入将代替递增。特别是，一条指令写入的值将是下一条指令读取的值。

汇编伪指令读取控制状态寄存器，CSRR _rd, csr_，编码为 CSRRS _rd, csr, x0_。汇编伪指令写入控制状态寄存器，CSRW _csr, rs1_，编码为 CSRRW _x0, csr, rs1_，而 CSRWI _csr, uimm_，编码为 CSRRWI _x0, csr, uimm_。

进一步的汇编伪指令定义为在不需要旧值时设置和清除控制状态寄存器中的位：CSRS/CSRC _csr, rs1_; CSRSI/CSRCI _csr, uimm_。

每个 RISC-V 硬件线程通常按程序顺序观察其自己的控制状态寄存器访问，包括其隐式的控制状态寄存器访问。特别是，除非另有规定，控制状态寄存器访问在程序顺序中先前的任何修改或被控制状态寄存器的状态指令执行之后执行，并且在程序顺序中任何修改或被控制状态寄存器的状态修改的后续指令执行之前执行。此外，显式控制状态寄存器读取返回指令执行前的控制状态寄存器状态，而显式控制状态寄存器写入抑制并覆盖同一指令对同一控制状态寄存器的任何隐式写入或修改。

同样，显式控制状态寄存器访问的任何副作用通常按程序顺序同步观察。除非另有规定，任何此类副作用的全部后果在下一条指令中可观察到，并且前面的指令不会观察到任何乱序的后果。（注意前面提到的控制状态寄存器写入的副作用和间接效果之间的区别。）

对于 RVWMO 内存一致性模型（<<memorymodel>>），控制状态寄存器访问默认是弱排序的，因此其他硬件线程或设备可能会以不同于程序顺序的顺序观察控制状态寄存器访问。此外，除非控制状态寄存器访问修改执行显式内存访问的指令的行为，或者控制状态寄存器访问和显式内存访问由内存模型定义的语法依赖关系或本手册第二卷中定义的内存排序 PMA 要求排序，否则控制状态寄存器访问与显式内存访问之间没有排序。为了在所有其他情况下强制排序，软件应在相关访问之间执行 FENCE 指令。对于 FENCE 指令的目的，控制状态寄存器读取访问被分类为设备输入（I），控制状态寄存器写入访问被分类为设备输出（O）。
[NOTE]
====
非正式地，控制状态寄存器空间充当弱排序的内存映射 I/O 区域，如本手册第二卷中内存排序 PMA 部分定义的那样。因此，控制状态寄存器访问与所有其他访问的顺序由约束内存映射 I/O 访问到此类区域的相同机制约束。

这些控制状态寄存器排序约束旨在支持与设备或其他硬件线程可见的控制状态寄存器访问相关的主内存和内存映射 I/O 访问的排序。示例包括 `time`、`cycle` 和 `mcycle` 控制状态寄存器，以及反映挂起中断的控制状态寄存器，如 `mip` 和 `sip`。注意，此类 控制状态寄存器的隐式读取（例如，由于 `mip` 的变化而中断）也按设备输入排序。

大多数 CSR控制状态寄存器（包括例如 `fcsr`）对其他硬件线程不可见；它们的访问可以在全局内存顺序中自由重新排序，而不会违反本规范。
====
硬件平台可以定义某些控制状态寄存器访问是强排序的，如本手册第二卷中内存排序 PMA 部分定义的那样。对强排序控制状态寄存器的访问在与弱排序控制状态寄存器和内存映射 I/O 区域的访问方面具有更强的排序约束。

[NOTE]
====
控制状态寄存器访问在全局内存顺序中的重新排序规则可能应移至 <<memorymodel>> 中有关 RVWMO 内存一致性模型的部分。
====
