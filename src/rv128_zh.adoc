[[rv128]]
== RV128I 基本整数指令集，版本 1.7

“在计算机设计中，只有一个错误是很难恢复的——那就是没有足够的地址位来进行内存寻址和内存管理。”
—— Bell 和 Strecker，ISCA-3，1976 年。

本章描述了 RV128I，这是一个支持平面 128 位地址空间的 RISC-V ISA 变体。该变体是现有 RV32I 和 RV64I 设计的直接扩展
(((RV128, design)))

[TIP]
====
扩展整数寄存器宽度的主要目的是支持更大的地址空间。目前尚不清楚何时会需要超过 64 位的平面地址空间。截至本文撰写时，世界上最快的超级计算机在 Top500 基准测试中排名第一，拥有超过 1PB 的 DRAM，如果所有 DRAM 都驻留在单一地址空间中，所需的地址空间就会超过 50 位。一些仓库级计算机已经包含更大量的 DRAM，新的高密度固态非易失性存储器和高速互连技术可能会推动对更大内存空间的需求。Exascale 系统研究的目标是实现 100PB 的内存系统，这将需要 57 位地址空间。按照历史增长的速度，可能在 2030 年之前会需要超过 64 位的地址空间。
历史表明，每当明确需要超过 64 位的地址空间时，架构师会反复讨论扩展地址空间的替代方案，包括分段、96 位地址空间和软件解决方法，最终往往选择平面 128 位地址空间，因为这是最简单且最佳的解决方案。
目前我们尚未冻结 RV128 的规范，可能会根据实际的 128 位地址空间使用情况进一步调整设计。
====
(((RV128, evolution)))
(((RV128I, as relates to RV64I)))

RV128I 是在 RV64I 基础上构建的，正像 RV64I 是在 RV32I 上构建的一样，整数寄存器扩展为 128 位（即 XLEN=128）。大多数整数计算指令保持不变，因为它们都是被定义为在 XLEN 位宽上操作。RV64I 中的 "*W" 整数指令仍然保留，它们在寄存器的低 32 位操作，但现在将其结果从第 31 位符号扩展到第 127 位。新增了一组 "*D" 整数指令，它们在 128 位整数寄存器的低 64 位上操作，并将其结果从第 63 位符号扩展到第 127 位。这些 "*D" 指令在标准 32 位编码中占用了两个主要操作码（OP-IMM-64 和 OP-64）。
(((RV128I, compatibility with RV64)))

[NOTE]
====
为了提高与 RV64 的兼容性，我们可能会对解码进行调整，将 RV64I 的 ADD 指令重命名为 64 位 ADDD，并在之前的 OP-64 主要操作码中添加 128 位 ADDQ（现已重命名为 OP-128 主要操作码）。
====


立即数移位（SLLI/SRLI/SRAI）现在使用 I 型立即数的低 7 位进行编码，而可变移位（SLL/SRL/SRA）则使用移位源寄存器的低 7 位。
(((RV128I, LOU)))

新增了一条 LDU（加载无符号双字）指令，使用现有的 LOAD 主要操作码，并新增了 LQ 和 SQ 指令来加载和存储四倍字值。SQ 被添加到 STORE 主要操作码中，而 LQ 被添加到 MISC-MEM 主要操作码中。


浮点指令集保持不变，尽管 128 位 Q 浮点扩展现在可以支持 FMV.X.Q 和 FMV.Q.X 指令，并新增了 FCVT 指令，用于与 T（128 位）整数格式之间的转换。

