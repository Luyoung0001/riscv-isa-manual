[[rv128]]
== RV128I 基本整数指令集，版本 1.7

“在计算机设计中，只有一个错误是很难恢复的——那就是没有足够的地址位来进行内存寻址和内存管理。”
—— Bell 和 Strecker，ISCA-3，1976 年。

本章阐述了 RV128I，RISC-V ISA 的一个变体，其特点是支持 128 位扁平寻址空间。 此变体是对现有 RV32I 和 RV64I 设计的直接外推。
(((RV128, design)))

[TIP]
====
扩展整数寄存器宽度的根本动因在于对更大地址空间的支持。 64 位以上的扁平地址空间何时成为必要，目前尚无定论。根据 Top500 性能测试，截至本文撰写之时，全球最快超级计算机已配备超过 1PB 的 DRAM，若将所有 DRAM 纳入单一地址空间，则需超过 50 位的地址空间。部分数据中心级计算机已配置更大规模的 DRAM 容量，同时，新型高密度固态非易失性存储器及高速互连技术亦可能催生对更大内存空间的需求。Exascale 系统研究正致力于构建 100PB 级别的内存系统，其地址空间需求将达到 57 位。按照过往发展速率推演，早于 2030 年，超过 64 位的地址空间需求或将成为现实。
历史经验表明，每当超过 64 位地址空间的需求显现，架构设计者们便会围绕地址空间扩展的替代方案展开深入辩论，包括分段机制、96 位地址空间以及软件层面的权宜之计，直至最终，扁平的 128 位地址空间被普遍接受为最简洁且最佳的解决途径。
考虑到 128 位地址空间的实际应用场景尚不明朗，RV128 规范目前仍处于待定状态，以便未来能够根据 128 位地址空间的实际应用反馈来迭代完善设计。
====
(((RV128, evolution)))
(((RV128I, as relates to RV64I)))

RV128I 是在 RV64I 基础上构建的，正像 RV64I 是在 RV32I 上构建的一样，整数寄存器扩展为 128 位（即 XLEN 等于 128）。大多数整数计算指令保持不变，因为它们都是被定义为在 XLEN 位宽上操作。RV64I 中的 "*W" 整数指令仍然保留，它们在寄存器的低 32 位操作，但现在将其结果从第 31 位符号扩展到第 127 位。新增了一组 "*D" 整数指令，它们在 128 位整数寄存器的低 64 位上操作，并将其结果从第 63 位符号扩展到第 127 位。这些 "*D" 指令在标准 32 位编码中占用了两个主操作码（OP-IMM-64 和 OP-64）。
(((RV128I, compatibility with RV64)))

[NOTE]
====
为了增强与 RV64 的兼容性，我们或对解码进行调整，即将 RV64I 的 ADD 指令重命名为 64 位 ADDD，并在之前的 OP-64 主操作码中添加 128 位 ADDQ（现已重命名为 OP-128 主操作码）。
====


立即数移位（SLLI/SRLI/SRAI）现在使用 I 型立即数的低 7 位进行编码，而可变移位（SLL/SRL/SRA）则使用移位源寄存器的低 7 位。
(((RV128I, LOU)))

新增了一条 LDU（加载无符号双字）指令，使用现有的 LOAD 主操作码，并新增了 LQ 和 SQ 指令来加载和存储四倍字值。SQ 被添加到 STORE 主操作码中，而 LQ 被添加到 MISC-MEM 主操作码中。


浮点指令集保持不变，尽管 128 位 Q 浮点扩展现在可以支持 FMV.X.Q 和 FMV.Q.X 指令，并新增了 FCVT 指令，用于与 T（128 位）整数格式之间的转换。

