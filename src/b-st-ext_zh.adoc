[[bits]]
== “B”扩展：位操作指令，版本 1.0.0

B 标准扩展包括由 Zba、Zbb 和 Zbs 扩展提供的指令。

[[preface]]
=== 位操作 a、b、c 和 s 扩展组合（供公众审查和批准）

位操作（bitmanip）扩展集由几个基本 RISC-V 架构的扩展组成，旨在提供代码大小减少、性能提升和功耗减少的组合。虽然这些指令旨在具有通用用途，但某些指令在某些领域比其他领域更有用。因此，提供的是几个较小的位操作扩展，而不是一个大的扩展。每个较小的扩展根据共同的功能和使用场景进行分组，每个扩展都有其独立的 Zb*-<扩展名称>。

每个位操作扩展都包括一组功能相似的位操作指令，这些指令通常可以共享相同的逻辑。某些指令仅在一个扩展中可用，而其他指令则在多个扩展中可用。这些指令的助记符和编码独立于它们所在的扩展。因此，在实现具有重复指令的扩展时，逻辑和编码不会产生冗余。

位操作扩展适用于 RV32 和 RV64。大多数指令预计与 RV128 向前兼容。虽然移位立即数指令的定义最多支持 6 位立即数字段，但如果 RV128 需要，可以在编码空间中提供第 7 位。

=== 字指令

位操作扩展遵循 RV64 中的约定，带有 _w_ 后缀的指令（_w_ 前没有点）会忽略其输入的高 32 位，操作低 32 位作为有符号值，并生成一个符号位扩展到 XLEN 的 32 位有符号结果。

带有 _.uw_ 后缀的位操作指令则将操作数视为从指定寄存器的最低 32 位提取的无符号 32 位值。除此之外，这些指令执行完整的 XLEN 操作。

带有 _.b_、_.h_ 和 _.w_ 后缀的位操作指令仅查看输入的最低 8 位、16 位和 32 位（分别），并生成符号扩展或零扩展的 XLEN 位宽结果，具体取决于特定指令。

=== 指令语义的伪代码

<<#insns>> 中每条指令的语义以类似 SAIL 的语法表示。

=== 扩展

第一组发布供公众审查的位操作扩展是：

* <<#zba>>
* <<#zbb>>
* <<#zbc>>
* <<#zbs>>

以下是这些扩展中包含的所有指令及其特定映射的列表：

[%header,cols="^3,^3,10,16,^2,^2,^2,^2"]
|====
|RV32
|RV64
|助记符
|指令
|Zba
|Zbb
|Zbc
|Zbs

|
|&#10003;
|add.uw _rd_, _rs1_, _rs2_
|<<#insns-add_uw>>
|&#10003;
|
|
|

|&#10003;
|&#10003;
|andn _rd_, _rs1_, _rs2_
|<<#insns-andn>>
|
|&#10003;
|
|


|&#10003;
|&#10003;
|clmul _rd_, _rs1_, _rs2_
|<<#insns-clmul>>
|
|
|&#10003;
|

|&#10003;
|&#10003;
|clmulh _rd_, _rs1_, _rs2_
|<<#insns-clmulh>>
|
|
|&#10003;
|

|&#10003;
|&#10003;
|clmulr _rd_, _rs1_, _rs2_
|<<#insns-clmulr>>
|
|
|&#10003;
|

|&#10003;
|&#10003;
|clz _rd_, _rs_
|<<#insns-clz>>
|
|&#10003;
|
|

|
|&#10003;
|clzw _rd_, _rs_
|<<#insns-clzw>>
|
|&#10003;
|
|
|&#10003;
|&#10003;
|cpop _rd_, _rs_
|<<#insns-cpop>>
|
|&#10003;
|
|

|
|&#10003;
|cpopw _rd_, _rs_
|<<#insns-cpopw>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|ctz _rd_, _rs_
|<<#insns-ctz>>
|
|&#10003;
|
|

|
|&#10003;
|ctzw _rd_, _rs_
|<<#insns-ctzw>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|max _rd_, _rs1_, _rs2_
|<<#insns-max>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|maxu _rd_, _rs1_, _rs2_
|<<#insns-maxu>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|min _rd_, _rs1_, _rs2_
|<<#insns-min>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|minu _rd_, _rs1_, _rs2_
|<<#insns-minu>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|orc.b _rd_, _rs1_, _rs2_
|<<#insns-orc_b>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|orn _rd_, _rs1_, _rs2_
|<<#insns-orn>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|rev8 _rd_, _rs_
|<<#insns-rev8>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|rol _rd_, _rs1_, _rs2_
|<<#insns-rol>>
|
|&#10003;
|
|

|
|&#10003;
|rolw _rd_, _rs1_, _rs2_
|<<#insns-rolw>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|ror _rd_, _rs1_, _rs2_
|<<#insns-ror>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|rori _rd_, _rs1_, _shamt_
|<<#insns-rori>>
|
|&#10003;
|
|

|
|&#10003;
|roriw _rd_, _rs1_, _shamt_
|<<#insns-roriw>>
|
|&#10003;
|
|

|
|&#10003;
|rorw _rd_, _rs1_, _rs2_
|<<#insns-rorw>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|bclr _rd_, _rs1_, _rs2_
|<<#insns-bclr>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|bclri _rd_, _rs1_, _imm_
|<<#insns-bclri>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|bext _rd_, _rs1_, _rs2_
|<<#insns-bext>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|bexti _rd_, _rs1_, _imm_
|<<#insns-bexti>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|binv _rd_, _rs1_, _rs2_
|<<#insns-binv>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|binvi _rd_, _rs1_, _imm_
|<<#insns-binvi>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|bset _rd_, _rs1_, _rs2_
|<<#insns-bset>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|bseti _rd_, _rs1_, _imm_
|<<#insns-bseti>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|sext.b _rd_, _rs_
|<<#insns-sext_b>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|sext.h _rd_, _rs_
|<<#insns-sext_h>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|sh1add _rd_, _rs1_, _rs2_
|<<#insns-sh1add>>
|&#10003;
|
|
|

|
|&#10003;
|sh1add.uw _rd_, _rs1_, _rs2_
|<<#insns-sh1add_uw>>
|&#10003;
|
|
|

|&#10003;
|&#10003;
|sh2add _rd_, _rs1_, _rs2_
|<<#insns-sh2add>>
|&#10003;
|
|
|

|
|&#10003;
|sh2add.uw _rd_, _rs1_, _rs2_
|<<#insns-sh2add_uw>>
|&#10003;
|
|
|

|&#10003;
|&#10003;
|sh3add _rd_, _rs1_, _rs2_
|<<#insns-sh3add>>
|&#10003;
|
|
|

|
|&#10003;
|sh3add.uw _rd_, _rs1_, _rs2_
|<<#insns-sh3add_uw>>
|&#10003;
|
|
|

|
|&#10003;
|slli.uw _rd_, _rs1_, _imm_
|<<#insns-slli_uw>>
|&#10003;
|
|
|

|&#10003;
|&#10003;
|xnor _rd_, _rs1_, _rs2_
|<<#insns-xnor>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|zext.h _rd_, _rs_
|<<#insns-zext_h>>
|
|&#10003;
|
|

|====

[#zba,reftext=地址生成指令]
==== Zba：地址生成

[NOTE,caption=冻结]
====
Zba 扩展已冻结。
====

Zba 指令用于加速生成指向基本类型（半字、字、双字）数组的索引地址，使用无符号字大小和 XLEN 大小的索引 -- 通过将移位后的索引加到基地址上来实现。

移位和加法指令将左移 1、2 或 3 位，因为这些操作在实际代码中较为常见，且可以通过最少的额外硬件实现，超出简单加法器的范围。这可以避免延长实现中的关键路径。

虽然移位和加法指令的左移限制为最多 3 位，但可以使用 slli 指令（来自基本 ISA）对更宽元素的数组进行类似的移位操作。slli.uw -- 在此扩展中新增 -- 可以当索引被解释为无符号字时使用。

以下指令（和伪指令）组成 Zba 扩展：

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|
|&#10003;
|add.uw _rd_, _rs1_, _rs2_
|<<#insns-add_uw>>

|&#10003;
|&#10003;
|sh1add _rd_, _rs1_, _rs2_
|<<#insns-sh1add>>

|
|&#10003;
|sh1add.uw _rd_, _rs1_, _rs2_
|<<#insns-sh1add_uw>>

|&#10003;
|&#10003;
|sh2add _rd_, _rs1_, _rs2_
|<<#insns-sh2add>>

|
|&#10003;
|sh2add.uw _rd_, _rs1_, _rs2_
|<<#insns-sh2add_uw>>

|&#10003;
|&#10003;
|sh3add _rd_, _rs1_, _rs2_
|<<#insns-sh3add>>

|
|&#10003;
|sh3add.uw _rd_, _rs1_, _rs2_
|<<#insns-sh3add_uw>>

|
|&#10003;
|slli.uw _rd_, _rs1_, _imm_
|<<#insns-slli_uw>>

|
|&#10003;
|zext.w _rd_, _rs_
|<<#insns-add_uw>>

|===

[#zbb,reftext="基本位操作指令"]
==== Zbb：基本位操作指令

[NOTE,caption=冻结]
====
Zbb 扩展已冻结。
====
===== 带否定的逻辑操作

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|andn _rd_, _rs1_, _rs2_
|<<#insns-andn>>

|&#10003;
|&#10003;
|orn _rd_, _rs1_, _rs2_
|<<#insns-orn>>

|&#10003;
|&#10003;
|xnor _rd_, _rs1_, _rs2_
|<<#insns-xnor>>
|===

.实现提示
[NOTE, caption="Imp" ]
===============================================================
逻辑非指令可以通过对基础所需的与、或和异或逻辑指令的 _rs2_ 输入进行反转来实现。在某些实现中，用于减法的 rs2 反相器可以被用于此目的。
===============================================================

===== 计数前导/后导零位 （Count leading/trailing zero bits）

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|clz _rd_, _rs_
|<<#insns-clz>>

|
|&#10003;
|clzw _rd_, _rs_
|<<#insns-clzw>>

|&#10003;
|&#10003;
|ctz _rd_, _rs_
|<<#insns-ctz>>

|
|&#10003;
|ctzw _rd_, _rs_
|<<#insns-ctzw>>
|===

===== 位计数 (Count population)

这些指令用于计算设置位（1 位）的数量。这个操作也通常称为位计数。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|cpop _rd_, _rs_
|<<#insns-cpop>>

|
|&#10003;
|cpopw _rd_, _rs_
|<<#insns-cpopw>>
|===

===== 整数最小值/最大值

整数最小值/最大值指令是算术 R 型指令，返回两个操作数中较小值/较大值。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|max _rd_, _rs1_, _rs2_
|<<#insns-max>>

|&#10003;
|&#10003;
|maxu _rd_, _rs1_, _rs2_
|<<#insns-maxu>>

|&#10003;
|&#10003;
|min _rd_, _rs1_, _rs2_
|<<#insns-min>>

|&#10003;
|&#10003;
|minu _rd_, _rs1_, _rs2_
|<<#insns-minu>>
|===

===== 符号位扩展和零扩展

这些指令对源寄存器的最低 8 位或 16 位执行符号扩展或零扩展。

这些指令替代了习惯用法 `slli rD,rS,(XLEN-<size>) + srli`（用于零扩展）或 `slli + srai`（用于符号扩展），用于对 8 位和 16 位量进行符号扩展，以及对 16 位量进行零扩展。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|sext.b _rd_, _rs_
|<<#insns-sext_b>>

|&#10003;
|&#10003;
|sext.h _rd_, _rs_
|<<#insns-sext_h>>

|&#10003;
|&#10003;
|zext.h _rd_, _rs_
|<<#insns-zext_h>>
|===

===== 位旋转 （Bitwise rotation）

位旋转指令类似于基本规范中的逻辑移位操作。然而，与逻辑移位指令将零移入不同，旋转指令将从值的另一侧移出的位移入。这种操作也被称为“循环移位” （circular shifts）。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|rol _rd_, _rs1_, _rs2_
|<<#insns-rol>>

|
|&#10003;
|rolw _rd_, _rs1_, _rs2_
|<<#insns-rolw>>

|&#10003;
|&#10003;
|ror _rd_, _rs1_, _rs2_
|<<#insns-ror>>

|&#10003;
|&#10003;
|rori _rd_, _rs1_, _shamt_
|<<#insns-rori>>

|
|&#10003;
|roriw _rd_, _rs1_, _shamt_
|<<#insns-roriw>>

|
|&#10003;
|rorw _rd_, _rs1_, _rs2_
|<<#insns-rorw>>
|===

.架构解释
[NOTE, caption="AE" ]
===============================================================
加入旋转指令是为了替换一个常见的四指令序列，以实现相同的效果（neg; sll/srl; srl/sll; or）
===============================================================

===== OR 组合

如果 _rs_ 中相应字节的任何位都没有被设置，*orc.b* 将结果寄存器 _rd_ 中每个字节的位设置为全零；如果 _rs_ 中相应字节的任何一位被设置，则将结果字节的位设置为全一。

一个典型的应用场景是字符串处理函数，如 *strlen* 和 *strcpy*，它们可以使用 *orc.b* 通过计算字中的前导非零字节中的设置位，来测试终止零字节。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|orc.b _rd_, _rs_
|<<#insns-orc_b>>
|===

===== 字节反转

*rev8* 反转 _rs_ 的字节顺序。

[%header,cols="^1,^1,4,8"]
|====
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|rev8 _rd_, _rs_
|<<#insns-rev8>>

|====

[#zbc,reftext="无进位乘法指令"]
==== Zbc: 无进位乘法指令

[NOTE,caption=Frozen]
====
Zbc 扩展已冻结。
====

无进位乘法是在 GF(2) 上的多项式环中的乘法。

*clmul* 生成无进位乘积的下半部分，*clmulh* 生成 2&#x2715;XLEN 无进位乘积的上半部分。

*clmulr* 生成 2&#x2715;XLEN−2:XLEN-1 的 2&#x2715;XLEN 无进位乘积。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|clmul _rd_, _rs1_, _rs2_
|<<#insns-clmul>>

|&#10003;
|&#10003;
|clmulh _rd_, _rs1_, _rs2_
|<<#insns-clmulh>>

|&#10003;
|&#10003;
|clmulr _rd_, _rs1_, _rs2_
|<<#insns-clmulr>>

|===

[#zbs,reftext="单比特指令"]
==== Zbs: 单比特指令

[NOTE,caption=Frozen]
====
Zbs 扩展已冻结。
====

单比特指令提供了一种机制，用于在寄存器中设置、清除、反转或提取单比特位。该位由其索引指定。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|bclr _rd_, _rs1_, _rs2_
|<<#insns-bclr>>

|&#10003;
|&#10003;
|bclri _rd_, _rs1_, _imm_
|<<#insns-bclri>>

|&#10003;
|&#10003;
|bext _rd_, _rs1_, _rs2_
|<<#insns-bext>>

|&#10003;
|&#10003;
|bexti _rd_, _rs1_, _imm_
|<<#insns-bexti>>

|&#10003;
|&#10003;
|binv _rd_, _rs1_, _rs2_
|<<#insns-binv>>

|&#10003;
|&#10003;
|binvi _rd_, _rs1_, _imm_
|<<#insns-binvi>>

|&#10003;
|&#10003;
|bset _rd_, _rs1_, _rs2_
|<<#insns-bset>>

|&#10003;
|&#10003;
|bseti _rd_, _rs1_, _imm_
|<<#insns-bseti>>

|===

[#zbkb,reftext="用于加密的位操作"]
==== Zbkb: 用于加密的位操作

[NOTE,caption=Frozen]
====
Zbkb 扩展已冻结。
====

此扩展包含实现加密工作负载中常见操作所必需的指令。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

| &#10003;
| &#10003;
|  rol
| <<insns-rol>>

|
| &#10003;
|  rolw
| <<insns-rolw>>

| &#10003;
| &#10003;
|  ror
| <<insns-ror>>

| &#10003;
| &#10003;
|  rori
| <<insns-rori>>

|
| &#10003;
|  roriw
| <<insns-roriw>>

|
| &#10003;
|  rorw
| <<insns-rorw>>

| &#10003;
| &#10003;
|  andn
| <<insns-andn>>

| &#10003;
| &#10003;
|  orn
| <<insns-orn>>

| &#10003;
| &#10003;
|  xnor
| <<insns-xnor>>

| &#10003;
| &#10003;
|  pack
| <<insns-pack>>

| &#10003;
| &#10003;
|  packh
| <<insns-packh>>

|
| &#10003;
|  packw
| <<insns-packw>>

| &#10003;
| &#10003;
|  rev.b
| <<insns-revb>>

| &#10003;
| &#10003;
|  rev8
| <<insns-rev8>>

| &#10003;
|
|  zip
| <<insns-zip>>

| &#10003;
|
|  unzip
| <<insns-unzip>>

|===

[#zbkc,reftext="用于加密的无进位乘法"]
==== Zbkc: 用于加密的无进位乘法

[NOTE,caption=Frozen]
====
Zbkc 扩展已冻结。
====

无进位乘法是在 GF(2) 上的多项式环中的乘法。这是一些加密工作负载中的关键操作，特别是在 AES-GCM 认证加密方案中。此扩展仅提供高效实现 GHASH 操作所需的指令，GHASH 是该工作负载的一部分。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|clmul _rd_, _rs1_, _rs2_
|<<#insns-clmul>>

|&#10003;
|&#10003;
|clmulh _rd_, _rs1_, _rs2_
|<<#insns-clmulh>>

|===

[#zbkx,reftext="交叉开关置换（Crossbar permutations）"]
==== Zbkx: 交叉开关置换（Crossbar permutations）

[NOTE,caption=Frozen]
====
Zbkx 扩展已冻结。
====

这些指令实现了一个用于通用寄存器中的 4 位和 8 位元素的“查找表”。_rs1_ 被用作一个 N 位字的向量，_rs2_ 被用作中一个 N 位的索引向量，指向 _rs1_ 中的元素。_rs1_ 中的元素将被 _rs2_ 中对应索引的元素替换，如果索引超出 _rs2_ 的范围，则替换为零。

这些指令对于表达 N 位到 N 位的布尔操作非常有用，并且可以实现具有依赖于密钥的内存访问（特别是 SBox）的加密代码，使得执行延迟不依赖于被操作的（密钥）数据。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|xperm.n _rd_, _rs1_, _rs2_
|<<#insns-xpermn>>

|&#10003;
|&#10003;
|xperm.b _rd_, _rs1_, _rs2_
|<<#insns-xpermb>>

|===

<<<

[#insns,reftext="指令（按字母顺序排列）"]
=== 指令（按字母顺序排列）

[#insns-add_uw,reftext="添加无符号字"]
==== add.uw

简述::
添加无符号字

助记符::
add.uw _rd_, _rs1_, _rs2_

伪指令::
zext.w _rd_, _rs1_ &#8594; add.uw _rd_, _rs1_, zero

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x0, attr: ['ADD.UW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x04, attr: ['ADD.UW'] },
]}
....

描述::
此指令执行 _rs2_ 与 _rs1_ 的最低有效字零扩展后的 XLEN 宽度加法。

操作::
[source,sail]
--
let base = X(rs2);
let index = EXTZ(X(rs1)[31..0]);

X(rd) = base + index;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<zba>>)
|0.93
|冻结
|===

<<<
[#insns-andn,reftext="与反转操作数的按位与"]
==== andn

简述::
与反转操作数的按位与

助记符::
andn _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x7, attr: ['ANDN']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x20, attr: ['ANDN'] },
]}
....

描述::
此指令在 _rs1_ 和 _rs2_ 的按位反转之间执行按位逻辑与操作。

操作::
[source,sail]
--
X(rd) = X(rs1) & ~X(rs2);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-bclr,reftext="单比特位清除（寄存器）"]
==== bclr

简述::
单比特位清除（寄存器）

助记符::
bclr _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BCLR'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x24, attr: ['BCLR/BEXT'] },
]}
....

描述::
此指令返回在 _rs2_ 指定的索引处清除了单比特位的 _rs1_ 的值。索引从 _rs2_ 的低 log2(XLEN) 位读取。

操作::
[source,sail]
--
let index = X(rs2) & (XLEN - 1);
X(rd) = X(rs1) & ~(1 << index)
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|冻结
|===

<<<
[#insns-bclri,reftext="单比特位清除（立即数）"]
==== bclri

简述::
单比特位清除（立即数）

助记符::
bclri _rd_, _rs1_, _shamt_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BCLRI'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x24, attr: ['BCLRI'] },
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BCLRI'] },
    { bits:  5, name: 'rs1' },
    { bits:  6, name: 'shamt' },
    { bits:  6, name: 0x12, attr: ['BCLRI'] },
]}
....

描述::
此指令返回在 _shamt_ 指定的索引处清除单比特位的 _rs1_ 的值。索引从 _shamt_ 的低 log2(XLEN) 位读取。对于 RV32，对应于 shamt[5]=1 的编码是保留的。

操作::
[source,sail]
--
let index = shamt & (XLEN - 1);
X(rd) = X(rs1) & ~(1 << index)
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|冻结
|===

<<<
[#insns-bext,reftext="单比特位提取（寄存器）"]
==== bext

简述::
单比特位提取（寄存器）
// 我们是否应该将其描述为“如果位被设置则设置”？

助记符::
bext _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['BEXT'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x24, attr: ['BCLR/BEXT'] },
]}
....

描述::
此指令返回从 _rs1_ 中提取的单比特位，索引位置由 _rs2_ 指定。索引值从 _rs2_ 的低 log2(XLEN) 位读取。

操作::
[source,sail]
--
let index = X(rs2) & (XLEN - 1);
X(rd) = (X(rs1) >> index) & 1;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|冻结
|===

<<<
[#insns-bexti,reftext="单比特位提取（立即数）"]
==== bexti

简述::
单比特位提取（立即数）

助记符::
bexti _rd_, _rs1_, _shamt_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['BEXTI'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x24, attr: ['BEXTI/BCLRI'] },
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['BEXTI'] },
    { bits:  5, name: 'rs1' },
    { bits:  6, name: 'shamt' },
    { bits:  6, name: 0x12, attr: ['BEXTI/BCLRI'] },
]}
....

描述::
此指令从 _rs1_ 中提取一个比特位，该比特位的位置由 _rs2_ 中指定的索引确定。索引值从 _shamt_ 的低 log2(XLEN) 位读取。对于 RV32，shamt[5]=1 对应的编码是保留的。

操作::
[source,sail]
--
let index = shamt & (XLEN - 1);
X(rd) = (X(rs1) >> index) & 1;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|冻结
|===

<<<
[#insns-binv,reftext="单比特位翻转（寄存器）"]
==== binv

简述::
单比特位翻转（寄存器）

助记符::
binv _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BINV'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x34, attr: ['BINV'] },
]}
....

描述::
此指令返回 _rs1_ ，其在 _rs2_ 中指定的索引位置的单比特位被翻转。索引值从 _rs2_ 的低 log2(XLEN) 位读取。

操作::
[source,sail]
--
let index = X(rs2) & (XLEN - 1);
X(rd) = X(rs1) ^ (1 << index)
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|冻结
|===

<<<
[#insns-binvi,reftext="单比特位翻转（立即数）"]
==== binvi

简述::
单比特位翻转（立即数）

助记符::
binvi _rd_, _rs1_, _shamt_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BINV'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x34, attr: ['BINVI'] },
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BINV'] },
    { bits:  5, name: 'rs1' },
    { bits:  6, name: 'shamt' },
    { bits:  6, name: 0x1a, attr: ['BINVI'] },
]}
....

描述::
此指令返回 _rs1_ ,其中在 _shamt_ 中指定的索引位置的单比特位被翻转。索引从 _shamt_ 的低 log2(XLEN) 位中读取。对于 RV32，shamt[5]=1 对应的编码是保留的。

操作::
[source,sail]
--
let index = shamt & (XLEN - 1);
X(rd) = X(rs1) ^ (1 << index)
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|冻结
|===

<<<
[#insns-bset,reftext="单比特位设置（寄存器）"]
==== bset

简述::
单比特位设置（寄存器）

助记符::
bset _rd_, _rs1_,_rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BSET'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x14, attr: ['BSET'] },
]}
....

描述::
此指令返回 _rs1_ , 其中在 _rs2_ 中指定的索引位置设置单比特位。索引从 _rs2_ 的低 log2(XLEN) 位读取。

操作::
[source,sail]
--
let index = X(rs2) & (XLEN - 1);
X(rd) = X(rs1) | (1 << index)
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|冻结
|===

<<<
[#insns-bseti,reftext="单比特位设置（立即数）"]
==== bseti

简述::
单比特位设置（立即数）

助记符::
bseti _rd_, _rs1_,_shamt_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BSETI'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x14, attr: ['BSETI'] },
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BSETI'] },
    { bits:  5, name: 'rs1' },
    { bits:  6, name: 'shamt' },
    { bits:  6, name: 0x0a, attr: ['BSETI'] },
]}
....

描述::
此指令返回 _rs1_，并在 _shamt_ 指定的索引位置设置单比特位。索引从 _shamt_ 的低 log2(XLEN) 位读取。对于 RV32，shamt[5]=1 的编码是保留的。

操作::
[source,sail]
--
let index = shamt & (XLEN - 1);
X(rd) = X(rs1) | (1 << index)
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|冻结
|===

<<<
[#insns-clmul,reftext="无进位乘法（低位部分）"]
==== clmul

简述::
无进位乘法（低位部分）

助记符::
clmul _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CLMUL'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x5, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
clmul 生成 2·XLEN 无进位乘积的低半部分。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);
let output : xlenbits = 0;

foreach (i from 0 to (xlen - 1) by 1) {
   output = if   ((rs2_val >> i) & 1)
            then output ^ (rs1_val << i);
            else output;
}

X[rd] = output
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbc (<<#zbc>>)
|0.93
|冻结

|Zbkc (<<#zbkc>>)
|v0.9.4
|冻结
|===

<<<
[#insns-clmulh,reftext="无进位乘法（高位部分）"]
==== clmulh

简述::
无进位乘法（高位部分）

助记符::
clmulh _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x3, attr: ['CLMULH'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x5, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
clmulh 生成 2·XLEN 无进位乘积的高半部分。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);
let output : xlenbits = 0;

foreach (i from 1 to xlen by 1) {
   output = if   ((rs2_val >> i) & 1)
            then output ^ (rs1_val >> (xlen - i));
            else output;
}

X[rd] = output
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbc (<<#zbc>>)
|0.93
|冻结

|Zbkc (<<#zbkc>>)
|v0.9.4
|冻结
|===


<<<
[#insns-clmulr,reftext="无进位乘法（反向）"]
==== clmulr

简述::
无进位乘法（反向）

助记符::
clmulr _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x2, attr: ['CLMULR'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x5, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
*clmulr* 生成 2·XLEN 无进位乘积的 2·XLEN−2:XLEN-1 位。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);
let output : xlenbits = 0;

foreach (i from 0 to (xlen - 1) by 1) {
   output = if   ((rs2_val >> i) & 1)
            then output ^ (rs1_val >> (xlen - i - 1));
            else output;
}

X[rd] = output
--

.提示
[NOTE, caption="A" ]
===============================================================
*clmulr* 指令用于加速 CRC 计算。指令助记符中的 *r* 代表反向，因为该指令相当于对输入进行位反转，执行 *clmul*，然后对输出进行位反转。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbc (<<#zbc>>)
|0.93
|冻结
|===

<<<
[#insns-clz,reftext="计数前导零位"]
==== clz

简述::
计数前导零位

助记符::
clz _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CLZ']  },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x0, attr: ['CLZ'] },
    { bits:  7, name: 0x30, attr: ['CLZ']  },
]}
....

描述::
此指令从最高有效位（即 XLEN-1 位）开始，向最低有效位（即位 0）逐位计算第一个 1 之前的 0 的数量。因此，如果输入为 0，输出为 XLEN；如果输入的最高有效位为 1，输出为 0。

操作::
[source,sail]
--
val HighestSetBit : forall ('N : Int), 'N >= 0. bits('N) -> int

function HighestSetBit x = {
  foreach (i from (xlen - 1) to 0 by 1 in dec)
    if [x[i]] == 0b1 then return(i) else ();
  return -1;
}

let rs = X(rs);
X[rd] = (xlen - 1) - HighestSetBit(rs);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-clzw,reftext="计数字中的前导零位"]
==== clzw

简述::
计数字中的前导零位

助记符::
clzw _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x1b, attr: ['OP-IMM-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CLZW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x0, attr: ['CLZW'] },
    { bits:  7, name: 0x30, attr: ['CLZW'] },
]}
....

描述::
此指令计算从位 31 开始到第一个 1 之前 0 的数量。因此，如果最低有效字为 0 ，输出为 32 ；如果字的最高有效位（即位 31）为 1 ，输出为 0。

操作::
[source,sail]
--
val HighestSetBit32 : forall ('N : Int), 'N >= 0. bits('N) -> int

function HighestSetBit32 x = {
  foreach (i from 31 to 0 by 1 in dec)
    if [x[i]] == 0b1 then return(i) else ();
  return -1;
}

let rs = X(rs);
X[rd] = 31 - HighestSetBit(rs);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-cpop,reftext="计数设置位"]
==== cpop

简述::
计数设置位

助记符::
cpop _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CPOP'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x2, attr: ['CPOP'] },
    { bits:  7, name: 0x30, attr: ['CPOP'] },
]}
....
描述::
此指令计算源寄存器中 1 的数量（即设置位）。

操作::
[source,sail]
--
let bitcount = 0;
let rs = X(rs);

foreach (i from 0 to (xlen - 1) in inc)
    if rs[i] == 0b1 then bitcount = bitcount + 1 else ();

X[rd] = bitcount
--

.Software Hint
[NOTE, caption="SH" ]
===============================================================
此操作被称为人口计数、popcount、横向求和、位求和或汉明权重。

GCC 内建函数 `+__builtin_popcount (unsigned int x)+` 在 RV32 上由 cpop 实现，在 RV64 上由 *cpopw* 实现。
GCC 内建函数 `+__builtin_popcountl (unsigned long x)+` 在 LP64 上由 *cpop* 在 RV64 上实现。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-cpopw,reftext="计数字中的设置位"]
==== cpopw

简述::
计数字中的设置位

助记符::
cpopw _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x1b, attr: ['OP-IMM-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CPOPW'] },
    { bits:  5, name: 'rs' },
    { bits:  5, name: 0x2, attr: ['CPOPW'] },
    { bits:  7, name: 0x30, attr: ['CPOPW'] },
]}
....
描述::
此指令计算源寄存器中最低有效字中的1的数量（即设置位）。

操作::
[source,sail]
--
let bitcount = 0;
let val = X(rs);

foreach (i from 0 to 31 in inc)
    if val[i] == 0b1 then bitcount = bitcount + 1 else ();

X[rd] = bitcount
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-ctz,reftext="计数后导零位"]
==== ctz

简述::
计数后导零位

助记符::
ctz _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CTZ/CTZW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x1, attr: ['CTZ/CTZW'] },
    { bits:  7, name: 0x30, attr: ['CTZ/CTZW'] },
]}
....

描述::
此指令从最低有效位（即位 0）开始，逐位计算第一个 1 之前的 0 的数量，直到最高有效位（即位 XLEN-1）。因此，如果输入为 0，输出为 XLEN；如果输入的最低有效位为 1，输出为 0。

操作::
[source,sail]
--
val LowestSetBit : forall ('N : Int), 'N >= 0. bits('N) -> int

function LowestSetBit x = {
  foreach (i from 0 to (xlen - 1) by 1 in dec)
    if [x[i]] == 0b1 then return(i) else ();
  return xlen;
}

let rs = X(rs);
X[rd] = LowestSetBit(rs);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-ctzw,reftext="计数字中的后导零位"]
==== ctzw

简述::
计数字中的后导零位

助记符::
ctzw _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x1b, attr: ['OP-IMM-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CTZ/CTZW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x1, attr: ['CTZ/CTZW'] },
    { bits:  7, name: 0x30, attr: ['CTZ/CTZW'] },
]}
....

描述::
此指令从最低有效位（即位 0）开始，逐位计算第一个 1 之前的 0 的数量，直到最低有效字的最高有效位（即位 31）。因此，如果最低有效字为 0，输出为 32；如果输入的最低有效位为 1，输出为 0。

操作::
[source,sail]
--
val LowestSetBit32 : forall ('N : Int), 'N >= 0. bits('N) -> int

function LowestSetBit32 x = {
  foreach (i from 0 to 31 by 1 in dec)
    if [x[i]] == 0b1 then return(i) else ();
  return 32;
}

let rs = X(rs);
X[rd] = LowestSetBit32(rs);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-max,reftext="最大值"]
==== max

简述::
最大值

助记符::
max _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x6, attr: ['MAX']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x05, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
此指令返回两个有符号整数中较大的一个。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);

let result = if   rs1_val <_s rs2_val
             then rs2_val
             else rs1_val;

X(rd) = result;
--

.软件提示
[NOTE, caption="SW"]
===============================================================
计算有符号整数的绝对值可以通过以下序列进行：*neg rD,rS* ，然后是 *max rD,rS,rD*。在使用此常见序列时，建议将它们安排在没有其它指令插入的情况下，以便经过优化的实现可以将它们合并在一起。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-maxu,reftext="无符号最大值"]
==== maxu

简述::
无符号最大值

助记符::
maxu _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x7, attr: ['MAXU']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x05, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
此指令返回两个无符号整数中较大的一个。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);

let result = if   rs1_val <_u rs2_val
             then rs2_val
             else rs1_val;

X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-min,reftext="最小值"]
==== min

简述::
最小值

助记符::
min _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['MIN']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x05, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
此指令返回两个有符号整数中较小的一个。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);

let result = if   rs1_val <_s rs2_val
             then rs1_val
             else rs2_val;

X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-minu,reftext="无符号最小值"]
==== minu

简述::
无符号最小值

助记符::
minu _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['MINU']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x05, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
此指令返回两个无符号整数中较小的一个。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);

let result = if   rs1_val <_u rs2_val
             then rs1_val
             else rs2_val;

X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-orc_b,reftext="按字节进行按位或组合"]
==== orc.b

简述::
按字节进行按位或组合

助记符::
orc.b _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5 },
    { bits:  5, name: 'rs' },
    { bits: 12, name: 0x287 }
]}
....

描述::
通过按位逻辑或将每个字节内的位进行合并。如果 _rs_ 的对应字节内没有任何位被设置，则将结果寄存器 _rd_ 中该字节的所有位都设置为零；如果 _rs_ 中对应字节内有任何位被设置，则结果寄存器 _rd_ 中该字节的所有位都为 1。

操作::
[source,sail]
--
let input = X(rs);
let output : xlenbits = 0;

foreach (i from 0 to (xlen - 8) by 8) {
   output[(i + 7)..i] = if   input[(i + 7)..i] == 0
                        then 0b00000000
                        else 0b11111111;
}

X[rd] = output;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-orn,reftext="对反转操作数进行按位或"]
==== orn

简述::
对反转操作数进行按位或

助记符::
orn _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x6, attr: ['ORN']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x20, attr: ['ORN'] },
]}
....

描述::
此指令对 _rs1_ 和 _rs2_ 的按位反结果执行按位或操作。

操作::
[source,sail]
--
X(rd) = X(rs1) | ~X(rs2);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-pack,reftext="打包寄存器的低半部分"]
==== pack

简述::
将 _rs1_ 和 _rs2_ 的低半部分打包到 _rd_ 中。

助记符::
pack _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    {bits:  7, name: 0x33, attr: ['OP'] },
    {bits: 5, name: 'rd'},
    {bits: 3, name: 0x4, attr:['PACK']},
    {bits: 5, name: 'rs1'},
    {bits: 5, name: 'rs2'},
    {bits: 7, name: 0x4, attr:['PACK']},
]}
....

描述::
pack 指令将 _rs1_ 和 _rs2_ 的 XLEN/2 位低半部分打包到 _rd_ 中，_rs1_ 位于低半部分，_rs2_ 位于高半部分。

操作::
[source,sail]
--
let lo_half : bits(xlen/2) = X(rs1)[xlen/2-1..0];
let hi_half : bits(xlen/2) = X(rs2)[xlen/2-1..0];
X(rd) = EXTZ(hi_half @ lo_half);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-packh,reftext="打包寄存器的低字节"]
==== packh

简述::
将 _rs1_ 和 _rs2_ 的低字节打包到 _rd_ 中。

助记符::
packh _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    {bits:  7, name: 0x33, attr: ['OP'] },
    {bits: 5, name: 'rd'},
    {bits: 3, name: 0x7, attr: ['PACKH']},
    {bits: 5, name: 'rs1'},
    {bits: 5, name: 'rs2'},
    {bits: 7, name: 0x4, attr: ['PACKH']},
]}
....

描述::
packh 指令将 _rs1_ 和 _rs2_ 的最低有效字节打包到 _rd_ 的 16 个最低有效位中，零扩展 _rd_ 的其余部分。

操作::
[source,sail]
--
let lo_half : bits(8) = X(rs1)[7..0];
let hi_half : bits(8) = X(rs2)[7..0];
X(rd) = EXTZ(hi_half @ lo_half);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-packw,reftext="打包寄存器的低 16 位（RV64）"]
==== packw

简述::
在 RV64 上将 _rs1_ 和 _rs2_ 的低 16 位打包到 _rd_ 中。

助记符::
packw _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
{bits: 2, name: 0x3},
{bits: 5, name: 0xe},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x4},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 7, name: 0x4},
]}
....

描述::
此指令将 _rs1_ 和 _rs2_ 的低 16 位打包到 _rd_ 的 32 个最低有效位中，将 32 位结果符号位扩展到 _rd_ 的其余部分。此指令仅存在于基于 RV64 的系统上。

操作::
[source,sail]
--
let lo_half : bits(16) = X(rs1)[15..0];
let hi_half : bits(16) = X(rs2)[15..0];
X(rd) = EXTS(hi_half @ lo_half);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-rev8,reftext="字节反转寄存器"]
==== rev8

简述::
字节反转寄存器

助记符::
rev8 _rd_, _rs_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5 },
    { bits:  5, name: 'rs' },
    { bits: 12, name: 0x698 }
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5 },
    { bits:  5, name: 'rs' },
    { bits: 12, name: 0x6b8 }
]}
....

描述::
此指令反转_rs_中的字节顺序。

操作::
[source,sail]
--
let input = X(rs);
let output : xlenbits = 0;
let j = xlen - 1;

foreach (i from 0 to (xlen - 8) by 8) {
   output[i..(i + 7)] = input[(j - 7)..j];
   j = j - 8;
}

X[rd] = output
--

.提示
[NOTE, caption="A" ]
===============================================================
*rev8* 助记符在 RV32 和 RV64 中对应不同的指令编码。
===============================================================

.软件提示
[NOTE, caption="SH" ]
===============================================================
字节反转操作仅适用于整个寄存器宽度。为了模拟单字大小和半字大小的字节反转，可以执行 `rev8 rd,rs` ，然后执行 `srai rd,rd,K` ，其中 K 分别为 XLEN-32 和 XLEN-16。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-revb,reftext="反转字节中的比特位"]
==== rev.b

简述::
反转源寄存器中每个字节的比特位。

助记符::
rev.b _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5 },
    { bits:  5, name: 'rs' },
    { bits: 12, name: 0x687 }
]}
....

描述::
此指令反转寄存器中每个字节的位顺序。

操作::
[source,sail]
--
result : xlenbits = EXTZ(0b0);
foreach (i from 0 to sizeof(xlen) by 8) {
    result[i+7..i] = reverse_bits_in_byte(X(rs1)[i+7..i]);
};
X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-rol,reftext="左旋转（寄存器）"]
==== rol

简述::
左旋转（寄存器）

助记符::
rol _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['ROL']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x30, attr: ['ROL'] },
]}
....

描述::
此指令执行 _rs1_ 的左旋转，旋转的位数由 _rs2_ 中最低有效的 log2(XLEN) 位决定。

操作::
[source,sail]
--
let shamt = if   xlen == 32
            then X(rs2)[4..0]
            else X(rs2)[5..0];
let result = (X(rs1) << shamt) | (X(rs1) >> (xlen - shamt));

X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-rolw,reftext="左旋转字（寄存器）"]
==== rolw

简述::
左旋转字（寄存器）

助记符::
rolw _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['ROLW']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x30, attr: ['ROLW'] },
]}
....

描述::
此指令对 _rs1_ 的最低有效字进行左旋转，选择的位数由 _rs2_ 中最低有效的 5 位决定。结果字值通过将第 31 位复制到所有更高有效位来进行符号扩展。

操作::
[source,sail]
--
let rs1 = EXTZ(X(rs1)[31..0])
let shamt = X(rs2)[4..0];
let result = (rs1 << shamt) | (rs1 >> (32 - shamt));
X(rd) = EXTS(result[31..0]);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-ror,reftext="右旋转（寄存器）"]
==== ror

简述::
右旋转

助记符::
ror _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['ROR']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x30, attr: ['ROR'] },
]}
....

描述::
此指令对 _rs1_ 进行右旋转，旋转的位数由 _rs2_ 的最低有效的 log2(XLEN) 位决定。

操作::
[source,sail]
--
let shamt = if   xlen == 32
            then X(rs2)[4..0]
            else X(rs2)[5..0];
let result = (X(rs1) >> shamt) | (X(rs1) << (xlen - shamt));

X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-rori,reftext="右旋转（立即数）"]
==== rori

简述::
右旋转（立即数）

助记符::
rori _rd_, _rs1_, _shamt_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['RORI']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x30, attr: ['RORI'] },
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['RORI']},
    { bits:  5, name: 'rs1' },
    { bits:  6, name: 'shamt' },
    { bits:  6, name: 0x18, attr: ['RORI'] },
]}
....

描述::
此指令对 _rs1_ 进行右旋转，旋转的位数由 _shamt_ 的最低有效的 log2(XLEN) 位决定。对于 RV32 ，shamt[5]=1 对应的编码是保留的。

操作::
[source,sail]
--
let shamt = if   xlen == 32
            then shamt[4..0]
            else shamt[5..0];
let result = (X(rs1) >> shamt) | (X(rs1) << (xlen - shamt));

X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-roriw,reftext="右旋转字（立即数）"]
==== roriw

简述::
右旋转字（立即数）

助记符::
roriw _rd_, _rs1_, _shamt_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x1b, attr: ['OP-IMM-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['RORIW']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x30, attr: ['RORIW'] },
]}
....

描述::
此指令对 _rs1_ 的最低有效字进行右旋转，旋转的位数由 _shamt_ 中最低有效的 log2(XLEN) 位决定。结果字值通过将第 31 位复制到所有更高有效位来进行符号扩展。

操作::
[source,sail]
--
let rs1_data = EXTZ(X(rs1)[31..0];
let result = (rs1_data >> shamt) | (rs1_data << (32 - shamt));
X(rd) = EXTS(result[31..0]);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-rorw,reftext="右旋转字（寄存器）"]
==== rorw

简述::
右旋转字（寄存器）

助记符::
rorw _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['RORW']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x30, attr: ['RORW'] },
]}
....

描述::
此指令对 _rs1_ 的最低有效字执行右旋操作，旋转的位数由 _rs2_ 的最低有效 5 位决定。
结果字的值会通过将位 31 复制到所有更高位来进行符号扩展。

操作::
[source,sail]
--
let rs1 = EXTZ(X(rs1)[31..0])
let shamt = X(rs2)[4..0];
let result = (rs1 >> shamt) | (rs1 << (32 - shamt));
X(rd) = EXTS(result);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-sext_b,reftext="符号扩展字节"]
==== sext.b

简述::
符号位扩展字节

助记符::
sext.b _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['SEXT.B/SEXT.H'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x04, attr: ['SEXT.B'] },
    { bits:  7, name: 0x30 },
]}
....

描述::
此指令通过将字节中的最高有效位（即第 7 位）复制到所有更高有效位来将源操作数中的最低有效字节符号位扩展到 XLEN 位。

操作::
[source,sail]
--
X(rd) = EXTS(X(rs)[7..0]);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-sext_h,reftext="符号扩展半字"]
==== sext.h

简述::
符号扩展半字

助记符::
sext.h _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['SEXT.B/SEXT.H'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x05, attr: ['SEXT.H'] },
    { bits:  7, name: 0x30 },
]}
....

描述::
此指令通过将半字中的最高有效位（即第 15 位）复制到所有更高有效位，来将 _rs_ 中的最低有效半字符号位扩展到 XLEN 位。

操作::
[source,sail]
--
X(rd) = EXTS(X(rs)[15..0]);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===


<<<
[#insns-sh1add,reftext=左移 1 位并且相加]
==== sh1add

简述::
左移 1 位并且相加

助记符::
sh1add _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x2, attr: ['SH1ADD'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x10, attr: ['SH1ADD'] },
]}
....

描述::
此指令将 _rs1_ 左移 1 位，并将其加到 _rs2_ 中。

操作::
[source,sail]
--
X(rd) = X(rs2) + (X(rs1) << 1);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

// 我们已经决定此指令和所有其他指令不会为“无用编码”保留编码
// 如果有某种公认的价值，我们可以效仿基本 ISA 并创建 HINTs

<<<
[#insns-sh1add_uw,reftext= 与左移 1 位的无符号字相加]
==== sh1add.uw

简述::
与左移 1 位的无符号字相加

助记符::
sh1add.uw _rd_, _rs1_, _rs2_
编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x2, attr: ['SH1ADD.UW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x10, attr: ['SH1ADD.UW']  },
]}
....

描述::
此指令执行两个加数的 XLEN 位宽加法。第一个加数是 _rs2_。第二个加数是通过提取 _rs1_ 中的最低有效字并将其左移 1 位形成的无符号值。

操作::
[source,sail]
--
let base = X(rs2);
let index = EXTZ(X(rs1)[31..0]);

X(rd) = base + (index << 1);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

<<<
[#insns-sh2add,reftext=左移 2 位并且相加]
==== sh2add

简述::
左移 2 位并且相加

助记符::
sh2add _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['SH2ADD'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x10, attr: ['SH2ADD'] },
]}
....

描述::
此指令将 _rs1_ 左移 2 位，并将其与 _rs2_ 相加。

操作::
[source,sail]
--
X(rd) = X(rs2) + (X(rs1) << 2);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

<<<
[#insns-sh2add_uw,reftext=与左移 2 位的无符号字相加]
==== sh2add.uw

简述::
与左移 2 位的无符号字相加

助记符::
sh2add.uw _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['SH2ADD.UW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x10, attr: ['SH2ADD.UW'] },
]}
....

描述::
此指令执行一个 XLEN 位宽的加法运算。第一个加数是 _rs2_。第二个加数是通过提取 _rs1_ 的最低有效字并将其左移 2 位得到的无符号值。

操作::
[source,sail]
--
let base = X(rs2);
let index = EXTZ(X(rs1)[31..0]);

X(rd) = base + (index << 2);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

<<<
[#insns-sh3add,reftext=左移 3 位并且相加]
==== sh3add

简述::
左移 3 位并且相加

助记符::
sh3add _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x6, attr: ['SH3ADD'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x10, attr: ['SH3ADD'] },
]}
....

描述::
此指令将 _rs1_ 左移 3 位，并将其加到 _rs2_。

操作::
[source,sail]
--
X(rd) = X(rs2) + (X(rs1) << 3);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

<<<
[#insns-sh3add_uw,reftext=与左移 3 位的无符号字相加]
==== sh3add.uw

简述::
与左移 3 位的无符号字相加

助记符::
sh3add.uw _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x6, attr: ['SH3ADD.UW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x10, attr: ['SH3ADD.UW'] },
]}
....

描述::
此指令执行两个加数的 XLEN 位宽加法。第一个加数是 _rs2_。第二个加数是通过提取 _rs1_ 的最低有效字并将其左移 3 位得到的无符号值。

操作::
[source,sail]
--
let base = X(rs2);
let index = EXTZ(X(rs1)[31..0]);

X(rd) = base + (index << 3);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

<<<
[#insns-slli_uw,reftext="左移无符号字（立即数）"]
==== slli.uw

简述::
左移无符号字（立即数）

助记符::
slli.uw _rd_, _rs1_, _shamt_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x1b, attr: ['OP-IMM-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['SLLI.UW'] },
    { bits:  5, name: 'rs1' },
    { bits:  6, name: 'shamt' },
    { bits:  6, name: 0x02, attr: ['SLLI.UW'] },
]}
....

描述::
此指令将 _rs1_ 的最低有效字提取出来，进行零扩展，并按立即数左移。

操作::
[source,sail]
--
X(rd) = (EXTZ(X(rs)[31..0]) << shamt);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

.架构解释
[NOTE, caption="A" ]
===============================================================
此指令与 *slli* 相同，在左移之前对 _rs1_ 执行 *zext.w*。
===============================================================

<<<
[#insns-unzip,reftext="位解交错 (Bit deinterleave)"]
==== unzip

简述::
实现 zip 指令的逆操作。

助记符::
unzip _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13, attr: ['OP-IMM']},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x5},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x1f},
{bits: 7, name: 0x4},
]}
....

描述::
此指令将源操作字的高半部分和低半部分中的位收集到目标字的奇偶位位置中。它是 <<insns-zip,zip>> 指令的逆操作。此指令仅在 RV32 上可用。

操作::
[source,sail]
--
foreach (i from 0 to xlen/2-1) {
  X(rd)[i] = X(rs1)[2*i]
  X(rd)[i+xlen/2] = X(rs1)[2*i+1]
}
--

.软件提示
[NOTE, caption="SH" ]
===============================================================
此指令对于在 32 位架构上实现 SHA3 加密哈希函数 （hash function） 非常有用，因为它实现了用于加速 64 位旋转的位交错操作。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkb (<<#zbkb>>) (RV32)
|v0.9.4
|冻结
|===

<<<
[#insns-xnor,reftext="异或非"]
==== xnor

简述::
异或非

助记符::
xnor _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['XNOR']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x20, attr: ['XNOR'] },
]}
....

描述::
此指令对 _rs1_ 和 _rs2_ 执行按位异或非操作。

操作::
[source,sail]
--
X(rd) = ~(X(rs1) ^ X(rs2));
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-xpermb,reftext="交叉开关置换（字节）"]
==== xperm.b

简述::
按字节方式查找寄存器中向量的索引。

助记符::
xperm.b _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
{bits: 2, name: 0x3},
{bits: 5, name: 0xc},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x4},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 7, name: 0x14},
]}
....

描述::
xperm.b 指令作用于字节。_rs1_ 寄存器包含一个 XLEN/8 大小的 8 位元素向量。_rs2_ 寄存器包含一个 XLEN/8 大小的 8 位索引向量。结果是 _rs2_ 中的每个元素将被替换为 _rs1_ 中对应索引的元素，如果 _rs2_ 中的索引越界，则该元素为零。

操作::
[source,sail]
--
val xpermb_lookup : (bits(8), xlenbits) -> bits(8)
function xpermb_lookup (idx, lut) = {
    (lut >> (idx @ 0b000))[7..0]
}

function clause execute ( XPERM_B (rs2,rs1,rd)) = {
    result : xlenbits = EXTZ(0b0);
    foreach(i from 0 to xlen by 8) {
        result[i+7..i] = xpermn_lookup(X(rs2)[i+7..i], X(rs1));
    };
    X(rd) = result;
    RETIRE_SUCCESS
}
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkx (<<#zbkx>>)
|v0.9.4
|冻结
|===

<<<
[#insns-xpermn,reftext="交叉开关置换（半字节）"]
==== xperm.n

简述::
在向量中按半字节查找索引。

助记符::
xperm.n _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
{bits: 2, name: 0x3},
{bits: 5, name: 0xc},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x2},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 7, name: 0x14},
]}
....

描述::
xperm.n 指令作用于半字节。_rs1_ 寄存器包含一个 XLEN/4 大小的 4 位元素向量。_rs2_ 寄存器包含一个 XLEN/4 大小的 4 位索引向量。结果是 _rs2_ 中的每个元素将被替换为 _rs1_ 中对应索引的元素，如果 _rs2_ 中的索引越界，则该元素为零。

操作::
[source,sail]
--
val xpermn_lookup : (bits(4), xlenbits) -> bits(4)
function xpermn_lookup (idx, lut) = {
    (lut >> (idx @ 0b00))[3..0]
}

function clause execute ( XPERM_N (rs2,rs1,rd)) = {
    result : xlenbits = EXTZ(0b0);
    foreach(i from 0 to xlen by 4) {
        result[i+3..i] = xpermn_lookup(X(rs2)[i+3..i], X(rs1));
    };
    X(rd) = result;
    RETIRE_SUCCESS
}
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkx (<<#zbkx>>)
|v0.9.4
|冻结
|===

<<<
[#insns-zext_h,reftext="零扩展半字"]
==== zext.h

简述::
零扩展半字

助记符::
zext.h _rd_, _rs_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['ZEXT.H']},
    { bits:  5, name: 'rs' },
    { bits:  5, name: 0x00 },
    { bits:  7, name: 0x04 },
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['ZEXT.H']},
    { bits:  5, name: 'rs' },
    { bits:  5, name: 0x00 },
    { bits:  7, name: 0x04 },
]}
....

描述::
此指令通过在高于第 15 位的所有位插入 0，将源操作数的最低有效半字零扩展到 XLEN。

操作::
[source,sail]
--
X(rd) = EXTZ(X(rs)[15..0]);
--

.提示
[NOTE, caption="A" ]
===============================================================
*zext.h* 助记符在 RV32 和 RV64 中对应不同的指令编码。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-zip,reftext="位交错 (Bit interleave)"]
==== zip

简述::
将源操作字的奇偶位收集到目标的上半部分和下半部分。

助记符::
zip _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13, attr: ['OP-IMM']},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x1e},
{bits: 7, name: 0x4},
]}
....

描述::
此指令将源操作字的所有奇偶位分散到目标操作数的高半部分和低半部分。它是 <<insns-unzip,unzip>> 指令的逆操作。此指令仅在 RV32 上可用。

操作::
[source,sail]
--
foreach (i from 0 to xlen/2-1) {
  X(rd)[2*i] = X(rs1)[i]
  X(rd)[2*i+1] = X(rs1)[i+xlen/2]
}
--

.软件提示
[NOTE, caption="SH" ]
===============================================================
此指令对于在32位架构上实现SHA3加密哈希函数非常有用，因为它实现了用于直接加速64位旋转的位交织操作。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkb (<<#zbkb>>) (RV32)
|v0.9.4
|冻结
|===


=== 软件优化指南

==== strlen

*orc.b* 指令允许高效检测 XLEN 大小数据块中的 *NUL* 字节：

 * 对于不包含任何 *NUL* 字节的数据块，*orc.b* 的结果将是是全为 1，
 * 在对 *orc.b* 的结果进行按位取反后，可以通过 *ctz*/*clz* （取决于数据的字节序）检测出第一个 *NUL* 字节之前的数据字节数（如果有的话）。

下面一个完整的 *strlen* 函数示例，它使用了这些技术，并演示了它在未对齐/部分数据情况下的使用：
[source,asm]
--
#include <sys/asm.h>

    .text
    .globl strlen
    .type  strlen, @function
strlen:
    andi	a3, a0, (SZREG-1)   // 偏移量
    andi    a1, a0, -SZREG      // 对齐指针
.Lprologue:
    li      a4, SZREG
    sub     a4, a4, a3          // XLEN - 偏移量
    slli	a3, a3, 3           // 偏移量 * 8
    REG_L   a2, 0(a1)           // 数据块
    /*
     * 将我们加载的部分或未对齐的数据块进行移位，以去除字符串开始之前的字节，并在末尾添加 NUL 字节。
     */
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    srl	a2, a2 ,a3          // 数据块 >> (偏移量 * 8)
#else
    sll     a2, a2, a3
#endif
    orc.b   a2, a2
    not	a2, a2
    /*
     * 字符串中的非 NUL 字节已扩展为 0x00，而 NUL 字节已变为 0xff。搜索第一个设置的位
     * （对应于初始数据块中的 NUL 字节）。
     */
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    ctz     a2, a2
#else
    clz     a2, a2
#endif
    /*
     * 第一个数据块是特殊的：与此数据块中的有效字节数进行比较。
     */
    srli    a0, a2, 3
    bgtu    a4, a0, .Ldone
    addi    a3, a1, SZREG
    li      a4, -1
    .align 2
    /*
     * 我们的关键循环是 4 条指令，并以 4 字节或 8 字节的数据块处理数据。
     */
.Lloop:
    REG_L   a2, SZREG(a1)
    addi    a1, a1, SZREG
    orc.b   a2, a2
    beq     a2, a4, .Lloop

.Lepilogue:
    not     a2, a2
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    ctz     a2, a2
#else
    clz     a2, a2
#endif
    sub     a1, a1, a3
    add	a0, a0, a1
    srli    a2, a2, 3
    add 	a0, a0, a2
.Ldone:
    ret
--

==== strcmp

[source,asm]
--
#include <sys/asm.h>

  .text
  .globl strcmp
  .type  strcmp, @function
strcmp:
  or    a4, a0, a1
  li    t2, -1
  and   a4, a4, SZREG-1
  bnez  a4, .Lsimpleloop

  # 对齐字符串的主循环
.Lloop:
  REG_L a2, 0(a0)
  REG_L a3, 0(a1)
  orc.b t0, a2
  bne   t0, t2, .Lfoundnull
  addi  a0, a0, SZREG
  addi  a1, a1, SZREG
  beq   a2, a3, .Lloop

  # 字不匹配，且第一个字中没有空字节。
  # 获取大端字节顺序的字节并进行比较。
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  rev8  a2, a2
  rev8  a3, a3
#endif
  # 在无分支序列中合成 (a2 >= a3) ? 1 : -1。
  sltu a0, a2, a3
  neg  a0, a0
  ori  a0, a0, 1
  ret

.Lfoundnull:
  # 找到一个空字节。
  # 如果字不匹配，则回退到简单循环。
  bne   a2, a3, .Lsimpleloop

  # 否则，字符串相等。
  li    a0, 0
  ret

  # 未对齐字符串的简单循环
.Lsimpleloop:
  lbu   a2, 0(a0)
  lbu   a3, 0(a1)
  addi  a0, a0, 1
  addi  a1, a1, 1
  bne   a2, a3, 1f
  bnez  a2, .Lsimpleloop

1:
  sub   a0, a2, a3
  ret

.size   strcmp, .-strcmp
--
