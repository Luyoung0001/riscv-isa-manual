[[bits]]
== "B" 扩展：位操作，版本 1.0.0

B 标准扩展包括由 Zba、Zbb 和 Zbs 扩展提供的指令。

[[preface]]
=== 位操作 a、b、c 和 s 扩展组合以供公众审查和批准

位操作（bitmanip）扩展集合由几个基本 RISC-V 架构的组件扩展组成，旨在提供代码大小减少、性能提升和能量减少的组合。
虽然这些指令旨在具有广泛的用途，但某些指令在某些领域比其他领域更有用。
因此，提供了几个较小的位操作扩展，而不是一个大的扩展。
每个较小的扩展按共同功能和使用案例分组，每个都有自己的 Zb*-扩展名称。

每个位操作扩展包括一组具有相似目的的多个位操作指令，这些指令通常可以共享相同的逻辑。一些指令仅在一个扩展中可用，而其他指令在多个扩展中可用。
这些指令的助记符和编码独立于它们出现的扩展。
因此，在实现具有重叠指令的扩展时，逻辑或编码没有冗余。

位操作扩展定义了 RV32 和 RV64。
大多数指令预计与 RV128 向前兼容。
虽然移位立即数指令定义为最多具有 6 位立即数字段，但如果 RV128 需要，可以在编码空间中提供第 7 位。

=== 字指令

位操作扩展遵循 RV64 中的约定，带有 _w_ 后缀的指令（_w_ 前没有点）忽略其输入的高 32 位，操作最不重要的 32 位作为有符号值，并生成一个符号扩展到 XLEN 的 32 位有符号结果。

带有 _.uw_ 后缀的位操作指令有一个操作数是从指定寄存器的最低 32 位提取的无符号 32 位值。除此之外，这些指令执行完整的 XLEN 操作。

带有 _.b_、_.h_ 和 _.w_ 后缀的位操作指令仅查看输入的最低 8 位、16 位和 32 位（分别）并生成一个符号扩展或零扩展的 XLEN 宽结果，具体取决于特定指令。

=== 指令语义的伪代码

<<#insns>> 中每条指令的语义以类似 SAIL 的语法表示。

=== 扩展

第一组发布供公众审查的位操作扩展是：

* <<#zba>>
* <<#zbb>>
* <<#zbc>>
* <<#zbs>>

以下是这些扩展中包含的所有指令及其特定映射的列表：

[%header,cols="^3,^3,10,16,^2,^2,^2,^2"]
|====
|RV32
|RV64
|助记符
|指令
|Zba
|Zbb
|Zbc
|Zbs

|
|&#10003;
|add.uw _rd_, _rs1_, _rs2_
|<<#insns-add_uw>>
|&#10003;
|
|
|

|&#10003;
|&#10003;
|andn _rd_, _rs1_, _rs2_
|<<#insns-andn>>
|
|&#10003;
|
|


|&#10003;
|&#10003;
|clmul _rd_, _rs1_, _rs2_
|<<#insns-clmul>>
|
|
|&#10003;
|

|&#10003;
|&#10003;
|clmulh _rd_, _rs1_, _rs2_
|<<#insns-clmulh>>
|
|
|&#10003;
|

|&#10003;
|&#10003;
|clmulr _rd_, _rs1_, _rs2_
|<<#insns-clmulr>>
|
|
|&#10003;
|

|&#10003;
|&#10003;
|clz _rd_, _rs_
|<<#insns-clz>>
|
|&#10003;
|
|

|
|&#10003;
|clzw _rd_, _rs_
|<<#insns-clzw>>
|
|&#10003;
|
|
|&#10003;
|&#10003;
|cpop _rd_, _rs_
|<<#insns-cpop>>
|
|&#10003;
|
|

|
|&#10003;
|cpopw _rd_, _rs_
|<<#insns-cpopw>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|ctz _rd_, _rs_
|<<#insns-ctz>>
|
|&#10003;
|
|

|
|&#10003;
|ctzw _rd_, _rs_
|<<#insns-ctzw>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|max _rd_, _rs1_, _rs2_
|<<#insns-max>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|maxu _rd_, _rs1_, _rs2_
|<<#insns-maxu>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|min _rd_, _rs1_, _rs2_
|<<#insns-min>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|minu _rd_, _rs1_, _rs2_
|<<#insns-minu>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|orc.b _rd_, _rs1_, _rs2_
|<<#insns-orc_b>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|orn _rd_, _rs1_, _rs2_
|<<#insns-orn>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|rev8 _rd_, _rs_
|<<#insns-rev8>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|rol _rd_, _rs1_, _rs2_
|<<#insns-rol>>
|
|&#10003;
|
|

|
|&#10003;
|rolw _rd_, _rs1_, _rs2_
|<<#insns-rolw>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|ror _rd_, _rs1_, _rs2_
|<<#insns-ror>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|rori _rd_, _rs1_, _shamt_
|<<#insns-rori>>
|
|&#10003;
|
|

|
|&#10003;
|roriw _rd_, _rs1_, _shamt_
|<<#insns-roriw>>
|
|&#10003;
|
|

|
|&#10003;
|rorw _rd_, _rs1_, _rs2_
|<<#insns-rorw>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|bclr _rd_, _rs1_, _rs2_
|<<#insns-bclr>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|bclri _rd_, _rs1_, _imm_
|<<#insns-bclri>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|bext _rd_, _rs1_, _rs2_
|<<#insns-bext>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|bexti _rd_, _rs1_, _imm_
|<<#insns-bexti>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|binv _rd_, _rs1_, _rs2_
|<<#insns-binv>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|binvi _rd_, _rs1_, _imm_
|<<#insns-binvi>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|bset _rd_, _rs1_, _rs2_
|<<#insns-bset>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|bseti _rd_, _rs1_, _imm_
|<<#insns-bseti>>
|
|
|
|&#10003;

|&#10003;
|&#10003;
|sext.b _rd_, _rs_
|<<#insns-sext_b>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|sext.h _rd_, _rs_
|<<#insns-sext_h>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|sh1add _rd_, _rs1_, _rs2_
|<<#insns-sh1add>>
|&#10003;
|
|
|

|
|&#10003;
|sh1add.uw _rd_, _rs1_, _rs2_
|<<#insns-sh1add_uw>>
|&#10003;
|
|
|

|&#10003;
|&#10003;
|sh2add _rd_, _rs1_, _rs2_
|<<#insns-sh2add>>
|&#10003;
|
|
|

|
|&#10003;
|sh2add.uw _rd_, _rs1_, _rs2_
|<<#insns-sh2add_uw>>
|&#10003;
|
|
|

|&#10003;
|&#10003;
|sh3add _rd_, _rs1_, _rs2_
|<<#insns-sh3add>>
|&#10003;
|
|
|

|
|&#10003;
|sh3add.uw _rd_, _rs1_, _rs2_
|<<#insns-sh3add_uw>>
|&#10003;
|
|
|

|
|&#10003;
|slli.uw _rd_, _rs1_, _imm_
|<<#insns-slli_uw>>
|&#10003;
|
|
|

|&#10003;
|&#10003;
|xnor _rd_, _rs1_, _rs2_
|<<#insns-xnor>>
|
|&#10003;
|
|

|&#10003;
|&#10003;
|zext.h _rd_, _rs_
|<<#insns-zext_h>>
|
|&#10003;
|
|

|====

[#zba,reftext=地址生成指令]
==== Zba：地址生成

[NOTE,caption=冻结]
====
Zba 扩展已冻结。
====

Zba 指令可用于加速生成索引到基本类型（半字、字、双字）数组的地址，使用无符号字大小和 XLEN 大小的索引：将移位的索引添加到基地址。

移位和加法指令将左移 1、2 或 3 位，因为这些在现实世界代码中常见，并且可以用最少的额外硬件实现，超出简单加法器的范围。这避免了在实现中延长关键路径。

虽然移位和加法指令限制为最大左移 3 位，但 slli 指令（来自基本 ISA）可用于对更宽元素的数组进行类似的移位。slli.uw -- 在此扩展中添加 -- 可用于当索引被解释为无符号字时。

以下指令（和伪指令）组成 Zba 扩展：

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|
|&#10003;
|add.uw _rd_, _rs1_, _rs2_
|<<#insns-add_uw>>

|&#10003;
|&#10003;
|sh1add _rd_, _rs1_, _rs2_
|<<#insns-sh1add>>

|
|&#10003;
|sh1add.uw _rd_, _rs1_, _rs2_
|<<#insns-sh1add_uw>>

|&#10003;
|&#10003;
|sh2add _rd_, _rs1_, _rs2_
|<<#insns-sh2add>>

|
|&#10003;
|sh2add.uw _rd_, _rs1_, _rs2_
|<<#insns-sh2add_uw>>

|&#10003;
|&#10003;
|sh3add _rd_, _rs1_, _rs2_
|<<#insns-sh3add>>

|
|&#10003;
|sh3add.uw _rd_, _rs1_, _rs2_
|<<#insns-sh3add_uw>>

|
|&#10003;
|slli.uw _rd_, _rs1_, _imm_
|<<#insns-slli_uw>>

|
|&#10003;
|zext.w _rd_, _rs_
|<<#insns-add_uw>>

|===

[#zbb,reftext="基本位操作"]
==== Zbb：基本位操作

[NOTE,caption=冻结]
====
Zbb 扩展已冻结。
====
===== 带否定的逻辑操作

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|andn _rd_, _rs1_, _rs2_
|<<#insns-andn>>

|&#10003;
|&#10003;
|orn _rd_, _rs1_, _rs2_
|<<#insns-orn>>

|&#10003;
|&#10003;
|xnor _rd_, _rs1_, _rs2_
|<<#insns-xnor>>
|===

.实现提示
[NOTE, caption="实现" ]
===============================================================
带否定的逻辑指令可以通过将 _rs2_ 输入反转到基本要求的 AND、OR 和 XOR 逻辑指令来实现。
在某些实现中，用于减法的 rs2 反转器可以用于此目的。
===============================================================

===== 计数前导/尾随零位

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|clz _rd_, _rs_
|<<#insns-clz>>

|
|&#10003;
|clzw _rd_, _rs_
|<<#insns-clzw>>

|&#10003;
|&#10003;
|ctz _rd_, _rs_
|<<#insns-ctz>>

|
|&#10003;
|ctzw _rd_, _rs_
|<<#insns-ctzw>>
|===

===== 计数人口

这些指令计算设置位（1 位）的数量。这也通常称为人口计数。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|cpop _rd_, _rs_
|<<#insns-cpop>>

|
|&#10003;
|cpopw _rd_, _rs_
|<<#insns-cpopw>>
|===

===== 整数最小值/最大值

整数最小值/最大值指令是算术 R 型指令，返回两个操作数中较小/较大的一个。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|max _rd_, _rs1_, _rs2_
|<<#insns-max>>

|&#10003;
|&#10003;
|maxu _rd_, _rs1_, _rs2_
|<<#insns-maxu>>

|&#10003;
|&#10003;
|min _rd_, _rs1_, _rs2_
|<<#insns-min>>

|&#10003;
|&#10003;
|minu _rd_, _rs1_, _rs2_
|<<#insns-minu>>
|===

===== 符号扩展和零扩展

这些指令对源寄存器的最低 8 位或 16 位执行符号扩展或零扩展。

这些指令取代了广义的习惯用法 `slli rD,rS,(XLEN-<size>) + srli`（用于零扩展）或 `slli + srai`（用于符号扩展）用于 8 位和 16 位数量的符号扩展，以及 16 位数量的零扩展。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|sext.b _rd_, _rs_
|<<#insns-sext_b>>

|&#10003;
|&#10003;
|sext.h _rd_, _rs_
|<<#insns-sext_h>>

|&#10003;
|&#10003;
|zext.h _rd_, _rs_
|<<#insns-zext_h>>
|===

===== 位旋转

位旋转指令类似于基本规范中的逻辑移位操作。然而，逻辑移位指令移入零，而旋转指令则移入从值的另一侧移出的位。这种操作也被称为“循环移位”。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|rol _rd_, _rs1_, _rs2_
|<<#insns-rol>>

|
|&#10003;
|rolw _rd_, _rs1_, _rs2_
|<<#insns-rolw>>

|&#10003;
|&#10003;
|ror _rd_, _rs1_, _rs2_
|<<#insns-ror>>

|&#10003;
|&#10003;
|rori _rd_, _rs1_, _shamt_
|<<#insns-rori>>

|
|&#10003;
|roriw _rd_, _rs1_, _shamt_
|<<#insns-roriw>>

|
|&#10003;
|rorw _rd_, _rs1_, _rs2_
|<<#insns-rorw>>
|===

.架构解释
[NOTE, caption="AE" ]
===============================================================
包含旋转指令是为了替换实现相同效果的常见四指令序列（neg; sll/srl; srl/sll; or）
===============================================================

===== OR 组合

*orc.b* 将结果 _rd_ 中每个字节的位设置为全零，如果 _rs_ 的相应字节内没有任何位被设置，或者如果 _rs_ 的相应字节内有任何位被设置，则设置为全一。

一个用例是字符串处理函数，例如 *strlen* 和 *strcpy*，它们可以使用 *orc.b* 通过计算字中的前导非零字节中的设置位来测试终止零字节。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|orc.b _rd_, _rs_
|<<#insns-orc_b>>
|===

===== 字节反转

*rev8* 反转 _rs_ 的字节顺序。

[%header,cols="^1,^1,4,8"]
|====
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|rev8 _rd_, _rs_
|<<#insns-rev8>>

|====

[#zbc,reftext="无进位乘法"]
==== Zbc: 无进位乘法

[NOTE,caption=Frozen]
====
Zbc 扩展已冻结。
====

无进位乘法是在 GF(2) 上的多项式环中的乘法。

*clmul* 生成无进位乘积的低半部分，*clmulh* 生成 2&#x2715;XLEN 无进位乘积的高半部分。

*clmulr* 生成 2&#x2715;XLEN−2:XLEN-1 的 2&#x2715;XLEN 无进位乘积的位。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|clmul _rd_, _rs1_, _rs2_
|<<#insns-clmul>>

|&#10003;
|&#10003;
|clmulh _rd_, _rs1_, _rs2_
|<<#insns-clmulh>>

|&#10003;
|&#10003;
|clmulr _rd_, _rs1_, _rs2_
|<<#insns-clmulr>>

|===

[#zbs,reftext="单个位指令"]
==== Zbs: 单个位指令

[NOTE,caption=Frozen]
====
Zbs 扩展已冻结。
====

单个位指令提供了一种机制来设置、清除、反转或提取寄存器中的单个位。该位由其索引指定。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|bclr _rd_, _rs1_, _rs2_
|<<#insns-bclr>>

|&#10003;
|&#10003;
|bclri _rd_, _rs1_, _imm_
|<<#insns-bclri>>

|&#10003;
|&#10003;
|bext _rd_, _rs1_, _rs2_
|<<#insns-bext>>

|&#10003;
|&#10003;
|bexti _rd_, _rs1_, _imm_
|<<#insns-bexti>>

|&#10003;
|&#10003;
|binv _rd_, _rs1_, _rs2_
|<<#insns-binv>>

|&#10003;
|&#10003;
|binvi _rd_, _rs1_, _imm_
|<<#insns-binvi>>

|&#10003;
|&#10003;
|bset _rd_, _rs1_, _rs2_
|<<#insns-bset>>

|&#10003;
|&#10003;
|bseti _rd_, _rs1_, _imm_
|<<#insns-bseti>>

|===

[#zbkb,reftext="用于加密的位操作"]
==== Zbkb: 用于加密的位操作

[NOTE,caption=Frozen]
====
Zbkb 扩展已冻结。
====

此扩展包含实现加密工作负载中常见操作所必需的指令。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

| &#10003;
| &#10003;
|  rol
| <<insns-rol>>

|
| &#10003;
|  rolw
| <<insns-rolw>>

| &#10003;
| &#10003;
|  ror
| <<insns-ror>>

| &#10003;
| &#10003;
|  rori
| <<insns-rori>>

|
| &#10003;
|  roriw
| <<insns-roriw>>

|
| &#10003;
|  rorw
| <<insns-rorw>>

| &#10003;
| &#10003;
|  andn
| <<insns-andn>>

| &#10003;
| &#10003;
|  orn
| <<insns-orn>>

| &#10003;
| &#10003;
|  xnor
| <<insns-xnor>>

| &#10003;
| &#10003;
|  pack
| <<insns-pack>>

| &#10003;
| &#10003;
|  packh
| <<insns-packh>>

|
| &#10003;
|  packw
| <<insns-packw>>

| &#10003;
| &#10003;
|  rev.b
| <<insns-revb>>

| &#10003;
| &#10003;
|  rev8
| <<insns-rev8>>

| &#10003;
|
|  zip
| <<insns-zip>>

| &#10003;
|
|  unzip
| <<insns-unzip>>

|===

[#zbkc,reftext="用于加密的无进位乘法"]
==== Zbkc: 用于加密的无进位乘法

[NOTE,caption=Frozen]
====
Zbkc 扩展已冻结。
====

无进位乘法是在 GF(2) 上的多项式环中的乘法。这是某些加密工作负载中的关键操作，特别是 AES-GCM 认证加密方案。此扩展仅提供高效实现 GHASH 操作所需的指令，这是此工作负载的一部分。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|clmul _rd_, _rs1_, _rs2_
|<<#insns-clmul>>

|&#10003;
|&#10003;
|clmulh _rd_, _rs1_, _rs2_
|<<#insns-clmulh>>

|===

[#zbkx,reftext="交叉开关置换"]
==== Zbkx: 交叉开关置换

[NOTE,caption=Frozen]
====
Zbkx 扩展已冻结。
====

这些指令在通用寄存器内实现了一个用于 4 位和 8 位元素的“查找表”。
_rs1_ 用作 N 位字的向量，_rs2_ 用作 _rs1_ 中 N 位索引的向量。
_rs1_ 中的元素被 _rs2_ 中索引的元素替换，如果索引超出 _rs2_ 的范围，则替换为零。

这些指令对于表达 N 位到 N 位的布尔操作以及实现具有秘密依赖内存访问（特别是 SBoxes）的加密代码非常有用，这样执行延迟不依赖于正在操作的（秘密）数据。

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|助记符
|指令

|&#10003;
|&#10003;
|xperm.n _rd_, _rs1_, _rs2_
|<<#insns-xpermn>>

|&#10003;
|&#10003;
|xperm.b _rd_, _rs1_, _rs2_
|<<#insns-xpermb>>

|===

<<<

[#insns,reftext="按字母顺序排列的指令"]
=== 按字母顺序排列的指令

[#insns-add_uw,reftext=添加无符号字]
==== add.uw

简述::
添加无符号字

助记符::
add.uw _rd_, _rs1_, _rs2_

伪指令::
zext.w _rd_, _rs1_ &#8594; add.uw _rd_, _rs1_, zero

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x0, attr: ['ADD.UW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x04, attr: ['ADD.UW'] },
]}
....

描述::
此指令在 _rs2_ 和 _rs1_ 的零扩展最低有效字之间执行 XLEN 宽的加法。

操作::
[source,sail]
--
let base = X(rs2);
let index = EXTZ(X(rs1)[31..0]);

X(rd) = base + index;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<zba>>)
|0.93
|Frozen
|===

<<<
[#insns-andn,reftext="与反操作数的 AND"]
==== andn

简述::
与反操作数的 AND

助记符::
andn _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x7, attr: ['ANDN']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x20, attr: ['ANDN'] },
]}
....

描述::
此指令在 _rs1_ 和 _rs2_ 的按位反转之间执行按位逻辑 AND 操作。

操作::
[source,sail]
--
X(rd) = X(rs1) & ~X(rs2);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|Frozen

|Zbkb (<<#zbkb>>)
|v0.9.4
|Frozen
|===

<<<
[#insns-bclr,reftext="单个位清除（寄存器）"]
==== bclr

简述::
单个位清除（寄存器）

助记符::
bclr _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BCLR'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x24, attr: ['BCLR/BEXT'] },
]}
....

描述::
此指令返回在 _rs2_ 指定的索引处清除单个位的 _rs1_。
索引从 _rs2_ 的低 log2(XLEN) 位读取。

操作::
[source,sail]
--
let index = X(rs2) & (XLEN - 1);
X(rd) = X(rs1) & ~(1 << index)
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|Frozen
|===

<<<
[#insns-bclri,reftext="单个位清除（立即数）"]
==== bclri

简述::
单个位清除（立即数）

助记符::
bclri _rd_, _rs1_, _shamt_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BCLRI'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x24, attr: ['BCLRI'] },
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BCLRI'] },
    { bits:  5, name: 'rs1' },
    { bits:  6, name: 'shamt' },
    { bits:  6, name: 0x12, attr: ['BCLRI'] },
]}
....

描述::
此指令返回在 _shamt_ 指定的索引处清除单个位的 _rs1_。
索引从 _shamt_ 的低 log2(XLEN) 位读取。
对于 RV32，对应于 shamt[5]=1 的编码是保留的。

操作::
[source,sail]
--
let index = shamt & (XLEN - 1);
X(rd) = X(rs1) & ~(1 << index)
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|Frozen
|===

<<<
[#insns-bext,reftext="单个位提取（寄存器）"]
==== bext

简述::
单个位提取（寄存器）
// 我们是否应该将其描述为“如果位被设置则设置”？

助记符::
bext _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['BEXT'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x24, attr: ['BCLR/BEXT'] },
]}
....

描述::
此指令从 _rs1_ 中返回在 _rs2_ 指定的索引处提取的单个位。
索引从 _rs2_ 的低 log2(XLEN) 位读取。

操作::
[source,sail]
--
let index = X(rs2) & (XLEN - 1);
X(rd) = (X(rs1) >> index) & 1;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|Frozen
|===

<<<
[#insns-bexti,reftext="单个位提取（立即数）"]
==== bexti

简述::
单个位提取（立即数）

助记符::
bexti _rd_, _rs1_, _shamt_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['BEXTI'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x24, attr: ['BEXTI/BCLRI'] },
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['BEXTI'] },
    { bits:  5, name: 'rs1' },
    { bits:  6, name: 'shamt' },
    { bits:  6, name: 0x12, attr: ['BEXTI/BCLRI'] },
]}
....

描述::
此指令从 _rs1_ 中返回在 _shamt_ 指定的索引处提取的单个位。
索引从 _shamt_ 的低 log2(XLEN) 位读取。
对于 RV32，对应于 shamt[5]=1 的编码是保留的。

操作::
[source,sail]
--
let index = shamt & (XLEN - 1);
X(rd) = (X(rs1) >> index) & 1;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|Frozen
|===

<<<
[#insns-binv,reftext="单个位反转（寄存器）"]
==== binv

简述::
单个位反转（寄存器）

助记符::
binv _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BINV'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x34, attr: ['BINV'] },
]}
....

描述::
此指令返回在 _rs2_ 指定的索引处反转单个位的 _rs1_。
索引从 _rs2_ 的低 log2(XLEN) 位读取。

操作::
[source,sail]
--
let index = X(rs2) & (XLEN - 1);
X(rd) = X(rs1) ^ (1 << index)
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|Frozen
|===

<<<
[#insns-binvi,reftext="单个位反转（立即数）"]
==== binvi

简述::
单个位反转（立即数）

助记符::
binvi _rd_, _rs1_, _shamt_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BINV'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x34, attr: ['BINVI'] },
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BINV'] },
    { bits:  5, name: 'rs1' },
    { bits:  6, name: 'shamt' },
    { bits:  6, name: 0x1a, attr: ['BINVI'] },
]}
....

描述::
此指令返回在 _shamt_ 指定的索引处反转单个位的 _rs1_。
索引从 _shamt_ 的低 log2(XLEN) 位读取。
对于 RV32，对应于 shamt[5]=1 的编码是保留的。

操作::
[source,sail]
--
let index = shamt & (XLEN - 1);
X(rd) = X(rs1) ^ (1 << index)
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|Frozen
|===

<<<
[#insns-bset,reftext="单个位设置（寄存器）"]
==== bset

简述::
单个位设置（寄存器）

助记符::
bset _rd_, _rs1_,_rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['BSET'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x14, attr: ['BSET'] },
]}
....

描述::
此指令返回在 _rs2_ 指定的索引处设置单个位的 _rs1_。
索引从 _rs2_ 的低 log2(XLEN) 位读取。

操作::
[source,sail]
--
let index = X(rs2) & (XLEN - 1);
X(rd) = X(rs1) | (1 << index)
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbs (<<#zbs>>)
|0.93
|Frozen
|===

描述::
此指令返回在_shamt_指定的索引处设置单个位的_rs1_。
索引从_shamt_的低log2(XLEN)位读取。
对于RV32，对应于shamt[5]=1的编码是保留的。

操作::
[source,sail]
--
let index = shamt & (XLEN - 1);
X(rd) = X(rs1) | (1 << index)
--

包含于::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbs (<<#zbs>>)
|0.93
|Frozen
|===

<<<
[#insns-clmul,reftext="无进位乘法（低位部分）"]
==== clmul

简述::
无进位乘法（低位部分）

助记符::
clmul _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CLMUL'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x5, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
clmul生成2·XLEN无进位乘积的低半部分。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);
let output : xlenbits = 0;

foreach (i from 0 to (xlen - 1) by 1) {
   output = if   ((rs2_val >> i) & 1)
            then output ^ (rs1_val << i);
            else output;
}

X[rd] = output
--

包含于::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbc (<<#zbc>>)
|0.93
|Frozen

|Zbkc (<<#zbkc>>)
|v0.9.4
|Frozen
|===

<<<
[#insns-clmulh,reftext="无进位乘法（高位部分）"]
==== clmulh

简述::
无进位乘法（高位部分）

助记符::
clmulh _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x3, attr: ['CLMULH'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x5, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
clmulh生成2·XLEN无进位乘积的高半部分。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);
let output : xlenbits = 0;

foreach (i from 1 to xlen by 1) {
   output = if   ((rs2_val >> i) & 1)
            then output ^ (rs1_val >> (xlen - i));
            else output;
}

X[rd] = output
--

包含于::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbc (<<#zbc>>)
|0.93
|Frozen

|Zbkc (<<#zbkc>>)
|v0.9.4
|Frozen
|===


<<<
[#insns-clmulr,reftext="无进位乘法（反向）"]
==== clmulr

简述::
无进位乘法（反向）

助记符::
clmulr _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x2, attr: ['CLMULR'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x5, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
*clmulr*生成2·XLEN无进位乘积的2·XLEN−2:XLEN-1位。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);
let output : xlenbits = 0;

foreach (i from 0 to (xlen - 1) by 1) {
   output = if   ((rs2_val >> i) & 1)
            then output ^ (rs1_val >> (xlen - i - 1));
            else output;
}

X[rd] = output
--

.Note
[NOTE, caption="A" ]
===============================================================
*clmulr*指令用于加速CRC计算。
指令助记符中的*r*代表_反向_，因为该指令相当于对输入进行位反转，执行*clmul*，然后对输出进行位反转。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbc (<<#zbc>>)
|0.93
|Frozen
|===

<<<
[#insns-clz,reftext="计数前导零位"]
==== clz

简述::
计数前导零位

助记符::
clz _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CLZ']  },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x0, attr: ['CLZ'] },
    { bits:  7, name: 0x30, attr: ['CLZ']  },
]}
....

描述::
此指令计算从最高有效位（即XLEN-1）开始到第一个1之前的0的数量，并进展到位0。因此，如果输入为0，输出为XLEN；如果输入的最高有效位为1，输出为0。

操作::
[source,sail]
--
val HighestSetBit : forall ('N : Int), 'N >= 0. bits('N) -> int

function HighestSetBit x = {
  foreach (i from (xlen - 1) to 0 by 1 in dec)
    if [x[i]] == 0b1 then return(i) else ();
  return -1;
}

let rs = X(rs);
X[rd] = (xlen - 1) - HighestSetBit(rs);
--

包含于::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|0.93
|Frozen
|===

<<<
[#insns-clzw,reftext="计数字中的前导零位"]
==== clzw

简述::
计数字中的前导零位

助记符::
clzw _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x1b, attr: ['OP-IMM-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CLZW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x0, attr: ['CLZW'] },
    { bits:  7, name: 0x30, attr: ['CLZW'] },
]}
....

描述::
此指令计算从位31开始到第一个1之前的0的数量，并进展到位0。
因此，如果最低有效字为0，输出为32；如果字的最高有效位（即位31）为1，输出为0。

操作::
[source,sail]
--
val HighestSetBit32 : forall ('N : Int), 'N >= 0. bits('N) -> int

function HighestSetBit32 x = {
  foreach (i from 31 to 0 by 1 in dec)
    if [x[i]] == 0b1 then return(i) else ();
  return -1;
}

let rs = X(rs);
X[rd] = 31 - HighestSetBit(rs);
--

包含于::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|0.93
|Frozen
|===

<<<
[#insns-cpop,reftext="计数设置位"]
==== cpop

简述::
计数设置位

助记符::
cpop _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CPOP'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x2, attr: ['CPOP'] },
    { bits:  7, name: 0x30, attr: ['CPOP'] },
]}
....
描述::
此指令计算源寄存器中1的数量（即设置位）。

操作::
[source,sail]
--
let bitcount = 0;
let rs = X(rs);

foreach (i from 0 to (xlen - 1) in inc)
    if rs[i] == 0b1 then bitcount = bitcount + 1 else ();

X[rd] = bitcount
--

.Software Hint
[NOTE, caption="SH" ]
===============================================================
此操作被称为人口计数、popcount、横向求和、位求和或汉明重量。

GCC内置函数`+__builtin_popcount (unsigned int x)+`在RV32上由cpop实现，在RV64上由*cpopw*实现。
GCC内置函数`+__builtin_popcountl (unsigned long x)+`用于LP64在RV64上由*cpop*实现。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|0.93
|Frozen
|===

<<<
[#insns-cpopw,reftext="计数字中的设置位"]
==== cpopw

简述::
计数字中的设置位

助记符::
cpopw _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x1b, attr: ['OP-IMM-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CPOPW'] },
    { bits:  5, name: 'rs' },
    { bits:  5, name: 0x2, attr: ['CPOPW'] },
    { bits:  7, name: 0x30, attr: ['CPOPW'] },
]}
....
描述::
此指令计算源寄存器中最低有效字中的1的数量（即设置位）。

操作::
[source,sail]
--
let bitcount = 0;
let val = X(rs);

foreach (i from 0 to 31 in inc)
    if val[i] == 0b1 then bitcount = bitcount + 1 else ();

X[rd] = bitcount
--

包含于::
[%header,cols="4,2,2"]
|===
|Extension
|Minimum version
|Lifecycle state

|Zbb (<<#zbb>>)
|0.93
|Frozen
|===

<<<
[#insns-ctz,reftext="计数尾随零位"]
==== ctz

简述::
计数尾随零位

助记符::
ctz _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CTZ/CTZW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x1, attr: ['CTZ/CTZW'] },
    { bits:  7, name: 0x30, attr: ['CTZ/CTZW'] },
]}
....

描述::
此指令计算从最低有效位（即0）开始到第一个1之前的0的数量，并进展到最高有效位（即XLEN-1）。
因此，如果输入为0，输出为XLEN；如果输入的最低有效位为1，输出为0。

操作::
[source,sail]
--
val LowestSetBit : forall ('N : Int), 'N >= 0. bits('N) -> int

function LowestSetBit x = {
  foreach (i from 0 to (xlen - 1) by 1 in dec)
    if [x[i]] == 0b1 then return(i) else ();
  return xlen;
}

let rs = X(rs);
X[rd] = LowestSetBit(rs);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-ctzw,reftext="计数字中的尾随零位"]
==== ctzw

简述::
计数字中的尾随零位

助记符::
ctzw _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x1b, attr: ['OP-IMM-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['CTZ/CTZW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x1, attr: ['CTZ/CTZW'] },
    { bits:  7, name: 0x30, attr: ['CTZ/CTZW'] },
]}
....

描述::
此指令计算从最低有效位（即0）开始到第一个1之前的0的数量，并进展到最低有效字的最高有效位（即31）。因此，如果最低有效字为0，输出为32；如果输入的最低有效位为1，输出为0。

操作::
[source,sail]
--
val LowestSetBit32 : forall ('N : Int), 'N >= 0. bits('N) -> int

function LowestSetBit32 x = {
  foreach (i from 0 to 31 by 1 in dec)
    if [x[i]] == 0b1 then return(i) else ();
  return 32;
}

let rs = X(rs);
X[rd] = LowestSetBit32(rs);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-max,reftext="最大值"]
==== max

简述::
最大值

助记符::
max _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x6, attr: ['MAX']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x05, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
此指令返回两个有符号整数中较大的一个。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);

let result = if   rs1_val <_s rs2_val
             then rs2_val
             else rs1_val;

X(rd) = result;
--

.Software Hint
[NOTE, caption="SW"]
===============================================================
计算有符号整数的绝对值可以通过以下序列进行：*neg rD,rS*，然后是*max rD,rS,rD*。在使用此常见序列时，建议它们在没有中间指令的情况下进行调度，以便经过优化的实现可以将它们融合在一起。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-maxu,reftext="无符号最大值"]
==== maxu

简述::
无符号最大值

助记符::
maxu _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x7, attr: ['MAXU']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x05, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
此指令返回两个无符号整数中较大的一个。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);

let result = if   rs1_val <_u rs2_val
             then rs2_val
             else rs1_val;

X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-min,reftext="最小值"]
==== min

简述::
最小值

助记符::
min _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['MIN']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x05, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
此指令返回两个有符号整数中较小的一个。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);

let result = if   rs1_val <_s rs2_val
             then rs1_val
             else rs2_val;

X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-minu,reftext="无符号最小值"]
==== minu

简述::
无符号最小值

助记符::
minu _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['MINU']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x05, attr: ['MINMAX/CLMUL'] },
]}
....

描述::
此指令返回两个无符号整数中较小的一个。

操作::
[source,sail]
--
let rs1_val = X(rs1);
let rs2_val = X(rs2);

let result = if   rs1_val <_u rs2_val
             then rs1_val
             else rs2_val;

X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-orc_b,reftext="按字节进行按位或组合"]
==== orc.b

简述::
按字节进行按位或组合

助记符::
orc.b _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5 },
    { bits:  5, name: 'rs' },
    { bits: 12, name: 0x287 }
]}
....

描述::
使用按位逻辑或组合每个字节内的位。
如果_rs_的相应字节内没有设置任何位，则将结果_rd_的每个字节的位设置为全零；如果_rs_的相应字节内设置了任何位，则将结果_rd_的每个字节的位设置为全一。

操作::
[source,sail]
--
let input = X(rs);
let output : xlenbits = 0;

foreach (i from 0 to (xlen - 8) by 8) {
   output[(i + 7)..i] = if   input[(i + 7)..i] == 0
                        then 0b00000000
                        else 0b11111111;
}

X[rd] = output;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-orn,reftext="与反操作数进行或"]
==== orn

简述::
与反操作数进行或

助记符::
orn _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x6, attr: ['ORN']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x20, attr: ['ORN'] },
]}
....

描述::
此指令对_rs1_和_rs2_的按位反进行按位逻辑或操作。

操作::
[source,sail]
--
X(rd) = X(rs1) | ~X(rs2);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-pack,reftext="打包寄存器的低半部分"]
==== pack

简述::
将_rs1_和_rs2_的低半部分打包到_rd_中。

助记符::
pack _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    {bits:  7, name: 0x33, attr: ['OP'] },
    {bits: 5, name: 'rd'},
    {bits: 3, name: 0x4, attr:['PACK']},
    {bits: 5, name: 'rs1'},
    {bits: 5, name: 'rs2'},
    {bits: 7, name: 0x4, attr:['PACK']},
]}
....

描述::
pack指令将_rs1_和_rs2_的XLEN/2位低半部分打包到_rd_中，_rs1_在低半部分，_rs2_在高半部分。

操作::
[source,sail]
--
let lo_half : bits(xlen/2) = X(rs1)[xlen/2-1..0];
let hi_half : bits(xlen/2) = X(rs2)[xlen/2-1..0];
X(rd) = EXTZ(hi_half @ lo_half);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-packh,reftext="打包寄存器的低字节"]
==== packh

简述::
将_rs1_和_rs2_的低字节打包到_rd_中。

助记符::
packh _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    {bits:  7, name: 0x33, attr: ['OP'] },
    {bits: 5, name: 'rd'},
    {bits: 3, name: 0x7, attr: ['PACKH']},
    {bits: 5, name: 'rs1'},
    {bits: 5, name: 'rs2'},
    {bits: 7, name: 0x4, attr: ['PACKH']},
]}
....

描述::
packh指令将_rs1_和_rs2_的最低有效字节打包到_rd_的16个最低有效位中，零扩展_rd_的其余部分。

操作::
[source,sail]
--
let lo_half : bits(8) = X(rs1)[7..0];
let hi_half : bits(8) = X(rs2)[7..0];
X(rd) = EXTZ(hi_half @ lo_half);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-packw,reftext="打包寄存器的低16位（RV64）"]
==== packw

简述::
在RV64上将_rs1_和_rs2_的低16位打包到_rd_中。

助记符::
packw _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
{bits: 2, name: 0x3},
{bits: 5, name: 0xe},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x4},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 7, name: 0x4},
]}
....

描述::
此指令将_rs1_和_rs2_的低16位打包到_rd_的32个最低有效位中，将32位结果符号扩展到_rd_的其余部分。
此指令仅存在于基于RV64的系统上。

操作::
[source,sail]
--
let lo_half : bits(16) = X(rs1)[15..0];
let hi_half : bits(16) = X(rs2)[15..0];
X(rd) = EXTS(hi_half @ lo_half);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-rev8,reftext="字节反转寄存器"]
==== rev8

简述::
字节反转寄存器

助记符::
rev8 _rd_, _rs_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5 },
    { bits:  5, name: 'rs' },
    { bits: 12, name: 0x698 }
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5 },
    { bits:  5, name: 'rs' },
    { bits: 12, name: 0x6b8 }
]}
....

描述::
此指令反转_rs_中的字节顺序。

操作::
[source,sail]
--
let input = X(rs);
let output : xlenbits = 0;
let j = xlen - 1;

foreach (i from 0 to (xlen - 8) by 8) {
   output[i..(i + 7)] = input[(j - 7)..j];
   j = j - 8;
}

X[rd] = output
--

.Note
[NOTE, caption="A" ]
===============================================================
*rev8* 助记符在RV32和RV64中对应不同的指令编码。
===============================================================

.Software Hint
[NOTE, caption="SH" ]
===============================================================
字节反转操作仅适用于整个寄存器宽度。要模拟字大小和半字大小的字节反转，执行`rev8 rd,rs`，然后执行`srai rd,rd,K`，其中K分别为XLEN-32和XLEN-16。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-revb,reftext="反转字节中的位"]
==== rev.b

简述::
反转源寄存器中每个字节的位。

助记符::
rev.b _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5 },
    { bits:  5, name: 'rs' },
    { bits: 12, name: 0x687 }
]}
....

描述::
此指令反转寄存器中每个字节的位顺序。

操作::
[source,sail]
--
result : xlenbits = EXTZ(0b0);
foreach (i from 0 to sizeof(xlen) by 8) {
    result[i+7..i] = reverse_bits_in_byte(X(rs1)[i+7..i]);
};
X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-rol,reftext="左旋转（寄存器）"]
==== rol

简述::
左旋转（寄存器）

助记符::
rol _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['ROL']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x30, attr: ['ROL'] },
]}
....

描述::
此指令将_rs1_左旋转由_rs2_的最低log2(XLEN)位指定的数量。

操作::
[source,sail]
--
let shamt = if   xlen == 32
            then X(rs2)[4..0]
            else X(rs2)[5..0];
let result = (X(rs1) << shamt) | (X(rs1) >> (xlen - shamt));

X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-rolw,reftext="左旋转字（寄存器）"]
==== rolw

简述::
左旋转字（寄存器）

助记符::
rolw _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['ROLW']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x30, attr: ['ROLW'] },
]}
....

描述::
此指令将_rs1_的最低有效字左旋转由_rs2_的最低5位指定的数量。结果字值通过将第31位复制到所有更高位来进行符号扩展。

操作::
[source,sail]
--
let rs1 = EXTZ(X(rs1)[31..0])
let shamt = X(rs2)[4..0];
let result = (rs1 << shamt) | (rs1 >> (32 - shamt));
X(rd) = EXTS(result[31..0]);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-ror,reftext="右旋转（寄存器）"]
==== ror

简述::
右旋转

助记符::
ror _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['ROR']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x30, attr: ['ROR'] },
]}
....

描述::
此指令将_rs1_右旋转由_rs2_的最低log2(XLEN)位指定的数量。

操作::
[source,sail]
--
let shamt = if   xlen == 32
            then X(rs2)[4..0]
            else X(rs2)[5..0];
let result = (X(rs1) >> shamt) | (X(rs1) << (xlen - shamt));

X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-rori,reftext="右旋转（立即数）"]
==== rori

简述::
右旋转（立即数）

助记符::
rori _rd_, _rs1_, _shamt_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['RORI']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x30, attr: ['RORI'] },
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['RORI']},
    { bits:  5, name: 'rs1' },
    { bits:  6, name: 'shamt' },
    { bits:  6, name: 0x18, attr: ['RORI'] },
]}
....

描述::
此指令将_rs1_右旋转由_shamt_的最低log2(XLEN)位指定的数量。对于RV32，对应于shamt[5]=1的编码是保留的。

操作::
[source,sail]
--
let shamt = if   xlen == 32
            then shamt[4..0]
            else shamt[5..0];
let result = (X(rs1) >> shamt) | (X(rs1) << (xlen - shamt));

X(rd) = result;
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-roriw,reftext="右旋转字（立即数）"]
==== roriw

简述::
右旋转字（立即数）

助记符::
roriw _rd_, _rs1_, _shamt_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x1b, attr: ['OP-IMM-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['RORIW']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'shamt' },
    { bits:  7, name: 0x30, attr: ['RORIW'] },
]}
....

描述::
此指令将_rs1_的最低有效字右旋转由_shamt_的最低log2(XLEN)位指定的数量。结果字值通过将第31位复制到所有更高位来进行符号扩展。

操作::
[source,sail]
--
let rs1_data = EXTZ(X(rs1)[31..0];
let result = (rs1_data >> shamt) | (rs1_data << (32 - shamt));
X(rd) = EXTS(result[31..0]);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-rorw,reftext="右旋转字（寄存器）"]
==== rorw

简述::
右旋转字（寄存器）

助记符::
rorw _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x5, attr: ['RORW']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x30, attr: ['RORW'] },
]}
....

描述::
此指令将_rs1_的最低有效字右旋转由_rs2_的最低5位指定的数量。结果字通过将第31位复制到所有更高位来进行符号扩展。

操作::
[source,sail]
--
let rs1 = EXTZ(X(rs1)[31..0])
let shamt = X(rs2)[4..0];
let result = (rs1 >> shamt) | (rs1 << (32 - shamt));
X(rd) = EXTS(result);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-sext_b,reftext="符号扩展字节"]
==== sext.b

简述::
符号扩展字节

助记符::
sext.b _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['SEXT.B/SEXT.H'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x04, attr: ['SEXT.B'] },
    { bits:  7, name: 0x30 },
]}
....

描述::
此指令通过将字节中的最高有效位（即第7位）复制到所有更高位来将源中的最低有效字节符号扩展到XLEN。

操作::
[source,sail]
--
X(rd) = EXTS(X(rs)[7..0]);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-sext_h,reftext="符号扩展半字"]
==== sext.h

简述::
符号扩展半字

助记符::
sext.h _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x13, attr: ['OP-IMM'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['SEXT.B/SEXT.H'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 0x05, attr: ['SEXT.H'] },
    { bits:  7, name: 0x30 },
]}
....

描述::
此指令将_rs_中最低有效的半字符号扩展到XLEN，通过将半字中的最高有效位（即第15位）复制到所有更高位。

操作::
[source,sail]
--
X(rd) = EXTS(X(rs)[15..0]);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===


<<<
[#insns-sh1add,reftext=左移1位并加]
==== sh1add

简述::
左移1位并加

助记符::
sh1add _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x2, attr: ['SH1ADD'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x10, attr: ['SH1ADD'] },
]}
....

描述::
此指令将_rs1_左移1位并加到_rs2_。

操作::
[source,sail]
--
X(rd) = X(rs2) + (X(rs1) << 1);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

// 我们已经决定此指令和所有其他指令不会为“无用编码”保留编码
// 如果有某种公认的价值，我们可以效仿基本ISA并创建HINTs

<<<
[#insns-sh1add_uw,reftext=左移1位并加无符号字]
==== sh1add.uw

简述::
左移1位并加无符号字

助记符::
sh1add.uw _rd_, _rs1_, _rs2_
编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x2, attr: ['SH1ADD.UW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x10, attr: ['SH1ADD.UW']  },
]}
....

描述::
此指令执行两个加数的XLEN宽度加法。
第一个加数是_rs2_。第二个加数是从_rs1_中提取的最低有效字并左移1位形成的无符号值。

操作::
[source,sail]
--
let base = X(rs2);
let index = EXTZ(X(rs1)[31..0]);

X(rd) = base + (index << 1);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

<<<
[#insns-sh2add,reftext=左移2位并加]
==== sh2add

简述::
左移2位并加

助记符::
sh2add _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['SH2ADD'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x10, attr: ['SH2ADD'] },
]}
....

描述::
此指令将_rs1_左移2位并加到_rs2_。

操作::
[source,sail]
--
X(rd) = X(rs2) + (X(rs1) << 2);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

<<<
[#insns-sh2add_uw,reftext=左移2位并加无符号字]
==== sh2add.uw

简述::
左移2位并加无符号字

助记符::
sh2add.uw _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['SH2ADD.UW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x10, attr: ['SH2ADD.UW'] },
]}
....

描述::
此指令执行两个加数的XLEN宽度加法。
第一个加数是_rs2_。
第二个加数是从_rs1_中提取的最低有效字并左移2位形成的无符号值。

操作::
[source,sail]
--
let base = X(rs2);
let index = EXTZ(X(rs1)[31..0]);

X(rd) = base + (index << 2);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

<<<
[#insns-sh3add,reftext=左移3位并加]
==== sh3add

简述::
左移3位并加

助记符::
sh3add _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x6, attr: ['SH3ADD'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x10, attr: ['SH3ADD'] },
]}
....

描述::
此指令将_rs1_左移3位并加到_rs2_。

操作::
[source,sail]
--
X(rd) = X(rs2) + (X(rs1) << 3);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

<<<
[#insns-sh3add_uw,reftext=左移3位并加无符号字]
==== sh3add.uw

简述::
左移3位并加无符号字

助记符::
sh3add.uw _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x6, attr: ['SH3ADD.UW'] },
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x10, attr: ['SH3ADD.UW'] },
]}
....

描述::
此指令执行两个加数的XLEN宽度加法。第一个加数是_rs2_。第二个加数是从_rs1_中提取的最低有效字并左移3位形成的无符号值。

操作::
[source,sail]
--
let base = X(rs2);
let index = EXTZ(X(rs1)[31..0]);

X(rd) = base + (index << 3);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

<<<
[#insns-slli_uw,reftext="左移无符号字（立即数）"]
==== slli.uw

简述::
左移无符号字（立即数）

助记符::
slli.uw _rd_, _rs1_, _shamt_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x1b, attr: ['OP-IMM-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x1, attr: ['SLLI.UW'] },
    { bits:  5, name: 'rs1' },
    { bits:  6, name: 'shamt' },
    { bits:  6, name: 0x02, attr: ['SLLI.UW'] },
]}
....

描述::
此指令获取_rs1_的最低有效字，零扩展它，并左移立即数位。

操作::
[source,sail]
--
X(rd) = (EXTZ(X(rs)[31..0]) << shamt);
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zba (<<#zba>>)
|0.93
|冻结
|===

.Architecture Explanation
[NOTE, caption="A" ]
===============================================================
此指令与*slli*相同，在左移之前对_rs1_执行*zext.w*。
===============================================================

<<<
[#insns-unzip,reftext="位反交错"]
==== unzip

简述::
实现zip指令的逆操作。

助记符::
unzip _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13, attr: ['OP-IMM']},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x5},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x1f},
{bits: 7, name: 0x4},
]}
....

描述::
此指令将源字的高低两半中的位收集到目标字的奇偶位位置。
它是<<insns-zip,zip>>指令的逆操作。
此指令仅在RV32上可用。

操作::
[source,sail]
--
foreach (i from 0 to xlen/2-1) {
  X(rd)[i] = X(rs1)[2*i]
  X(rd)[i+xlen/2] = X(rs1)[2*i+1]
}
--

.Software Hint
[NOTE, caption="SH" ]
===============================================================
此指令对于在32位架构上实现SHA3加密哈希函数非常有用，因为它实现了用于加速64位旋转的位交错操作。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkb (<<#zbkb>>) (RV32)
|v0.9.4
|冻结
|===

<<<
[#insns-xnor,reftext="异或非"]
==== xnor

简述::
异或非

助记符::
xnor _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['XNOR']},
    { bits:  5, name: 'rs1' },
    { bits:  5, name: 'rs2' },
    { bits:  7, name: 0x20, attr: ['XNOR'] },
]}
....

描述::
此指令对_rs1_和_rs2_执行按位异或非操作。

操作::
[source,sail]
--
X(rd) = ~(X(rs1) ^ X(rs2));
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结

|Zbkb (<<#zbkb>>)
|v0.9.4
|冻结
|===

<<<
[#insns-xpermb,reftext="交叉开关置换（字节）"]
==== xperm.b

简述::
在寄存器中按字节查找索引到向量。

助记符::
xperm.b _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
{bits: 2, name: 0x3},
{bits: 5, name: 0xc},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x4},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 7, name: 0x14},
]}
....

描述::
xperm.b 指令对字节进行操作。
_rs1_ 寄存器包含一个 XLEN/8 的 8 位元素向量。
_rs2_ 寄存器包含一个 XLEN/8 的 8 位索引向量。
结果是 _rs2_ 中的每个元素被 _rs1_ 中的索引元素替换，
如果索引超出 _rs2_ 的范围，则为零。

操作::
[source,sail]
--
val xpermb_lookup : (bits(8), xlenbits) -> bits(8)
function xpermb_lookup (idx, lut) = {
    (lut >> (idx @ 0b000))[7..0]
}

function clause execute ( XPERM_B (rs2,rs1,rd)) = {
    result : xlenbits = EXTZ(0b0);
    foreach(i from 0 to xlen by 8) {
        result[i+7..i] = xpermn_lookup(X(rs2)[i+7..i], X(rs1));
    };
    X(rd) = result;
    RETIRE_SUCCESS
}
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkx (<<#zbkx>>)
|v0.9.4
|冻结
|===

<<<
[#insns-xpermn,reftext="交叉开关置换（半字节）"]
==== xperm.n

简述::
在向量中按半字节查找索引。

助记符::
xperm.n _rd_, _rs1_, _rs2_

编码::
[wavedrom, , svg]
....
{reg:[
{bits: 2, name: 0x3},
{bits: 5, name: 0xc},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x2},
{bits: 5, name: 'rs1'},
{bits: 5, name: 'rs2'},
{bits: 7, name: 0x14},
]}
....

描述::
xperm.n 指令对半字节进行操作。
_rs1_ 寄存器包含一个 XLEN/4 的 4 位元素向量。
_rs2_ 寄存器包含一个 XLEN/4 的 4 位索引向量。
结果是 _rs2_ 中的每个元素被 _rs1_ 中的索引元素替换，
如果索引超出 _rs2_ 的范围，则为零。

操作::
[source,sail]
--
val xpermn_lookup : (bits(4), xlenbits) -> bits(4)
function xpermn_lookup (idx, lut) = {
    (lut >> (idx @ 0b00))[3..0]
}

function clause execute ( XPERM_N (rs2,rs1,rd)) = {
    result : xlenbits = EXTZ(0b0);
    foreach(i from 0 to xlen by 4) {
        result[i+3..i] = xpermn_lookup(X(rs2)[i+3..i], X(rs1));
    };
    X(rd) = result;
    RETIRE_SUCCESS
}
--

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkx (<<#zbkx>>)
|v0.9.4
|冻结
|===

<<<
[#insns-zext_h,reftext="零扩展半字"]
==== zext.h

简述::
零扩展半字

助记符::
zext.h _rd_, _rs_

编码 (RV32)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x33, attr: ['OP'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['ZEXT.H']},
    { bits:  5, name: 'rs' },
    { bits:  5, name: 0x00 },
    { bits:  7, name: 0x04 },
]}
....

编码 (RV64)::
[wavedrom, , svg]
....
{reg:[
    { bits:  7, name: 0x3b, attr: ['OP-32'] },
    { bits:  5, name: 'rd' },
    { bits:  3, name: 0x4, attr: ['ZEXT.H']},
    { bits:  5, name: 'rs' },
    { bits:  5, name: 0x00 },
    { bits:  7, name: 0x04 },
]}
....

描述::
此指令将源的最低有效半字零扩展到 XLEN，通过在所有高于 15 位的位置插入 0。

操作::
[source,sail]
--
X(rd) = EXTZ(X(rs)[15..0]);
--

.Note
[NOTE, caption="A" ]
===============================================================
*zext.h* 助记符在 RV32 和 RV64 中对应不同的指令编码。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbb (<<#zbb>>)
|0.93
|冻结
|===

<<<
[#insns-zip,reftext="位交错"]
==== zip

简述::
将源字的奇偶位收集到目标的上半部分和下半部分。

助记符::
zip _rd_, _rs_

编码::
[wavedrom, , svg]
....
{reg:[
{bits: 7, name: 0x13, attr: ['OP-IMM']},
{bits: 5, name: 'rd'},
{bits: 3, name: 0x1},
{bits: 5, name: 'rs1'},
{bits: 5, name: 0x1e},
{bits: 7, name: 0x4},
]}
....

描述::
此指令将源字的所有奇偶位分散到目标字的高低半部分。
它是 <<insns-unzip,unzip>> 指令的逆操作。
此指令仅在 RV32 上可用。

操作::
[source,sail]
--
foreach (i from 0 to xlen/2-1) {
  X(rd)[2*i] = X(rs1)[i]
  X(rd)[2*i+1] = X(rs1)[i+xlen/2]
}
--

.Software Hint
[NOTE, caption="SH" ]
===============================================================
此指令对于在 32 位架构上实现 SHA3 加密哈希函数非常有用，因为它实现了用于加速 64 位旋转的位交错操作。
===============================================================

包含于::
[%header,cols="4,2,2"]
|===
|扩展
|最低版本
|生命周期状态

|Zbkb (<<#zbkb>>) (RV32)
|v0.9.4
|冻结
|===


=== 软件优化指南

==== strlen

*orc.b* 指令允许在 XLEN 大小的数据块中高效检测 *NUL* 字节：

 * 在不包含任何 *NUL* 字节的数据块上执行 *orc.b* 的结果将是全 1，
 * 在对 *orc.b* 的结果进行按位取反后，可以通过 *ctz*/*clz*（取决于数据的字节序）检测到第一个 *NUL* 字节之前的数据字节数（如果有）。

下面是一个完整的 *strlen* 函数示例，它使用了这些技术，并演示了它在未对齐/部分数据上的使用：

[source,asm]
--
#include <sys/asm.h>

    .text
    .globl strlen
    .type  strlen, @function
strlen:
    andi	a3, a0, (SZREG-1)   // 偏移量
    andi    a1, a0, -SZREG      // 对齐指针
.Lprologue:
    li      a4, SZREG
    sub     a4, a4, a3          // XLEN - 偏移量
    slli	a3, a3, 3           // 偏移量 * 8
    REG_L   a2, 0(a1)           // 数据块
    /*
     * 移动加载的部分/未对齐的数据块以移除字符串开始之前的字节，并在末尾添加 NUL 字节。
     */
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    srl	a2, a2 ,a3          // 数据块 >> (偏移量 * 8)
#else
    sll     a2, a2, a3
#endif
    orc.b   a2, a2
    not	a2, a2
    /*
     * 字符串中的非 NUL 字节已扩展为 0x00，而 NUL 字节已变为 0xff。搜索第一个设置的位
     * （对应于原始数据块中的 NUL 字节）。
     */
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    ctz     a2, a2
#else
    clz     a2, a2
#endif
    /*
     * 第一个数据块是特殊的：与此数据块中的有效字节数进行比较。
     */
    srli    a0, a2, 3
    bgtu    a4, a0, .Ldone
    addi    a3, a1, SZREG
    li      a4, -1
    .align 2
    /*
     * 我们的关键循环是 4 条指令，并以 4 字节或 8 字节的数据块处理数据。
     */
.Lloop:
    REG_L   a2, SZREG(a1)
    addi    a1, a1, SZREG
    orc.b   a2, a2
    beq     a2, a4, .Lloop

.Lepilogue:
    not     a2, a2
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
    ctz     a2, a2
#else
    clz     a2, a2
#endif
    sub     a1, a1, a3
    add	a0, a0, a1
    srli    a2, a2, 3
    add 	a0, a0, a2
.Ldone:
    ret
--

==== strcmp

[source,asm]
--
#include <sys/asm.h>

  .text
  .globl strcmp
  .type  strcmp, @function
strcmp:
  or    a4, a0, a1
  li    t2, -1
  and   a4, a4, SZREG-1
  bnez  a4, .Lsimpleloop

  # 对齐字符串的主循环
.Lloop:
  REG_L a2, 0(a0)
  REG_L a3, 0(a1)
  orc.b t0, a2
  bne   t0, t2, .Lfoundnull
  addi  a0, a0, SZREG
  addi  a1, a1, SZREG
  beq   a2, a3, .Lloop

  # 字不匹配，且第一个字中没有空字节。
  # 获取大端字节顺序的字节并进行比较。
#if __BYTE_ORDER__ == __ORDER_LITTLE_ENDIAN__
  rev8  a2, a2
  rev8  a3, a3
#endif
  # 在无分支序列中合成 (a2 >= a3) ? 1 : -1。
  sltu a0, a2, a3
  neg  a0, a0
  ori  a0, a0, 1
  ret

.Lfoundnull:
  # 找到一个空字节。
  # 如果字不匹配，则回退到简单循环。
  bne   a2, a3, .Lsimpleloop

  # 否则，字符串相等。
  li    a0, 0
  ret

  # 未对齐字符串的简单循环
.Lsimpleloop:
  lbu   a2, 0(a0)
  lbu   a3, 0(a1)
  addi  a0, a0, 1
  addi  a1, a1, 1
  bne   a2, a3, 1f
  bnez  a2, .Lsimpleloop

1:
  sub   a0, a2, a3
  ret

.size   strcmp, .-strcmp
--
