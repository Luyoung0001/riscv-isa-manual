[[chap:zihintntl]]
== "Zihintntl" 非时间局部性提示扩展，版本 1.0

NTL 指令是提示指令，表示紧接着的指令（以下简称“目标指令”）的显式内存访问表现出较差的时间局部性。NTL 指令不会改变架构状态，也不会改变目标指令的架构可见效果。提供了四种变体：

NTL.P1 指令表示目标指令在内存层次结构中最内层的私有缓存容量内不表现出时间局部性。NTL.P1 编码为 ADD _x0, x0, x2_。

NTL.PALL 指令表示目标指令在内存层次结构中的任何级别的私有缓存容量内不表现出时间局部性。NTL.PALL 编码为 ADD _x0, x0, x3_。

NTL.S1 指令表示目标指令在内存层次结构中最内层的共享缓存容量内不表现出时间局部性。NTL.S1 编码为 ADD _x0, x0, x4_。

NTL.ALL 指令表示目标指令在内存层次结构中的任何级别的缓存容量内不表现出时间局部性。NTL.ALL 编码为 ADD _x0, x0, x5_。

[NOTE]
====
NTL 指令可用于在流数据或遍历大型数据结构时避免缓存污染，或在生产者-消费者交互中减少延迟。

微架构可能使用 NTL 指令来通知缓存替换策略，或决定分配到哪个缓存，或完全避免缓存分配。例如，NTL.P1 可能表示实现不应在私有 L1 缓存中分配行，但应在 L2（无论是私有还是共享）中分配。在另一种实现中，NTL.P1 可能在 L1 中分配行，但处于最近最少使用状态。

NTL.ALL 通常会通知实现不要在缓存层次结构中的任何地方分配。程序员应使用 NTL.ALL 进行没有可利用时间局部性的访问。

像任何提示指令一样，这些指令可以被自由忽略。因此，尽管它们是以基于缓存的内存层次结构来描述的，但它们并不强制提供缓存。

某些实现可能会对某些内存访问尊重这些提示，但对其他内存访问则不然：例如，实现通过在 L1 中获取缓存行的独占状态来实现 LR/SC 可能会忽略 LR 和 SC 上的 NTL 指令，但可能会尊重 AMO 和常规加载和存储的 NTL 指令。
====

<<ntl-portable>> 列出了几个软件使用案例以及便携软件（即未针对任何特定实现的内存层次结构进行调优的软件）在每种情况下应使用的推荐 NTL 变体。

[[ntl-portable]]
.便携软件在各种场景中使用的推荐 NTL 变体。
[%autowidth,float="center",align="center",cols="<,<",options="header",]
|===
|场景 |推荐的 NTL 变体
|访问工作集大小在 和 之间 |NTL.P1
|访问工作集大小在 和 之间 |NTL.PALL
|访问工作集大小大于 |NTL.S1
|没有可利用时间局部性的访问（例如，流式传输） |NTL.ALL
|访问争用的同步变量 |NTL.PALL
|===

[NOTE]
====
<<ntl-portable>> 中列出的工作集大小并不是为了限制实现者的缓存大小决策。
缓存大小显然会因实现而异，因此软件编写者应仅将这些工作集大小视为粗略指南。
====

<<ntl>> 列出了几个示例内存层次结构，并推荐了每个 NTL 变体如何映射到每个缓存级别。该表还推荐了实现调优软件应使用的 NTL 变体，以避免在特定缓存级别进行分配。例如，对于具有私有 L1 和共享 L2 的系统，建议 NTL.P1 和 NTL.PALL 表示时间局部性不能被 L1 利用，而 NTL.S1 和 NTL.ALL 表示时间局部性不能被 L2 利用。此外，针对这种系统进行调优的软件应使用 NTL.P1 表示 L1 无法利用的时间局部性，或使用 NTL.ALL 表示 L2 无法利用的时间局部性。

如果提供了 C 扩展，则还提供了这些提示的压缩变体：C.NTL.P1 编码为 C.ADD _x0, x2_；C.NTL.PALL 编码为 C.ADD _x0, x3_；C.NTL.S1 编码为 C.ADD _x0, x4_；C.NTL.ALL 编码为 C.ADD _x0, x5_。

NTL 指令影响所有内存访问指令，除了 Zicbom 扩展中的缓存管理指令。

[NOTE]
====
截至本文撰写时，没有其他例外情况，因此 NTL 指令影响基本 ISA 和 A、F、D、Q、C 和 V 标准扩展中定义的所有内存访问指令，以及卷 II 中的管理程序扩展中定义的那些指令。

NTL 指令可以影响 Zicbom 扩展之外的缓存管理操作。例如，NTL.PALL 后跟 CBO.ZERO 可能表示该行应在 L3 中分配并清零，但不应在 L1 或 L2 中分配。
====

<<<

[[ntl]]
[%autowidth,float="center",align="center",cols="<,^,^,^,^,^,^,^,^",options="header"]
.NTL 变体到各种内存层次结构的映射。
|===
| 内存层次结构 4+| NTL 变体到实际缓存级别的推荐映射 4+| 显式缓存管理的推荐 NTL 变体
|
|P1 |PALL |S1 |ALL
|L1 |L2 |L3 |L4/L5
 9+^| 常见场景
| 无缓存 4+|--- 4+|无
|仅私有 L1 |L1 |L1 |L1 |L1| ALL |--- |--- |---
|私有 L1；共享 L2 |L1  |L1  |L2  |L2 |P1|ALL|---|---
|私有 L1；共享 L2/L3 |L1 | L1 | L2 | L3 |P1  |S1   |ALL |---
|私有 L1/L2 |L1  |L2  |L2  |L2 | P1  |ALL  |--- |---
|私有 L1/L2；共享 L3 |L1 | L2 | L3 | L3 | P1 | PALL| ALL |---
|私有 L1/L2；共享 L3/L4 | L1 | L2|  L3 | L4 | P1 | PALL | S1 | ALL
 9+^| 不常见场景
|私有 L1/L2/L3；共享 L4 | L1 | L3 |L4 |L4 |P1 |P1 |PALL |ALL
|私有 L1；共享 L2/L3/L4 |L1 | L1 |L2 |L4 |P1 |S1 |ALL |ALL
|私有 L1/L2；共享 L3/L4/L5  |L1 | L2 | L3 | L5 |P1 | PALL |S1 |ALL
|私有 L1/L2/L3；共享 L4/L5  |L1 |L3 |L4 |L5 |P1 |P1 |PALL |ALL
|===

当 NTL 指令应用于 Zicbop 扩展中的预取提示时，它表示应将缓存行预取到由 NTL 指定级别的外部缓存中。

[NOTE]
====
例如，在具有私有 L1 和共享 L2 的系统中，NTL.P1 后跟 PREFETCH.R 可能会预取到 L2 中，具有读取意图。

要预取到缓存的最内层，不要在预取指令前加 NTL 指令。

在某些系统中，NTL.ALL 后跟预取指令可能会预取到内存控制器内部的缓存或预取缓冲区中。
====

不建议软件在 NTL 指令后跟随不显式访问内存的指令。不遵守此建议可能会降低性能，但不会对架构产生可见影响。

如果在目标指令上发生陷阱，建议实现不要将 NTL 应用于陷阱处理程序中的第一条指令。相反，建议在这种情况下忽略提示。

[NOTE]
====
如果在执行 NTL 指令和其目标指令之间发生中断，通常会在目标指令处恢复执行。NTL 指令不重新执行不会改变程序的语义。

某些实现可能更喜欢在看到目标指令之前不处理 NTL 指令（例如，以便 NTL 可以与其修改的内存访问融合）。这种实现可能更倾向于在 NTL 之前而不是在 NTL 和内存访问之间发生中断。
====
'''
[TIP]
====
由于 NTL 指令被编码为 ADD，因此它们可以在 LR/SC 循环中使用，而不会使前进保证失效。但是，由于在 LR/SC 循环中使用其他加载和存储确实会使前进保证失效，因此在此类循环中使用 NTL 的唯一原因是修改 LR 或 SC。
====
