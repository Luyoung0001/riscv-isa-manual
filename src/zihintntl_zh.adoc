[[chap:zihintntl]]
== "Zihintntl" 非时间局部性提示扩展，版本 1.0

NTL 指令是一种提示（HINT），用于表明紧随其后的目标指令的显式内存访问很可能表现出较差的时间局部性。NTL 指令不会改变架构状态，也不会影响目标指令的架构可见效果。提供了四种变体：

NTL.P1 指令用于提示目标指令在内存层次结构中最内层的私有缓存容量范围内缺乏时间局部性。NTL.P1 的编码方式为 ADD _x0, x0, x2_。

NTL.PALL 指令用于提示目标指令在内存层次结构中的任何级别的私有缓存容量范围内缺乏时间局部性。NTL.PALL 编码方式为 ADD _x0, x0, x3_。

NTL.S1 指令用于提示目标指令在内存层次结构中最内层的共享缓存容量内范围内缺乏时间局部性。NTL.S1 编码方式为 ADD _x0, x0, x4_。

NTL.ALL 指令用于提示目标指令在内存层次结构中的任何级别的缓存容量范围内缺乏时间局部性。NTL.ALL 编码方式为 ADD _x0, x0, x5_。

[NOTE]
====
NTL 指令可以用于在进行流数据处理或访问大型数据结构时避免缓存污染，或者在生产者-消费者交互场景中减少延迟。

在微架构层面，可以使用 NTL 指令来指导缓存替换策略，以便决定将数据分配到哪个缓存，或者完全不进行缓存分配。例如，NTL.P1 可以指示处理器实现不应在私有 L1 缓存中分配缓存行，而应在 L2 缓存中分配（无论是私有还是共享）。又例如，在某些实现中，NTL.P1 仍然可以在 L1 缓存中分配缓存行，但会将其设置为最近最少使用状态。

NTL.ALL 通常用于告知处理器实现不要在缓存层次结构的任何级别进行分配。程序员应该在进行没有可利用时间局部性的内存访问时使用 NTL.ALL。

与任何提示指令相同，这些指令都可以被自由地忽略。因此，尽管本文档是以基于缓存的内存层次结构为背景来描述这些指令的，但它们本身并不要求（强制）提供缓存机制。

部分处理器实现可能会选择对某些内存访问应用这些提示，而对另一些则不应用。例如，对于那些通过在 L1 缓存中以独占状态获取缓存行来实现 LR/SC 的实现，它们可能会忽略 LR 和 SC 指令之前的NTL 指令，但对于 AMO 和常规加载/存储指令之前的 NTL 指令，则仍然有可能会选择应用。
====

<<ntl-portable>> 列出了几个软件使用案例以及便携软件（即未针对任何特定实现的内存层次结构进行调优的软件）在每种情况下应使用的推荐 NTL 变体。

[[ntl-portable]]
.便携式软件在各种应用场景下应采用的推荐 NTL 变体
[%autowidth,float="center",align="center",cols="<,<",options="header",]
|===
|场景 |推荐的 NTL 变体
|访问工作集规模在 和 之间 |NTL.P1
|访问工作集规模在 和 之间 |NTL.PALL
|访问工作集规模大于 |NTL.S1
|没有可利用时间局部性的访问（例如，流式传输） |NTL.ALL
|访问争用的同步变量 |NTL.PALL
|===

[NOTE]
====
<<ntl-portable>> 中列出的工作集规模并非旨在限制处理器实现者对缓存容量大小的决策。缓存容量大小显然会因不同的处理器实现而有所差异，因此软件开发者仅应将这些工作集规模视为大致的参考指南。
====

<<ntl>> 列出了若干示例内存层次结构，并给出了每种 NTL 变体到每个缓存级别的推荐映射关系。该表还建议了经过实现调优的软件应使用哪种 NTL 变体，以便避免在指定的缓存级别进行分配。例如，对于采用私有 L1 缓存和共享 L2 缓存的系统，我们建议 NTL.P1 和 NTL.PALL 用于指示 L1 缓存无法有效利用时间局部性，而 NTL.S1 和 NTL.ALL 用于指示 L2 缓存无法有效利用时间局部性。更进一步地，针对此类系统进行调优的软件可以使用 NTL.P1 来指示 L1 缓存无法利用的时间局部性，或者使用 NTL.ALL 来指示 L2 缓存无法利用的时间局部性。

如果提供了 C 扩展，则还提供了这些提示的压缩变体：C.NTL.P1 编码为 C.ADD _x0, x2_；C.NTL.PALL 编码为 C.ADD _x0, x3_；C.NTL.S1 编码为 C.ADD _x0, x4_；C.NTL.ALL 编码为 C.ADD _x0, x5_。

NTL 指令影响所有内存访问指令，除了 Zicbom 扩展中的缓存管理指令。

[NOTE]
====
截至本文撰写时，没有其他例外情况，因此 NTL 指令影响基本 ISA 和 A、F、D、Q、C 和 V 标准扩展中定义的所有内存访问指令，以及卷 II 中的管理程序扩展中定义的那些指令。

NTL 指令可以影响 Zicbom 扩展之外的缓存管理操作。例如，NTL.PALL 后跟 CBO.ZERO 可能表示该行应在 L3 中分配并清零，但不应在 L1 或 L2 中分配。
====

<<<

[[ntl]]
[%autowidth,float="center",align="center",cols="<,^,^,^,^,^,^,^,^",options="header"]
.NTL 变体在不同内存层次结构中的映射关系。
|===
| 内存层次结构 4+| NTL 变体到实际缓存级别的推荐映射关系 4+| 用于显式缓存管理的推荐 NTL 变体
|
|P1 |PALL |S1 |ALL
|L1 |L2 |L3 |L4/L5
 9+^| 常见场景
| 无缓存 4+|--- 4+|无
|仅私有 L1 |L1 |L1 |L1 |L1| ALL |--- |--- |---
|私有 L1；共享 L2 |L1  |L1  |L2  |L2 |P1|ALL|---|---
|私有 L1；共享 L2/L3 |L1 | L1 | L2 | L3 |P1  |S1   |ALL |---
|私有 L1/L2 |L1  |L2  |L2  |L2 | P1  |ALL  |--- |---
|私有 L1/L2；共享 L3 |L1 | L2 | L3 | L3 | P1 | PALL| ALL |---
|私有 L1/L2；共享 L3/L4 | L1 | L2|  L3 | L4 | P1 | PALL | S1 | ALL
 9+^| 不常见场景
|私有 L1/L2/L3；共享 L4 | L1 | L3 |L4 |L4 |P1 |P1 |PALL |ALL
|私有 L1；共享 L2/L3/L4 |L1 | L1 |L2 |L4 |P1 |S1 |ALL |ALL
|私有 L1/L2；共享 L3/L4/L5  |L1 | L2 | L3 | L5 |P1 | PALL |S1 |ALL
|私有 L1/L2/L3；共享 L4/L5  |L1 |L3 |L4 |L5 |P1 |P1 |PALL |ALL
|===

当 NTL 指令被应用于 Zicbop 扩展的预取提示时，它所指示的是，应该将缓存行预取到相对于 NTL 所指定级别更外部的缓存层级中。

[NOTE]
====
例如，在一个具有私有 L1 缓存和共享 L2 缓存的系统中，NTL.P1 后接 PREFETCH.R 指令，则可能会将数据预取到 L2 缓存中，并带有读取意图。

若要将数据预取到缓存的最内层，请不要在预取指令之前添加 NTL 指令。

在另一些系统中，NTL.ALL 后接预取指令，则可能会将数据预取到内存控制器内部的缓存或预取缓冲区之中。
====

我们不建议软件在 NTL 指令之后跟随一条不显式访问内存的指令。如果不遵循此建议，有可能会降低性能，但在架构层面不会产生任何可见影响。

如果在目标指令上发生陷阱事件，我们建议处理器实现不要将 NTL 提示应用于陷阱处理程序的第一条指令。作为替代，我们更建议在这种情况下忽略该提示。

[NOTE]
====
假定在执行 NTL 指令与其目标指令之间发生中断，程序执行通常仍然会在目标指令处恢复。 NTL 指令是否重新执行并不会改变程序的语义。

考虑到某些处理器实现可能倾向于在确认目标指令之后再处理 NTL 指令（例如，为了使 NTL 能够与其修饰的内存访问操作相融合）。因此，这类实现可能更倾向于在 NTL 指令之前响应中断，而不是在 NTL 指令和内存访问操作之间响应中断。
====
'''
[TIP]
====
正因如此， NTL 指令才被编码为 ADD 指令，这样一来，它们就可以在 LR/SC 循环中使用，而不会破坏前进保证。然而，又由于在 LR/SC 循环中使用其他加载和存储 确实会破坏前进保证，故而，在此类循环中使用 NTL 的唯一目的是为了修改 LR 或 SC 指令。
====
