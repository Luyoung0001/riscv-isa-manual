[[chap:zihintntl]]
== “Zihintntl”扩展：非时间局部性提示，版本 1.0

NTL 指令是一种提示（HINT），用于指示紧随其后的目标指令的显式内存访问可能表现出较差的时间局部性。NTL 指令不会更改架构状态，也不会影响目标指令的架构可见效果。提供了四种变体：

`NTL.P1` 指令用于提示目标指令在内存层次结构中最内层的私有缓存范围内缺乏时间局部性。其编码方式为 ADD _x0, x0, x2_。

`NTL.PALL` 指令用于提示目标指令在内存层次结构中的任何级别的私有缓存范围内缺乏时间局部性。其编码方式为 ADD _x0, x0, x3_。

`NTL.S1` 指令用于提示目标指令在内存层次结构中最内层的共享缓存范围内缺乏时间局部性。其编码方式为 ADD _x0, x0, x4_。

`NTL.ALL` 指令用于提示目标指令在内存层次结构中的任何级别的缓存范围内缺乏时间局部性。其编码方式为 ADD _x0, x0, x5_。

[NOTE]
====
NTL 指令可用于避免流式数据处理或遍历大型数据结构时的缓存污染，或在生产者-消费者交互场景中降低延迟。

在微架构层面，NTL 指令可以用于指导缓存替换策略，决定数据应分配至哪个缓存级别，甚至完全避免缓存分配。例如，NTL.P1 可指示处理器不要在私有 L1 缓存中分配缓存行，而应在 L2（无论是私有还是共享）中分配。另一些实现可能仍会在 L1 缓存中分配缓存行，但将其设为最近最少使用状态。

`NTL.ALL` 通常用于指示处理器避免在整个缓存层次结构中进行分配。程序员应在无法利用时间局部性的内存访问（例如流式传输）时使用 NTL.ALL。

与所有提示指令一样，NTL 指令可以被自由忽略。因此，尽管本文档以基于缓存的内存层次结构为背景描述这些指令，但它们并不强制要求提供缓存机制。

部分处理器可能会选择性地应用这些提示，例如某些通过 L1 缓存独占状态获取缓存行以实现 LR/SC 的处理器，可能会忽略 LR 和 SC 指令前的 NTL 指令，但仍可能对 AMO 及常规加载/存储指令前的 NTL 指令加以应用。
====

<<ntl-portable>> 列出了多个软件使用场景，并提供了可移植软件（即未针对特定实现的内存层次结构进行调优的软件）应采用的推荐 NTL 变体。

[[ntl-portable]]
.可移植软件在不同应用场景下的推荐 NTL 变体
[%autowidth,float="center",align="center",cols="<,<",options="header",]
|===
|场景 |推荐的 NTL 变体
|访问工作集规模在 和 之间 |NTL.P1
|访问工作集规模在 和 之间 |NTL.PALL
|访问工作集规模大于 |NTL.S1
|没有可利用时间局部性的访问（例如，流式传输） |NTL.ALL
|访问争用的同步变量 |NTL.PALL
|===

[NOTE]
====
<<ntl-portable>> 中列出的工作集大小并非旨在约束实现者的缓存大小决策。缓存大小在不同实现之间显然会有所不同，因此程序员应仅将这些工作集大小作为粗略的指导方针
====

<<ntl>> 列出了几个示例内存层次结构，并推荐了每种 NTL 变体如何映射到每个缓存级别。该表还推荐了实现调整的软件应使用哪种 NTL 变体来避免在特定缓存级别进行分配。例如，对于具有私有 L1 和共享 L2 的系统，建议 NTL.P1 和 NTL.PALL 指示 L1 无法利用时间局部性，NTL.S1 和 NTL.ALL 指示 L2 无法利用时间局部性。此外，针对此类系统调整的软件应使用 NTL.P1 来指示 L1 无法利用的时间局部性，或应使用 NTL.ALL 来指示 L2 无法利用的时间局部性。

如果提供了 C 扩展，则还提供了这些 HINT（提示）的压缩变体：C.NTL.P1 的编码为 `C.ADD _x0, x2_`；C.NTL.PALL 的编码为 `C.ADD _x0, x3_`；C.NTL.S1 的编码为 `C.ADD _x0, x4_`；C.NTL.ALL 的编码为 `C.ADD _x0, x5_`。

NTL 指令影响除 Zicbom 扩展中的缓存管理指令外的所有内存访问指令。

[NOTE]
====
截至本文撰写时，没有其他例外情况，因此 NTL 指令影响基本 ISA 和 A、F、D、Q、C 和 V 标准扩展中定义的所有内存访问指令，以及第二卷中的管理程序扩展中定义的那些指令。

NTL 指令可以影响 Zicbom 扩展之外的缓存管理操作。例如，NTL.PALL 后跟 CBO.ZERO 可能表示该行应在 L3 中分配并清零，但不应在 L1 或 L2 中分配。
====

<<<

[[ntl]]
[%autowidth,float="center",align="center",cols="<,^,^,^,^,^,^,^,^",options="header"]
.NTL 变体在不同内存层次结构中的映射关系。
|===
| 内存层次结构 4+| NTL 变体到实际缓存级别的推荐映射关系 4+| 用于显式缓存管理的推荐 NTL 变体
|
|P1 |PALL |S1 |ALL
|L1 |L2 |L3 |L4/L5
 9+^| 常见场景
| 无缓存 4+|--- 4+|无
|仅私有 L1 |L1 |L1 |L1 |L1| ALL |--- |--- |---
|私有 L1；共享 L2 |L1  |L1  |L2  |L2 |P1|ALL|---|---
|私有 L1；共享 L2/L3 |L1 | L1 | L2 | L3 |P1  |S1   |ALL |---
|私有 L1/L2 |L1  |L2  |L2  |L2 | P1  |ALL  |--- |---
|私有 L1/L2；共享 L3 |L1 | L2 | L3 | L3 | P1 | PALL| ALL |---
|私有 L1/L2；共享 L3/L4 | L1 | L2|  L3 | L4 | P1 | PALL | S1 | ALL
 9+^| 不常见场景
|私有 L1/L2/L3；共享 L4 | L1 | L3 |L4 |L4 |P1 |P1 |PALL |ALL
|私有 L1；共享 L2/L3/L4 |L1 | L1 |L2 |L4 |P1 |S1 |ALL |ALL
|私有 L1/L2；共享 L3/L4/L5  |L1 | L2 | L3 | L5 |P1 | PALL |S1 |ALL
|私有 L1/L2/L3；共享 L4/L5  |L1 |L3 |L4 |L5 |P1 |P1 |PALL |ALL
|===

当 NTL 指令被应用于 Zicbop 扩展的预取提示时，它所指示的是，应该将缓存行预取到相对于 NTL 所指定级别更外部的缓存层级中。

[NOTE]
====
例如，在具有私有 L1 和共享 L2 的系统中，NTL.P1 后跟 PREFETCH.R 可能会将数据预取到具有读取意图的 L2 中。

要预取到最内层缓存，请不要在预取指令前添加 NTL 指令。

在某些系统中，NTL.ALL 后跟预取指令可能会预取到内存控制器内部的缓存或预取缓冲区中。
====

我们不建议软件在 NTL 指令之后跟随一条不显式访问内存的指令。如果不遵循此建议，可能会降低性能，但在架构层面不会产生任何可见影响。

如果在目标指令上发生陷阱事件，我们建议处理器实现不要将 NTL 提示应用于陷阱处理程序的第一条指令。相反，我们更建议在这种情况下忽略该提示。

[NOTE]
====
假定在执行 NTL 指令与其目标指令之间发生中断，程序执行通常依然会在目标指令处恢复。NTL 指令是否重新执行并不会改变程序的语义。

考虑到某些处理器实现可能倾向于在确认目标指令之后再处理 NTL 指令（例如：为了使 NTL 能够与其修饰的内存访问操作相融合）。因此，这类实现可能更倾向于在 NTL 指令之前响应中断，而不是在 NTL 指令和内存访问操作之间响应中断。
====
'''
[TIP]
====
正因如此，NTL 指令才被编码为 ADD 指令，这样一来，它们就可以在 LR/SC 循环中使用，而不会破坏持续进展保证。然而，又由于在 LR/SC 循环中使用其他加载和存储确实会破坏持续进展保证（forward-progress guarantee），故而，在此类循环中使用 NTL 的唯一目的是为了修改 LR 或 SC 指令。
====
