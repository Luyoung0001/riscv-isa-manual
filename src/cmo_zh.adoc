[[cmo]]
== “CMO”扩展：基础缓存管理操作 ISA，版本 1.0.0

=== 指令语义的伪代码

<<#insns>> 章节中的每条指令的语义都用类似 SAIL 的语法表示。

[#intro,reftext="Introduction"]
=== 介绍

缓存管理操作（或 _CMO_）指令对内存层次结构中的数据副本执行操作。通常，CMO 指令操作的是数据的缓存副本，但在某些情况下，CMO 指令可能直接对内存位置进行操作。此外，CMO 指令按操作分为以下几类：

* 管理指令根据可以访问数据的一组代理来操作缓存的数据副本
* 清零指令将一范围内的内存位置清零，可能在一个或多个缓存中分配数据的缓存副本
* 预取指令向硬件指示给定内存位置的数据可能在不久之后被访问，可能在一个或多个缓存中分配数据的缓存副本

本文档介绍了一组专门对缓存块或与缓存块对应的内存位置进行操作的 CMO ISA 扩展；这些称为缓存块操作（或 _CBO_）指令。上述每类指令在本规范中都代表一个扩展：

* _Zicbom_ 扩展定义了一组缓存块管理指令：`CBO.INVAL`、`CBO.CLEAN` 和 `CBO.FLUSH`
* _Zicboz_ 扩展定义了一条缓存块清零指令：`CBO.ZERO`
* _Zicbop_ 扩展定义了一组缓存块预取指令：`PREFETCH.R`、`PREFETCH.W` 和 `PREFETCH.I`

上述指令的执行行为也受本规范添加的控制状态寄存器状态的影响。

本文档的其余部分提供了有关 CMO 指令的一般背景信息，并描述了上述每个 ISA 扩展。

[NOTE]
====
_CMO 一词包含了对缓存或与缓存相关的资源的所有操作。CBO 一词代表仅对缓存块进行操作的 CMO 子集。第一个 CMO 扩展仅定义了 CBO。_
====

[#background,reftext="Background"]
=== 背景

本章提供了所有 CMO 扩展的通用信息。

[#memory-caches,reftext="Memory and Caches"]
==== 内存和缓存

内存位置是系统中由物理地址唯一标识的物理资源。代理是一个逻辑块，例如 RISC-V 硬件线程、加速器、I/O 设备等，可以访问给定的内存位置。

[NOTE]
====
_某个代理可能无法访问系统中的所有内存位置，两个不同的代理可能会也可能不会访问同一组内存位置。_
====

加载操作（或存储操作）由代理执行，用于获取（或修改）给定内存位置的数据。加载和存储操作是通过对该内存位置的显式内存访问而执行的。此外，读取传输从内存中获取该内存位置的数据，而写入传输则更新该内存位置的数据。

缓存是一种结构，用于缓冲数据副本以减少平均内存延迟。在代理和内存位置之间可以插入任意数量的缓存，并且代理的加载和存储操作可以由缓存而不是内存位置来满足。

[NOTE]
====
_加载和存储操作通过缓存实现了与物理读写传输的解耦。例如：加载操作可能仅通过缓存即可完成（无需执行来自内存的读取传输）；而存储操作可能需要先通过缓存执行来自内存的读取传输，之后才能完成该存储操作。_
====

缓存将数据副本组织成缓存块，每个缓存块代表一组连续的、自然对齐的二的幂（或 _NAPOT_）的内存位置范围。缓存块由对应于底层内存位置的任何物理地址标识。缓存的容量和组织以及缓存块的大小都是实现特定的，执行环境为软件提供了一种方法来发现系统中缓存和缓存块的信息。在最初的 CMO 扩展中，缓存块的大小在整个系统中应是统一的。

[NOTE]
====
_在未来的 CMO 扩展中，对统一缓存块大小的要求可能会放宽。_
====

诸如推测执行或硬件预取等实现技术可能会导致在缓存任何时间分配或释放缓存块的副本，前提是相应的物理地址可以根据支持的访问类型物理内存属性（PMA）访问，并且根据缓存可缓存能力物理内存属性是可缓存的。分配缓存块的副本会导致从另一个缓存或内存进行读取传输，而释放缓存块的副本可能会导致写入传输到另一个缓存或内存，具体取决于副本中的数据是否已被存储操作修改。更多详细信息请参见 <<#coherent-agents-caches>>。

==== 缓存块操作

CBO 指令会对指令标识的缓存块执行一个或多个操作。通常，CBO 指令可以标识一个或多个缓存块；然而，在最初的 CMO 扩展中，CBO 指令仅标识单个缓存块。

缓存块管理指令相对于分配在给定缓存中的给定缓存块的副本执行以下操作之一：

* 使无效操作释放缓存块的副本

* 清理操作如果缓存块副本中的数据已被存储操作修改，则执行写入传输到另一个缓存或内存

* 刷新操作原子性地执行清理操作，然后执行使无效操作

更多详细信息，包括给定缓存块管理指令执行的实际操作，请参见 <<#Zicbom>>。

缓存块清零指令执行一组存储操作，将零写入与缓存块对应的一组字节。除非另有说明，否则缓存块清零指令生成的存储操作具有与架构中的其他存储指令相同的一般属性和行为。实现可以选择是否使用单个存储操作原子性地更新整个字节集。更多详细信息请参见 <<#Zicboz>>。

缓存块预取指令是对硬件的提示，表明软件预计在不久的将来会执行特定类型的内存访问。更多详细信息请参见 <<#Zicbop>>。

[#coherent-agents-caches,reftext="一致代理和缓存"]
=== 一致代理和缓存

对于给定的内存位置，一组一致代理由满足以下所有条件的代理组成：

* 集合中所有代理的存储操作相对于彼此呈现为串行化
* 集合中所有代理的存储操作最终对集合中的所有其他代理可见
* 集合中某代理的加载操作返回集合中某代理的存储操作的数据（或内存中的初始数据）

这样的集合中的一致性代理应使用相同的物理地址和相同的物理内存属性访问给定的内存位置；但是，如果给定代理的一致性 PMA 表明给定的内存位置不一致，则该代理不应成为该内存位置与任何其他代理的一致代理集合的成员，并且应成为由其自身组成的一致代理集合的唯一成员。

成为一致代理集合成员的代理被称为相对于集合中的其他代理是一致的。另一方面，不是成员的代理被称为相对于集合中的代理是不一致的。

缓存引入了在系统中同时存在给定缓存块的多个副本的可能性。一个实现特定的机制使这些副本相对于一致代理集合中的代理的加载和存储操作保持一致。此外，如果集合中的一致代理执行指定缓存块的 CBO 指令，则结果操作应适用于可以通过一致代理的加载和存储操作访问的缓存中的所有副本。

[NOTE]
====
_来自 CBO 指令的操作被定义为仅对由一致代理集合执行的显式内存访问可访问的缓存中缓存的缓存块副本进行操作。这包括仅通过加载和存储操作间接访问的缓存中的缓存块副本，例如一致性指令缓存。_
====

受上述机制约束的缓存集合形成一个一致性缓存集合，并且每个一致性缓存具有以下行为，假设所有操作均由一致性代理集合中的代理执行：

* 允许一致缓存分配和释放缓存块的副本，并执行 <<#memory-caches>> 中描述的读写传输

* 只要自最近一次对缓存块使无效（invalidate）、清理或刷新操作以来，存储操作已经修改了缓存块中的数据，缓存是允许执行写入传输到内存的操作的

* 至少一个一致缓存负责执行写入传输到内存，一旦存储操作修改了缓存块中的数据，直到下一次对缓存块的使无效、清理或刷新操作为止，在此之后，直到下一次存储操作修改缓存块中的数据，所有一致性缓存都不负责（或不允许）执行写传输到内存。

* 如果存储操作自最近一次对缓存块的使无效、清理或刷新操作以来修改了缓存块中的数据，并且下一次清理或刷新操作需要写入传输到内存，则一致缓存必须执行写入传输到内存

[NOTE]
====
_上述限制确保了通过从内存读取传输能够获取一个“清洁”的缓存块副本，并且没有被存储操作修改，之后不会覆盖由非一致性代理通过写传输更新到内存的缓存块副本。_
====

非一致性代理可以启动一个缓存块操作，该操作作用于由一致性代理集访问的一致性缓存集。执行此类操作的机制是特定于实现的。

==== 内存顺序

===== 保留的程序顺序

保留的程序顺序（缩写为 _PPO_）规则由 RVWMO 内存排序模型定义。以下描述了由 CMO 指令产生的操作如何适应这些规则。

对于缓存块管理指令，产生的使无效、清理和刷新操作在 PPO 规则中表现为存储操作，但受一个附加的重叠地址规则的约束。具体来说，如果 _a_ 在程序顺序中先于 _b_，则如果满足以下条件，_a_ 将在全局内存顺序中先于 _b_：

* _a_ 是使无效、清理或刷新操作，_b_ 是加载操作，并且 _a_ 和 _b_ 访问相同的内存地址

[NOTE]
====
_上述规则确保了程序顺序中的后续加载操作在全局内存顺序中永远不会出现在先前的使无效、清除或刷新操作之前，尤其是当它们访问相同地址时。_
====

此外，使无效、清理和刷新操作在 `FENCE` 指令的前驱和后继集中被分类为 W 或 O（取决于相应物理地址的物理内存属性）。这些操作不会被其他排序存储的指令排序，例如 `FENCE.I` 和 `SFENCE.VMA`。

对于缓存块清零指令，生成的存储操作在 PPO 规则中表现为存储，并会被其他排序存储的指令排序。

最后，对于缓存块预取指令，产生的操作不受 PPO 规则的排序，也不受任何其他排序指令的排序。

===== 加载值

使无效操作可能会改变加载可以返回的值集。特别地，加载值公理中新增了一个附加条件：

* 如果一个使无效操作 _i_ 在加载操作 _r_ 之前，并且该操作作用于 _r_ 返回的字节 _x_，并且在 _i_ 和 _r_ 之间的程序顺序或全局内存顺序中没有对 _x_ 的存储操作，那么 _r_ 可以返回以下任意值：

. 如果在全局内存顺序中没有清除或刷新操作在 _i_ 之前操作 _x_，则返回 _x_ 的初始值或任何在 _i_ 之前对 _x_ 进行的存储操作的值。

. 如果在全局内存顺序中没有存储操作在清除或刷新操作之前操作 _x_，并且 _x_ 上的清除或刷新操作在 _i_ 之前操作 _x_，则返回 _x_ 的初始值或任何在 _i_ 之前对 _x_ 进行的存储操作的值。

. 如果在全局内存顺序中，存储操作在清除或刷新操作之前操作 _x_，并且 _x_ 上的清除或刷新操作在 _i_ 之前操作 _x_，则返回 _x_ 的最新存储操作的值（该操作在最新的清除或刷新操作之前），或者返回任何对 _x_ 的存储操作，该操作既在 _i_ 之前，又在最新的清除或刷新操作之后。

. 返回由非一致代理对 _x_ 的任何存储的值，无论上述条件如何

[NOTE]
====
前三个要点描述了在全局内存顺序中相对于清理或刷新操作，不同位置的可能加载值。最后一个要点意味着加载值可能在任何时候由非一致性代理产生。
====

==== 陷阱

执行某些 CMO 指令可能会由于控制状态寄存器的状态（在 <<#csr_state>> 部分中描述）或由于地址转换和保护机制而触发陷阱。CMO 指令的陷阱行为在以下部分描述。

===== 非法指令和虚拟指令异常

缓存块管理指令和缓存块清零指令可能会根据当前特权模式和 <<#csr_state>> 部分中描述的 CMO 控制寄存器的状态引发非法指令异常或虚拟指令异常。

缓存块预取指令不会引发非法指令异常或虚拟指令异常。

===== 缺页异常、客户机缺页异常和访问故障异常

与加载和存储指令类似，CMO 指令是计算有效地址的显式内存访问指令。有效地址最终根据特权模式和启用的转换机制转换为物理地址，CMO 扩展对给定缓存块中的物理地址施加以下约束：

* 物理内存保护（PMP）访问控制位对于缓存块中的所有物理地址应相同，并且如果物理内存保护访问控制位授予写权限，则还应授予读权限

* 物理内存属性（PMA）对于缓存块中的所有物理地址应相同，并且如果支持的访问类型物理内存属性授予写权限，则还应授予读权限

如果上述约束未得到满足，则 CBO 指令的行为是未定义的。

[NOTE]
====
本规范假定上述约束通常会在主存区域满足，并且可能在某些 I/O 区域满足。
====

Zicboz 扩展引入了一个额外的支持访问类型物理内存属性，用于缓存块清零指令。主存区域需要支持缓存块清零指令的访问；然而，I/O 区域可以指定是否支持缓存块清零指令的访问。

当加载指令或存储指令被允许访问相应的物理地址时，缓存块管理指令被允许访问指定的缓存块。如果加载指令和存储指令都不允许访问物理地址，但指令获取被允许访问物理地址，则缓存块管理指令是否被允许访问缓存块是未定义的。如果不允许访问缓存块，则缓存块管理指令会在地址转换不允许任何访问时引发存储页面错误（store page fault）或存储访客页面错误异常（store guest-page fault exception），或者在其他情况下引发存储访问错误异常。在地址转换过程中，指令还会检查访问位，并根据需要抛出异常或设置该位。

[NOTE]
====
缓存块管理指令与指令获取之间的交互将在未来的扩展中指定。

这意味着，缓存块管理指令不会检查脏位，也不会引发异常或设置该位。
====

只要存储指令被允许访问相应的物理地址，并且 PMA 指示缓存块清零指令是支持的访问类型，就允许缓存块清零指令访问指定的缓存块。如果不允许访问缓存块，则缓存块清零指令会在地址转换不允许写访问时引发存储页故障或存储访客页故障异常，否则会引发存储访问故障异常。在地址转换期间，指令还会检查访问位和脏位，并可能根据需要引发异常或设置这些位。

只要加载指令、存储指令或指令获取被允许访问相应的物理地址，就允许缓存块预取指令访问指定的缓存块。如果不允许访问缓存块，则缓存块预取指令不会引发任何异常，也不会访问任何缓存或内存。在地址转换期间，指令不会检查访问位和脏位，也不会引发异常或设置这些位。

当发生页故障、访客页故障或访问故障异常时，相关的 *tval 控制状态寄存器会写入故障的有效地址（即与这些异常的其他原因相同的故障地址值）。

[NOTE]
====
像加载或存储指令一样，CMO 指令是否被允许访问缓存块取决于 `mstatus` 中的 `MPRV`、`MPV` 和 `MPP` 位以及 `mstatus`、`sstatus` 和 `vsstatus` 中的 `SUM` 和 `MXR` 位的状态。

本规范预计实现将像处理存储/AMO 指令一样处理缓存块管理指令，因此，无论所需的权限如何，存储/AMO异常适用于这些指令。
====

===== 地址未对齐异常

CMO 指令不会生成地址未对齐异常。

===== 断点异常和调试模式进入

除非调试架构规范另有定义，否则触发模块（trigger modules）相对于 CMO 指令的行为是未指定的。

[NOTE]
====
对于 Zicbom、Zicboz 和 Zicbop 扩展，本规范建议以下通用触发模块行为：

* 应支持类型 6 地址匹配触发器（match triggers），即 `tdata1.type=6` 和 `mcontrol6.select=0`

* 不应支持类型 2 地址/数据匹配触发器，即 `tdata1.type=2`
    
* 内存访问的大小等于访问的缓存块的大小，比较值来自包含有效地址的 NAPOT 内存区域的地址
  
* 除非在 `mcontrol6.size` 字段中添加了缓存块的编码，否则地址触发器仅在 `mcontrol6.size=0` 时匹配来自 CBO 指令的内存访问
    
如果实现了 Zicbom 扩展，本规范建议以下附加触发模块行为：

* 实现地址匹配触发器应为可选项

* 不应支持类型 6 数据匹配触发器，即 `tdata1.type=6` 和 `mcontrol6.select=1`

* 内存访问被视为存储，即地址触发器仅在 `mcontrol6.store=1` 时匹配

如果实现了 Zicboz 扩展，本规范建议以下附加触发模块行为：

* 实现地址匹配触发器应为强制项

* 应支持类型 6 数据匹配触发器，即 `tdata1.type=6` 和 `mcontrol6.select=1`，并且实现这些触发器应为可选

* 内存访问被视为存储，即地址触发器仅在 `mcontrol6.store=1` 时匹配

如果实现了 Zicbop 扩展，本规范建议以下附加触发模块行为：

* 实现地址匹配触发器应为可选项

* 不应支持类型 6 数据匹配触发器，即 `tdata1.type=6` 和 `mcontrol6.select=1`

* 内存访问可以视为加载或存储，具体取决于实现，即当 `mcontrol6.load=1` 或 `mcontrol6.store=1` 时，这些指令上的地址触发器是否匹配是实现特定的

本规范还建议，Zicboz 扩展的触发模块行为应在调试架构规范的 1.0 版本中定义。Zicbom 和 Zicbop 扩展的触发模块行为预计将在未来的扩展中定义。
====

===== 虚拟机管理程序扩展

为了在陷阱时写入 `mtinst` 或 `htinst` 寄存器，定义了以下标准转换用于缓存块管理指令和缓存块清零指令：

[wavedrom, , svg]
....
{reg:[
    { bits: 7,  name: 'opcode'},
    { bits: 5,  name: 0x0 },
    { bits: 3,  name: 'funct3'},
    { bits: 5,  name: 0x0},
    { bits: 12, name: 'operation'},
]}
....

`operation` 字段对应于陷阱指令的 12 个最高有效位。

[NOTE]
====
如虚拟机管理程序扩展中所述，可以将零写入 `mtinst` 或 `htinst`，而不是上述标准转换。
====

==== 对受约束的 LR/SC 循环的影响

以下事件被添加到满足 A 扩展中定义的受约束 LR/SC 循环提供的最终保证的事件列表中：

* 其他硬件线程对 _H_ 的受约束 LR/SC 循环中的 LR 指令的预留集执行缓存块管理指令或缓存块清零指令。

[NOTE]
====
添加上述事件是为了适应无法区分存储失效和缓存块管理操作失效的缓存一致性协议。

除了上述事件外，CMO 指令既不会改变受约束 LR/SC 循环的属性，也不会修改它们提供的最终性保证。例如，执行 CMO 指令可能会导致任何硬件线程上的受约束 LR/SC 循环周期性失败，或者可能导致同一硬件线程上的非受约束 LR/SC 序列始终失败。此外，执行缓存块预取指令不会影响任何硬件线程上执行的受约束 LR/SC 循环提供的最终保证。
====

==== 软件探测

最初的 CMO 扩展要求软件发现以下信息：

* 管理和预取指令的缓存块大小
* 清零指令的缓存块大小
* 每个特权级别的 CBIE 支持

探测机制中还可以指定其他一般缓存特性。

[#csr_state,reftext="控制和状态寄存器状态"]
=== 控制状态寄存器状态

[NOTE]
====
CMO 扩展依赖于将在未来的特权架构更新中定义的 {csrname} 控制状态寄存器的状态。如果此控制状态寄存器更新未被批准，CMO 扩展将定义其自己的控制状态寄存器。
====

三种 CSR 控制 CMO 指令的执行：

* `m{csrname}`
* `s{csrname}`
* `h{csrname}`

`s{csrname}` 寄存器由所有监督模式使用，包括 VS 模式。虚拟机管理程序负责在客户上下文切换时保存和恢复 `s{csrname}`。`h{csrname}` 寄存器仅在实现并启用了 H 扩展时存在。

每个 `x{csrname}` 寄存器（其中 `x` 是 `m`、`s` 或 `h`）具有以下通用格式：

.x{csrname} CSRs 的通用格式
[cols="^10,^10,80a"]
|===
| 位    | 名称     | 描述

| [5:4]   | `CBIE`   | 缓存块无效化指令使能

能够在较低特权模式下执行缓存块使无效指令 `CBO.INVAL`：

* `00`: 指令引发非法指令或虚拟指令异常
* `01`: 指令执行并执行刷新操作
* `10`: 保留
* `11`: 指令执行并执行使无效操作

| [6]     | `CBCFE`  | 缓存块清除和刷新指令使能

能够在较低特权模式下执行缓存块清理指令 `CBO.CLEAN` 和缓存块刷新指令 `CBO.FLUSH`：

* `0`: 指令引发非法指令或虚拟指令异常
* `1`: 指令执行

| [7]     | `CBZE`   | 缓存块清零指令使能

能够在较低特权模式下执行缓存块清零指令 `CBO.ZERO`：

* `0`: 指令引发非法指令或虚拟指令异常
* `1`: 指令执行

|===

x{csrname} 寄存器根据当前特权模式和适当的控制状态寄存器状态控制 CBO 指令的执行，具体如下所述。

`CBO.INVAL` 指令根据 `x{csrname}.CBIE` 字段的状态执行或引发非法指令异常或虚拟指令异常：

[source,sail,subs="attributes+"]
--

// 非法指令异常
if (((priv_mode != M) && (m{csrname}.CBIE == 00)) ||
    ((priv_mode == U) && (s{csrname}.CBIE == 00)))
{
  <触发非法指令异常>
}
// 虚拟指令异常
else if (((priv_mode == VS) && (h{csrname}.CBIE == 00)) ||
         ((priv_mode == VU) && ((h{csrname}.CBIE == 00) || (s{csrname}.CBIE == 00))))
{
  <触发虚拟指令异常>
}
// 执行指令
else
{
  if (((priv_mode != M) && (m{csrname}.CBIE == 01)) ||
      ((priv_mode == U) && (s{csrname}.CBIE == 01)) ||
      ((priv_mode == VS) && (h{csrname}.CBIE == 01)) ||
      ((priv_mode == VU) && ((h{csrname}.CBIE == 01) || (s{csrname}.CBIE == 01))))
  {
    <执行 CBO.INVAL 并执行刷新操作>
  }
  else
  {
    <执行 CBO.INVAL 并执行使无效操作>
  }
}


--

[NOTE]
====
在修改后的缓存块更新内存之前，如果控制状态寄存器被编程为执行使无效操作，则 `CBO.INVAL` 指令可能会在内存中暴露过时的数据值。如果较低特权级别的软件执行使无效操作并访问内存中的敏感信息，这种行为可能会导致安全漏洞。

为了避免此类漏洞，较高特权级别的软件必须在允许较低特权级别的软件对缓存块执行使无效操作之前，对缓存块执行清理或刷新操作。或者，较高特权级别的软件可以编程控制状态寄存器，使得 `CBO.INVAL` 在较低特权级别下要么触发陷阱，要么执行刷新操作。
====

`CBO.CLEAN` 或 `CBO.FLUSH` 指令根据 `x{csrname}.CBCFE` 位的状态决定是否能够成功执行或是引发非法指令异常或是引发虚拟指令异常：

[source,sail,subs="attributes+"]
--

// 非法指令异常
if (((priv_mode != M) && !m{csrname}.CBCFE) ||
    ((priv_mode == U) && !s{csrname}.CBCFE))
{
  <触发非法指令异常>
}
// 虚拟指令异常
else if (((priv_mode == VS) && !h{csrname}.CBCFE) ||
         ((priv_mode == VU) && !(h{csrname}.CBCFE && s{csrname}.CBCFE)))
{
  <触发虚拟指令异常>
}
// 执行指令
else
{
  <执行 CBO.CLEAN 或 CBO.FLUSH 指令>
}

--

最后，`CBO.ZERO` 指令根据 `x{csrname}.CBZE` 位的状态决定是否能够成功执行或是引发非法指令异常或是引发虚拟指令异常：

[source,sail,subs="attributes+"]
--

// 非法指令异常
if (((priv_mode != M) && !m{csrname}.CBZE) ||
    ((priv_mode == U) && !s{csrname}.CBZE))
{
  <触发非法指令异常>
}
// 虚拟指令异常
else if (((priv_mode == VS) && !h{csrname}.CBZE) ||
         ((priv_mode == VU) && !(h{csrname}.CBZE && s{csrname}.CBZE)))
{
  <触发虚拟指令异常>
}
// 执行指令
else
{
  <执行 CBO.ZERO 指令>
}

--

每个 `x{csrname}` 寄存器都是 WARL（Write Any, Read Legal） 的；然而，软件应从执行环境发现机制来确定合法值。

[#extensions,reftext="Extensions"]
=== 扩展

CMO 指令在以下扩展中定义：

* <<#Zicbom>>
* <<#Zicboz>>
* <<#Zicbop>>

[#Zicbom,reftext="Cache-Block Management Instructions"]
==== 缓存块管理指令

缓存块管理指令使运行在一致性代理集（coherent agents）上的软件能够通过执行以下操作之一与非一致性代理集（non-coherent agents）进行通信：

* 使无效操作通过从一致性缓存集合中释放所有缓存块副本，使得由一组非一致性代理执行的存储操作的数据在两个集合的共同点上对一致性代理集合可见
  
* 清理操作通过执行缓存块副本的写入传输，使得由一致代理集合执行的存储操作的数据在两个集合的共同点上对非一致代理集合可见，前提是自上次对缓存块的使无效、清理或刷新操作以来，一致代理执行了修改缓存块中数据的存储操作
  
* 刷新操作原子性地执行清理操作，然后执行使无效操作

在 Zicbom 扩展中，指令在系统中所有代理的共同点上操作。换句话说，使无效操作确保所有非一致性代理的存储操作对一致性代理集合中的代理可见，而清理操作确保一致性代理的存储操作对所有非一致性代理可见。

[NOTE]
====
Zicbom 扩展不禁止超出上述架构定义的代理；然而，软件不能依赖定义的缓存操作对这些代理产生预期的效果。

未来的扩展可能会定义不同的代理集合以进行性能优化。
====

这些指令对其有效地址在 _rs1_ 中指定的缓存块进行操作。有效地址通过适当的转换机制转换为相应的物理地址。

以下指令组成了 Zicbom 扩展：

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

|&#10003;
|&#10003;
|cbo.clean _base_
|<<#insns-cbo_clean>>

|&#10003;
|&#10003;
|cbo.flush _base_
|<<#insns-cbo_flush>>

|&#10003;
|&#10003;
|cbo.inval _base_
|<<#insns-cbo_inval>>

|===

[#Zicboz,reftext="Cache-Block Zero Instructions"]
==== 缓存块归零指令

缓存块归零指令将零值存储到与缓存块对应的一组字节中。实现可以以任意顺序和粒度、原子性地更新字节，包括单个字节。

[NOTE]
====
缓存块归零指令将零值存储到字节中，而不考虑底层内存位置的数据是否可缓存。此外，本规范不限制字节写入的方式。
====

这些指令作用于缓存块或与缓存块对应的内存位置，其有效地址由 _rs1_ 指定。有效地址通过适当的转换机制转换为相应的物理地址。

以下指令组成了 Zicboz 扩展：

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

|&#10003;
|&#10003;
|cbo.zero _base_
|<<#insns-cbo_zero>>

|===

[#Zicbop,reftext="Cache-Block Prefetch Instructions"]
==== 缓存块预取指令

缓存块预取指令是对硬件的提示，表明软件打算在不久的将来执行特定类型的内存访问。内存访问的类型包括指令获取、数据读取（即加载）和数据写入（即存储）。

这些指令对其有效地址是 _rs1_ 中指定的基地址与 _imm[11:0]_ 中编码的符号扩展偏移量之和的缓存块进行操作，其中 _imm[4:0]_ 应等于 `0b00000`。有效地址通过适当的转换机制转换为相应的物理地址。

[NOTE]
====
缓存块预取指令被编码为 rd 等于 `0b00000` 的 ORI 指令；然而，为了有效地址计算的目的，该字段也被解释为 imm[4:0]，类似于存储指令。
====

以下指令组成了 Zicbop 扩展：

[%header,cols="^1,^1,4,8"]
|===
|RV32
|RV64
|Mnemonic
|Instruction

|&#10003;
|&#10003;
|prefetch.i _offset_(_base_)
|<<#insns-prefetch_i>>

|&#10003;
|&#10003;
|prefetch.r _offset_(_base_)
|<<#insns-prefetch_r>>

|&#10003;
|&#10003;
|prefetch.w _offset_(_base_)
|<<#insns-prefetch_w>>

|===

[#insns,reftext="Instructions"]
=== 指令

[#insns-cbo_clean,reftext="缓存块清除"]
==== cbo.clean

简述::
对缓存块执行清除操作

助记符::
cbo.clean _offset_(_base_)

编码::
[wavedrom, , svg]
....
{reg:[
    { bits: 7,  name: 0xF,   attr: ['MISC-MEM'] },
    { bits: 5,  name: 0x0 },
    { bits: 3,  name: 0x2,   attr: ['CBO'] },
    { bits: 5,  name: 'rs1', attr: ['base'] },
    { bits: 12, name: 0x001, attr: ['CBO.CLEAN'] },
]}
....

描述::

*cbo.clean* 指令对有效地址为 rs1 中指定的基地址的缓存块执行清除操作。偏移操作数可以省略；否则，任何计算偏移量的表达式都应计算为零。该指令作用于执行指令的代理访问的缓存一致性缓存集。

操作::

[source,sail]
--
TODO
--

[#insns-cbo_flush,reftext="缓存块刷新"]
==== cbo.flush

简述::
对缓存块执行刷新操作

助记符::
cbo.flush _offset_(_base_)

编码::
[wavedrom, , svg]
....
{reg:[
	{ bits: 7,  name: 0xF,   attr: ['MISC-MEM'] },
	{ bits: 5,  name: 0x0 },
	{ bits: 3,  name: 0x2,   attr: ['CBO'] },
	{ bits: 5,  name: 'rs1', attr: ['base'] },
	{ bits: 12, name: 0x002, attr: ['CBO.FLUSH'] },
]}
....

描述::  

*cbo.flush* 指令对有效地址为 _rs1_ 中指定的基地址的缓存块执行刷新操作。偏移操作数可以省略；否则，任何计算偏移量的表达式都应计算为零。该指令作用于执行指令的代理访问的缓存一致性缓存集。

操作::  

[source,sail]  
--  
TODO  
--  

[#insns-cbo_inval,reftext="缓存块使无效"]  
==== cbo.inval  

简述::  
对缓存块执行使无效操作  

助记符::  
cbo.inval _offset_(_base_)  

编码::  
[wavedrom, , svg]  
....  
{reg:[  
	{ bits: 7,  name: 0xF,   attr: ['MISC-MEM'] },  
	{ bits: 5,  name: 0x0 },  
	{ bits: 3,  name: 0x2,   attr: ['CBO'] },  
	{ bits: 5,  name: 'rs1', attr: ['base'] },  
	{ bits: 12, name: 0x000, attr: ['CBO.INVAL'] },  
]}  
....  

描述::  

*cbo.inval* 指令对有效地址为 rs1 中指定的基地址的缓存块执行使无效操作。偏移操作数可以省略；否则，任何计算偏移量的表达式都应计算为零。该指令作用于执行指令的代理访问的缓存一致性缓存集。根据控制状态寄存器的编程，指令可能会执行刷新操作，而不是使无效操作。

操作::  

[source,sail]  
--  
TODO  
--  

[#insns-cbo_zero,reftext="缓存块清零"]  
==== cbo.zero  

简述::  
将零存储到与缓存块对应的完整字节集  

助记符::  
cbo.zero _offset_(_base_)  

编码::  
[wavedrom, , svg]  
....  
{reg:[  
	{ bits: 7,  name: 0xF,   attr: ['MISC-MEM'] },  
	{ bits: 5,  name: 0x0 },  
	{ bits: 3,  name: 0x2,   attr: ['CBO'] },  
	{ bits: 5,  name: 'rs1', attr: ['base'] },  
	{ bits: 12, name: 0x004, attr: ['CBO.ZERO'] },  
]}  
....  

描述::  

*cbo.zero* 指令将零值存储到与有效地址为 _rs1_ 中指定的基地址的缓存块对应的所有字节中。偏移操作数可以省略；否则，任何计算偏移量的表达式都应计算为零。实现可以选择是否以原子方式更新整个字节集。

操作::  

[source,sail]  
--  
TODO  
--  

[#insns-prefetch_i,reftext="指令取值的缓存块预取"]  
==== prefetch.i  

简述::  
向硬件提供一个提示，表明某个缓存块在不久的将来可能会被指令取值访问  

助记符::  
prefetch.i _offset_(_base_)  

编码::  
[wavedrom, , svg]  
....  
{reg:[  
	{ bits: 7,  name: 0x13,        attr: ['OP-IMM'] },  
	{ bits: 5,  name: 0x0,         attr: ['offset[4:0]'] },  
	{ bits: 3,  name: 0x6,         attr: ['ORI'] },  
	{ bits: 5,  name: 'rs1',       attr: ['base'] },  
	{ bits: 5,  name: 0x0,         attr: ['PREFETCH.I'] },  
	{ bits: 7,  name: 'imm[11:5]', attr: ['offset[11:5]'] },  
]}  
....  

描述::  

*prefetch.i* 指令向硬件指示，有效地址为 _rs1_ 中指定的基地址与 _imm[11:0]_ 中编码的符号扩展偏移之和的缓存块，可能在不久的将来被指令获取访问，其中 _imm[4:0]_ 等于 `0b00000`。
[NOTE]  
====  
某些实现可能会选择在指令取值访问的缓存中缓存该缓存块的副本，以降低内存访问延迟，但这种行为并非强制要求的。
====  

操作::  

[source,sail]  
--  
TODO  
--  

[#insns-prefetch_r,reftext="数据读取的缓存块预取"]  
==== prefetch.r  

简述::  
向硬件提供一个提示，表明某个缓存块在不久的将来可能会被数据读取访问  

助记符::  
prefetch.r _offset_(_base_)  

编码::  
[wavedrom, , svg]  
....  
{reg:[  
	{ bits: 7,  name: 0x13,        attr: ['OP-IMM'] },  
	{ bits: 5,  name: 0x0,         attr: ['offset[4:0]'] },  
	{ bits: 3,  name: 0x6,         attr: ['ORI'] },  
	{ bits: 5,  name: 'rs1',       attr: ['base'] },  
	{ bits: 5,  name: 0x1,         attr: ['PREFETCH.R'] },  
	{ bits: 7,  name: 'imm[11:5]', attr: ['offset[11:5]'] },  
]}  
....  

描述::  

*prefetch.r* 指令向硬件指示，有效地址为 _rs1_ 中指定的基地址与 _imm[11:0]_ 中编码的符号扩展偏移之和的缓存块，可能会在不久的将来通过数据读取（即加载）被访问，其中 _imm[4:0]_ 等于 `0b00000`。
[NOTE]  
====  
某些实现可能会选择在数据读取访问的缓存中缓存该缓存块的副本，以改善内存访问延迟，但这种行为并非强制要求。
====  

操作::  

[source,sail]  
--  
TODO  
--  

[#insns-prefetch_w,reftext="数据写入的缓存块预取"]  
==== prefetch.w  

简述::  
向硬件提供一个提示，表明某个缓存块在不久的将来可能会被数据写入访问  

助记符::  
prefetch.w _offset_(_base_)  

编码::  
[wavedrom, , svg]  
....  
{reg:[  
	{ bits: 7,  name: 0x13,        attr: ['OP-IMM'] },  
	{ bits: 5,  name: 0x0,         attr: ['offset[4:0]'] },  
	{ bits: 3,  name: 0x6,         attr: ['ORI'] },  
	{ bits: 5,  name: 'rs1',       attr: ['base'] },  
	{ bits: 5,  name: 0x3,         attr: ['PREFETCH.W'] },  
	{ bits: 7,  name: 'imm[11:5]', attr: ['offset[11:5]'] },  
]}  
....  

描述::  

*prefetch.w* 指令向硬件指示，有效地址为 _rs1_ 中指定的基地址与 _imm[11:0]_ 中编码的符号扩展偏移之和的缓存块，可能会在不久的将来通过数据写入（即存储）被访问，其中 _imm[4:0]_ 等于 `0b00000`。

[NOTE]  
====  
某些实现可能会选择在数据写入访问的缓存中缓存该缓存块的副本，以改善内存访问延迟，但这种行为并非强制要求。  
====  

操作::  

[source,sail]  
--  
TODO  
--  