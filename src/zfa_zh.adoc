[[zfa]]
== “Zfa” 扩展：额外浮点指令, 版本 1.0

本章描述了 Zfa 标准扩展，该扩展增加了立即数加载指令、IEEE 754-2019 最小值和最大值操作、舍入到整数操作（round-to-integer operations）以及静默浮点数比较指令（quiet floating-point comparisonsS）。对于 RV32D，Zfa 扩展还增加了将双精度浮点值与整数寄存器之间传输的指令；对于 RV64Q，则增加了类似的指令，用于四精度浮点值。Zfa 扩展依赖于 F 扩展。

=== 立即数加载指令

FLI.S 指令将编码在 _rs1_ 字段中的 32 个单精度浮点常量之一加载到浮点寄存器 _rd_ 中。_rs1_字段值与单精度浮点值的对应关系如<<tab:flis, Table 37>>所示。FLI.S 的编码方式类似于FMV.W.X，但 _rs2_=1。

[[tab:flis]]
.FLI.S 指令加载的立即数值。
[%autowidth,float="center",align="center",cols=">,>,^,^,^",options="header",]
|===
|_rs1_ | 值 | 符号 | 指数 | 有效数
|0 |latexmath:[$-1.0$] |`1` |`01111111` |`000...000`
|1 |_Minimum positive normal_ |`0` |`00000001` |`000...000`
|2 |latexmath:[$1.0 \times 2^{-16}$] |`0` |`01101111` |`000...000`
|3 |latexmath:[$1.0 \times 2^{-15}$] |`0` |`01110000` |`000...000`
|4 |latexmath:[$1.0 \times 2^{-8}$] |`0` |`01110111` |`000...000`
|5 |latexmath:[$1.0 \times 2^{-7}$] |`0` |`01111000` |`000...000`
|6 |0.0625 (latexmath:[$2^{-4}$]) |`0` |`01111011` |`000...000`
|7 |0.125 (latexmath:[$2^{-3}$]) |`0` |`01111100` |`000...000`
|8 |0.25 |`0` |`01111101` |`000...000`
|9 |0.3125 |`0` |`01111101` |`010...000`
|10 |0.375 |`0` |`01111101` |`100...000`
|11 |0.4375 |`0` |`01111101` |`110...000`
|12 |0.5 |`0` |`01111110` |`000...000`
|13 |0.625 |`0` |`01111110` |`010...000`
|14 |0.75 |`0` |`01111110` |`100...000`
|15 |0.875 |`0` |`01111110` |`110...000`
|16 |1.0 |`0` |`01111111` |`000...000`
|17 |1.25 |`0` |`01111111` |`010...000`
|18 |1.5 |`0` |`01111111` |`100...000`
|19 |1.75 |`0` |`01111111` |`110...000`
|20 |2.0 |`0` |`10000000` |`000...000`
|21 |2.5 |`0` |`10000000` |`010...000`
|22 |3 |`0` |`10000000` |`100...000`
|23 |4 |`0` |`10000001` |`000...000`
|24 |8 |`0` |`10000010` |`000...000`
|25 |16 |`0` |`10000011` |`000...000`
|26 |128 (latexmath:[$2^7$]) |`0` |`10000110` |`000...000`
|27 |256 (latexmath:[$2^8$]) |`0` |`10000111` |`000...000`
|28 |latexmath:[$2^{15}$] |`0` |`10001110` |`000...000`
|29 |latexmath:[$2^{16}$] |`0` |`10001111` |`000...000`
|30 |latexmath:[$+\infty$] |`0` |`11111111` |`000...000`
|31 |_Canonical NaN_ |`0` |`11111111` |`100...000`
|===

[TIP]
====
条目 1、30 和 31 的首选汇编语法分别是 min、inf 和 nan。对于条目 0 到 29（包括条目 1），汇编器将接受 C 类语法中的十进制常量。
====
[TIP]
====
这 32 个常量的集合是通过检查浮点库（包括 C 标准数学库）并优化定点到浮点数的转换后选定的。

条目 8 到 22 遵循一个规律的编码模式。没有任何条目会设置除最高有效位之外的尾数位。
====

如果实现了 D 扩展，FLI.D 执行类似的操作，但将双精度浮点值加载到浮点寄存器 _rd_ 中。请注意，条目 1（对应最小正规范值）在双精度中与单精度中的数值不同。FLI.D 的编码方式与 FLI.S 相似，但 _fmt_=D。

如果实现了 Q 扩展，FLI.Q 执行类似的操作，但将四精度浮点值加载到浮点寄存器 _rd_ 中。请注意，条目 1（对应最小正规范值）在四精度中与其他精度中的数值不同。FLI.Q 的编码方式与 FLI.S 相似，但 _fmt_=Q。

如果实现了 Zfh 或 Zvfh 扩展，FLI.H 执行类似的操作，但将半精度浮点值加载到寄存器 _rd_ 中。请注意，条目 1（对应最小正规范值）在半精度中与其他精度中的数值不同。此外，由于 latexmath:[$2^{16}$] 不能在半精度浮点数中表示，表中的条目 29 改为加载正无穷——即，它与条目 30 是冗余的。FLI.H 的编码方式与 FLI.S 相似，但 _fmt_=H。
[NOTE]
====

另外，由于 latexmath:[$2^{-16}$] 和 latexmath:[$2^{-15}$] 在半精度下是次正规数，因此在 FLI.H 中，第 1 项的数值大于第 2 项和第 3 项。
====
FLI.fmt 指令永远不会设置任何浮点异常标志。

=== 最小值和最大值指令

FMINM.S 和 FMAXM.S 指令的定义与 FMIN.S 和 FMAX.S 指令类似，不同之处在于，如果任一输入是 NaN，结果将是规范的 NaN。

如果实现了 D 扩展，FMINM.D 和 FMAXM.D 指令也类似地定义为作用于双精度数。

如果实现了 Zfh 扩展，FMINM.H 和 FMAXM.H 指令也类似地定义为作用于半精度数。

如果实现了 Q 扩展，FMINM.Q 和 FMAXM.Q 指令也类似地定义为作用于四倍精度数。

这些指令的编码方式与 FMIN 和 FMAX 指令相同，只是指令的第 13 位设置为 1。
[NOTE]
====
这些指令实现了 IEEE 754-2019 的最小值和最大值操作。
====
=== 四舍五入到整数指令

FROUND.S 指令将浮点寄存器 rs1 中的单精度浮点数根据指令的 rm 字段指定的舍入模式四舍五入为一个整数。然后，它将该整数作为单精度浮点数写入浮点寄存器 rd。零和无穷大的输入会原样复制到 _rd_ 中。信号 NaN 输入会导致设置无效操作异常标志；不会设置其他异常标志。FROUND.S 的编码方式与 FCVT.S.D 相似，但 _rs2_ = 4。

FROUNDNX.S 指令的定义类似，但如果输入与舍入结果不同并且不是 NaN，它还会设置不精确异常标志。FROUNDNX.S 的编码方式与 FCVT.S.D 相似，但 _rs2_ = 5。

如果实现了 D 扩展，FROUND.D 和 FROUNDNX.D 指令类似地定义为操作双精度浮点数。它们的编码方式与 FCVT.D.S 相似，但 _rs2_ 分别为 4 和 5。

如果实现了 Zfh 扩展，FROUND.H 和 FROUNDNX.H 指令类似地定义为操作半精度浮点数。它们的编码方式与 FCVT.H.S 相似，但 _rs2_ 分别为 4 和 5。

如果实现了 Q 扩展，FROUND.Q 和 FROUNDNX.Q 指令类似地定义为操作四精度浮点数。它们的编码方式与 FCVT.Q.S 相似，但 _rs2_ 分别为 4 和 5。
[NOTE]
====
FROUNDNX.fmt 指令实现了 IEEE 754-2019 的 roundToIntegralExact 操作，而 FROUND.fmt指令实现了 roundToIntegral 系列中的其他操作。
====
=== 模块化向整数转换指令

FCVTMOD.W.D 指令的定义类似于 FCVT.W.D 指令，具有以下不同之处。FCVTMOD.W.D 总是向零舍入。位 31:0 来自舍入后的无界二进制补码结果，然后进行符号扩展至 XLEN 位，并写入整数寄存器 _rd_。latexmath:[$\pm\infty$] 和 NaN 会被转换为零。

浮点异常标志的设置与 FCVT.W.D 指令对相同输入操作数时的设置相同。

只有在实现了 D 扩展时，才提供此指令。其编码方式与 FCVT.W.D 相似，但 _rs2_ 字段设置为 8，_rm_ 字段设置为 1（RTZ）。其他 _rm_ 值是保留的。
[TIP]
====
汇编语法要求显式指定 RTZ 舍入模式，即 `fcvtmod.w.d rd, rs1, rtz`。

FCVTMOD.W.D 指令的添加主要是为了加速 JavaScript 数字的处理。数字是双精度值
，但某些运算符会隐式将其截断为符号整数，模 latexmath:[$2^{32}$]。
====
=== 移动指令

仅对于 RV32，如果实现了 D 扩展，FMVH.X.D 指令将浮点寄存器 _rs1_ 的 63:32 位移动到整数寄存器 _rd_。它在 OP-FP 主操作码中进行编码，_funct3_=0，_rs2_=1，_funct7_=1110001。
[NOTE]
====
FMVH.X.D 指令与现有的 FMV.X.W 指令配合使用，将双精度浮点数移动到一对 x 寄存器中。
====
仅对于 RV32，如果实现了 D 扩展，FMVP.D.X 指令将一对整数寄存器中的双精度数移动到浮点寄存器中。整数寄存器 _rs1_ 和 _rs2_ 分别提供 31:0 位和 63:32 位，结果写入浮点寄存器 _rd_。FMVP.D.X 在 OP-FP 主操作码中进行编码，_funct3_=0，_funct7_=1011001。

仅对于 RV64，如果实现了 Q 扩展，FMVH.X.Q 指令将浮点寄存器 _rs1_ 的 127:64 位移动到整数寄存器 rd。它在 OP-FP 主操作码中进行编码，_funct3_=0，_rs2_=1，_funct7_=1110011。
[NOTE]
====
FMVH.X.Q 指令与现有的 FMV.X.D 指令配合使用，将四倍精度浮点数移动到一对 x 寄存器中。
====

仅对于 RV64，如果实现了 Q 扩展，FMVP.Q.X 指令将一对整数寄存器中的双精度数移动到浮点寄存器中。整数寄存器 _rs1_ 和 _rs2_ 分别提供 63:0 位和 127:64 位，结果写入浮点寄存器 _rd_。FMVP.Q.X 在 OP-FP 主操作码中进行编码，_funct3_=0，_funct7_=1011011。

=== 比较指令

FLEQ.S 和 FLTQ.S 指令的定义类似于 FLE.S 和 FLT.S 指令，不同之处在于，静默 NaN 输入不会导致设置无效操作异常标志。

如果实现了 D 扩展，FLEQ.D 和 FLTQ.D 指令类似地定义为操作双精度浮点数。

如果实现了 Zfh 扩展，FLEQ.H 和 FLTQ.H 指令类似地定义为操作半精度浮点数。

如果实现了 Q 扩展，FLEQ.Q 和 FLTQ.Q 指令类似地定义为操作四精度浮点数。

这些指令的编码方式与它们的 FLE 和 FLT 对应指令相似，但指令位 14 设置为 1。
[NOTE]
====
我们不预计会向矢量 ISA 添加类似的比较指令，因为它们可以通过掩码操作合理高效地模拟。
====
