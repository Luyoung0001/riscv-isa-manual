[[zfa]]
== "Zfa" 扩展：额外浮点指令, 版本 1.0

本章描述了 Zfa 标准扩展，它增加了立即数加载、IEEE 754-2019 最小值和最大值操作、舍入
到整数操作以及安静浮点比较的指令。对于 RV32D，Zfa 扩展还增加了将双精度浮点值在浮点
寄存器和整数寄存器之间传输的指令；对于 RV64Q，它增加了类似的指令，用于四倍精度浮点值。
Zfa 扩展依赖于 F 扩展。

=== 立即数加载指令

FLI.S 指令将编码在 _rs1_ 字段中的 32 个单精度浮点常量之一加载到浮点寄存器 _rd_ 中。_rs1_ 
字段值与单精度浮点值的对应关系如<<tab:flis, Table 37>>所示。FLI.S 的编码方式类似于 
FMV.W.X，但 _rs2_=1。

[[tab:flis]]
.Immediate values loaded by the FLI.S instruction.
[%autowidth,float="center",align="center",cols=">,>,^,^,^",options="header",]
|===
|_rs1_ |Value |Sign |Exponent |Significand
|0 |latexmath:[$-1.0$] |`1` |`01111111` |`000...000`
|1 |_Minimum positive normal_ |`0` |`00000001` |`000...000`
|2 |latexmath:[$1.0 \times 2^{-16}$] |`0` |`01101111` |`000...000`
|3 |latexmath:[$1.0 \times 2^{-15}$] |`0` |`01110000` |`000...000`
|4 |latexmath:[$1.0 \times 2^{-8}$] |`0` |`01110111` |`000...000`
|5 |latexmath:[$1.0 \times 2^{-7}$] |`0` |`01111000` |`000...000`
|6 |0.0625 (latexmath:[$2^{-4}$]) |`0` |`01111011` |`000...000`
|7 |0.125 (latexmath:[$2^{-3}$]) |`0` |`01111100` |`000...000`
|8 |0.25 |`0` |`01111101` |`000...000`
|9 |0.3125 |`0` |`01111101` |`010...000`
|10 |0.375 |`0` |`01111101` |`100...000`
|11 |0.4375 |`0` |`01111101` |`110...000`
|12 |0.5 |`0` |`01111110` |`000...000`
|13 |0.625 |`0` |`01111110` |`010...000`
|14 |0.75 |`0` |`01111110` |`100...000`
|15 |0.875 |`0` |`01111110` |`110...000`
|16 |1.0 |`0` |`01111111` |`000...000`
|17 |1.25 |`0` |`01111111` |`010...000`
|18 |1.5 |`0` |`01111111` |`100...000`
|19 |1.75 |`0` |`01111111` |`110...000`
|20 |2.0 |`0` |`10000000` |`000...000`
|21 |2.5 |`0` |`10000000` |`010...000`
|22 |3 |`0` |`10000000` |`100...000`
|23 |4 |`0` |`10000001` |`000...000`
|24 |8 |`0` |`10000010` |`000...000`
|25 |16 |`0` |`10000011` |`000...000`
|26 |128 (latexmath:[$2^7$]) |`0` |`10000110` |`000...000`
|27 |256 (latexmath:[$2^8$]) |`0` |`10000111` |`000...000`
|28 |latexmath:[$2^{15}$] |`0` |`10001110` |`000...000`
|29 |latexmath:[$2^{16}$] |`0` |`10001111` |`000...000`
|30 |latexmath:[$+\infty$] |`0` |`11111111` |`000...000`
|31 |_Canonical NaN_ |`0` |`11111111` |`100...000`
|===

[TIP]
====
对应关系 1 、 30 和 31 的首选汇编语法分别是 min、inf 和 nan。对于对应 0 到 29（包括
对应 1），汇编器将接受类似 C 语言语法的十进制常量。
====
[TIP]
====
这 32 个常量的集合是通过检查浮点库（包括C标准数学库）并优化定点到浮点的转换来选择的。

对应关系 8-22 遵循规律的编码模式。没有任何对应关系设置除了两个最高有效位以外的尾数位。
====

如果实现了 D 扩展，FLI.D 执行类似操作，但将双精度值加载到浮点寄存器 _rd_ 中。请注意，
对应关系 1（对应最小的正归一化值）对于双精度和单精度的数值是不同的。FLI.D 的编码方式
与 FLI.S 类似，但 _fmt_=D。

如果实现了 Q 扩展，FLI.Q 执行类似操作，但将四倍精度值加载到浮点寄存器 _rd_ 中。请注
意，条目 1（对应最小的正归一化值）对于四倍精度的数值是不同的。FLI.Q 的编码方式与 
FLI.S 类似，但 _fmt_=Q。

如果实现了 Zfh 或 Zvfh 扩展，FLI.H 执行类似操作，但将半精度浮点值加载到寄存器 _rd_ 中。
请注意，条目 1（对应最小的正归一化值）对于半精度的数值是不同的。此外，由于 latexmath:[$2^{16}$]
在半精度浮点数中无法表示，因此表中的对应关系 29 加载的是正无穷大——即，它与对应关系 30 
是冗余的。FLI.H 的编码方式与 FLI.S 类似，但 _fmt_=H。
[NOTE]
====

另外，由于 latexmath:[$2^{-16}$] 和 latexmath:[$2^{-15}$] 在半精度下是次正规数，因此
在 FLI.H 中，第 1 项的数值大于第 2 项和第 3 项。
====
FLI.fmt 指令永远不会设置任何浮点异常标志。

=== 最小值和最大值指令

FMINM.S 和 FMAXM.S 指令的定义与 FMIN.S 和 FMAX.S 指令类似，不同之处在于，如果任一输入是 NaN，
结果将是规范的 NaN。

如果实现了 D 扩展，FMINM.D 和 FMAXM.D 指令也类似地定义为作用于双精度数。

如果实现了 Zfh 扩展，FMINM.H 和 FMAXM.H 指令也类似地定义为作用于半精度数。

如果实现了 Q 扩展，FMINM.Q 和 FMAXM.Q 指令也类似地定义为作用于四倍精度数。

这些指令的编码方式与 FMIN 和 FMAX 指令相同，只是指令的第 13 位设置为 1。
[NOTE]
====
这些指令实现了 IEEE 754-2019 的最小值和最大值操作。
====
=== 四舍五入到整数指令

FROUND.S 指令将浮点寄存器 _rs1_ 中的单精度浮点数四舍五入为整数，四舍五入的方式
根据指令的 _rm_ 字段中指定的舍入模式来决定。然后，它将该整数（以单精度浮点数形式
表示）写入浮点寄存器 _rd_。零和无穷大输入会被原封不动地复制到 _rd_。输入为信号 
NaN 时，会设置无效操作异常标志；不会设置其他异常标志。FROUND.S 的编码方式与 
FCVT.S.D 相同，但 _rs2_ = 4。

FROUNDNX.S 指令的定义类似，但如果输入值与四舍五入结果不同且不是 NaN，它还会设置
不精确异常标志。FROUNDNX.S 的编码方式与 FCVT.S.D 相同，但 _rs2_ = 5。

如果实现了 D 扩展，FROUND.D 和 FROUNDNX.D 指令类似地定义为作用于双精度数。它们
的编码方式与 FCVT.D.S 相同，但 _rs2_ 分别为 4 和 5。

如果实现了 Zfh 扩展，FROUND.H 和 FROUNDNX.H 指令类似地定义为作用于半精度数。它们
的编码方式与 FCVT.H.S 相同，但 _rs2_ 分别为 4 和 5。

如果实现了 Q 扩展，FROUND.Q 和 FROUNDNX.Q 指令类似地定义为作用于四倍精度数。它们
的编码方式与 FCVT.Q.S 相同，但 _rs2_ 分别为 4 和 5。
[NOTE]
====

FROUNDNX.fmt 指令实现了 IEEE 754-2019 的 roundToIntegralExact 操作，而 FROUND.fmt 
指令实现了 roundToIntegral 系列中的其他操作。
====
=== 模块化向整数转换指令

FCVTMOD.W.D 指令的定义类似于 FCVT.W.D 指令，但有以下区别：FCVTMOD.W.D 总是向零舍入。
位 31:0 来自舍入后的无界二进制补码结果，然后进行符号扩展至 XLEN 位，并写入整数寄存器
_rd_。latexmath:[$\pm\infty$] 和 NaN 会被转换为零。

浮点异常标志的设置与 FCVT.W.D 指令在相同输入操作数下的行为一致。

此指令仅在实现了 D 扩展时提供。它的编码方式与 FCVT.W.D 相同，但 _rs2_ 字段设置为 8，
_rm_ 字段设置为 1（RTZ）。其他 _rm_ 值是预留的。
[TIP]
====

汇编语法要求显式指定 RTZ 舍入模式，即 fcvtmod.w.d rd, rs1, rtz。

FCVTMOD.W.D 指令的添加主要是为了加速 JavaScript 数字的处理。数字是双精度值
，但某些运算符会隐式将其截断为符号整数，模 latexmath:[$2^{32}$]。
====
=== Move Instructions
仅对于 RV32，如果实现了 D 扩展，FMVH.X.D 指令将浮点寄存器 _rs1_ 的 63:32 位移动到
整数寄存器 _rd_。它在 OP-FP 主操作码中进行编码，_funct3_=0，_rs2_=1，
_funct7_=1110001。
[NOTE]
====
FMVH.X.D 指令与现有的 FMV.X.W 指令配合使用，将双精度浮点数移动到一对 x 寄存器中。
====
仅对于 RV32，如果实现了 D 扩展，FMVP.D.X 指令将一对整数寄存器中的双精度数移动到
浮点寄存器中。整数寄存器 _rs1_ 和 _rs2_ 分别提供 31:0 位和 63:32 位，结果写入浮
点寄存器 _rd_。FMVP.D.X 在 OP-FP 主操作码中进行编码，_funct3_=0，_funct7_=1011001。

仅对于 RV64，如果实现了 Q 扩展，FMVH.X.Q 指令将浮点寄存器 _rs1_ 的 127:64 位移动到
整数寄存器 rd。它在 OP-FP 主操作码中进行编码，_funct3_=0，_rs2_=1，_funct7_=1110011。
[NOTE]
====

FMVH.X.Q 指令与现有的 FMV.X.D 指令配合使用，将四倍精度浮点数移动到一对 x 寄存器中。

====

仅对于 RV64，如果实现了 Q 扩展，FMVP.Q.X 指令将一对整数寄存器中的双精度数移动到浮点寄存器
中。整数寄存器 _rs1_ 和 _rs2_ 分别提供 63:0 位和 127:64 位，结果写入浮点寄存器 _rd_。
FMVP.Q.X 在 OP-FP 主操作码中进行编码，_funct3_=0，_funct7_=1011011。

=== 比较指令
FLEQ.S 和 FLTQ.S 指令的定义类似于 FLE.S 和 FLT.S 指令，不同之处在于，静默 NaN 输入不会导致
设置无效操作异常标志。

如果实现了 D 扩展，FLEQ.D 和 FLTQ.D 指令类似地定义为作用于双精度数。

如果实现了 Zfh 扩展，FLEQ.H 和 FLTQ.H 指令类似地定义为作用于半精度数。

如果实现了 Q 扩展，FLEQ.Q 和 FLTQ.Q 指令类似地定义为作用于四倍精度数。

这些指令的编码方式与其对应的 FLE 和 FLT 指令相同，只是指令的第 14 位设置为 1。

[NOTE]
====
我们预计不会向向量 ISA 添加类似的比较指令，因为它们可以通过掩码操作高效地模拟。
====
