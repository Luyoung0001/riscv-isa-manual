[[rv32e]]
== RV32E 与 RV64E 基本整数指令集，版本 2.0
本章介绍了为嵌入式系统中微控制器设计的 RV32E 与 RV64E 基本整数指令集提案。RV32E 和 RV64E 分别是 RV32I 和 RV64I 的简化版，唯一的变化是将整数寄存器的数量减少到 16 个。本章概述 RV32E/RV64E 与 RV32I/RV64I 之间的差异，因此建议先阅读 <<rv32>> 和 <<rv64>> 章节，再阅读本章。

(((RV32E, 设计)))
[NOTE]
====
RV32E 的设计目标是为嵌入式微控制器提供更精简的基础核心。对于大型 SoC 设计中的微控制器应用，以及为了减少高度多线程化的 64 位处理器的上下文切换开销，RV64E 也受到了关注。

除非另有说明，与 RV32I 和 RV64I 兼容的标准扩展同样适用于 RV32E 与 RV64E。
====

=== RV32E 与 RV64E 程序员模型
RV32E 与 RV64E 将整数寄存器数量缩减为 16 个通用寄存器（`x0-x15`），其中 `x0` 为专用的零寄存器。

[TIP]
====
我们发现，在小型 RV32I 核心实现中，后半部分的 16 个寄存器约占整个核心的四分之一面积（不包括存储器），因此去除这些寄存器能节省约 25% 的核心面积，同时降低相应的功耗。
====

=== RV32E 与 RV64E 指令集编码
(((RV32E， 与 RV32I 的差异)))
RV32E 和 RV64E 采用与 RV32I 和 RV64I 一致的指令集编码方案，不同之处仅在于仅提供寄存器 `x0-x15`。所有指定其他寄存器（`x16-x31`）的编码均被保留。

[NOTE]
====
本章的早期草案曾将所有使用 `x16-x31` 寄存器的编码划归为自定义指令。而本版本采取了更为保守的策略，选择保留这些编码，以便未来在自定义扩展或新的标准编码之间进行分配。
====
