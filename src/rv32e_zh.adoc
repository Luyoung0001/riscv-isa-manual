[[rv32e]]
== RV32E 和 RV64E 基本整数指令集，第 2.0 版
本章节描述了 RV32E 和 RV64E 基本整数指令集的提案，这些指令集为嵌入式系统中的微控制器设计。RV32E 和 RV64E 是 RV32I 和 RV64I 的简化版，唯一的变化是将整数寄存器的数量减少到 16 个。本章仅概述了 RV32E/RV64E 与 RV32I/RV64I 之间的差异，因此应在阅读 <<rv32>> 和 <<rv64>> 后再阅读本章内容。

(((RV32E, 设计)))
[NOTE]
====
RV32E 旨在为嵌入式微控制器提供一个更小的基础核心。对于大型 SoC 设计中的微控制器，RV64E 也有一定的需求，并且能减少高线程数 64 位处理器的上下文状态。

除非另有说明，兼容 RV32I 和 RV64I 的标准扩展也兼容 RV32E 和 RV64E。
====

=== RV32E 和 RV64E 程序员模型
RV32E 和 RV64E 将整数寄存器数目减少到 16 个通用寄存器（`x0-x15`），其中 `x0` 是一个专用的零寄存器。

[TIP]
====
我们发现，在小型的 RV32I 核心实现中，后半部分的 16 个寄存器大约占用整个核心（不包括存储器）的四分之一面积，因此，去除这些寄存器能节省约 25% 的核心面积，同时降低相应的功耗。
====

=== RV32E 和 RV64E 指令集编码
(((RV32E， 与 RV32I 的差异)))
RV32E 和 RV64E 使用与 RV32I 和 RV64I 相同的指令集编码，唯一的区别是只提供 `x0-x15` 寄存器。所有指定其他寄存器 `x16-x31` 的编码都被保留。

[NOTE]
====
本章的前一个草稿将所有使用 `x16-x31` 寄存器的编码标记为自定义。这一版本采取了更保守的方法，将这些寄存器保留，以便将来在自定义空间或新标准编码之间进行分配。
====
