[[rv32e]]
== RV32E 与 RV64E 基本整数指令集，版本 2.0

本章介绍了为嵌入式系统中微控制器设计的 RV32E 与 RV64E 基本整数指令集提案。RV32E 和 RV64E 分别是 RV32I 和 RV64I 的简化版，具体来说，它们唯一的变化是将整数寄存器的数量减少到 16 个。本章仅概述了 RV32E/RV64E 与 RV32I/RV64I 之间的差异，因此建议在阅读 <<rv32>> 与 <<rv64>> 之后再行阅读本章。

(((RV32E, 设计)))
[NOTE]
====
RV32E 旨在为嵌入式微控制器提供更小的基本核心；得益于它有助于降低高度并发 64 位处理器的上下文状态开销，RV64E 在大型 Soc 设计中的微控制器上也得到了关注。

除非另有说明，兼容 RV32I 和 RV64I 标准的扩展同样适用于 RV32E 与 RV64E。
====

=== RV32E 与 RV64E 程序员模型
RV32E 与 RV64E 将整数寄存器数量缩减为 16 个通用寄存器（`x0-x15`），其中 `x0` 为专用的零寄存器。

[TIP]
====
我们发现，在小型 RV32I 核心实现中，后半部分的 16 个寄存器约占整个核心（不包含存储器）的四分之一面积，因此，去除这些寄存器能节省约 25% 的核心面积，同时相应的降低核心功耗。
====

=== RV32E 与 RV64E 指令集编码
(((RV32E， 与 RV32I 的差异)))
RV32E 和 RV64E 采用与 RV32I 和 RV64I 一致的指令集编码方案，不同之处仅在于仅提供寄存器 `x0-x15`。所有指定其他寄存器（`x16-x31`）的编码均被保留。

[NOTE]
====
本章先前的草案将所有使用 `x16-x31` 寄存器的编码标记为可用的自定义编码；而本版本则采取了更为保守的策略，将这些编码保留，以便将来可以在自定义扩展与新的标准编码之间进行分配。
====
