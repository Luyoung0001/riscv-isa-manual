== “D” 扩展：双精度浮点指令，版本 2.2

本章描述了标准的双精度浮点指令集扩展，称为 "D" 扩展。该扩展添加了符合 IEEE 754-2008 算术标准的双精度浮点计算指令。D 扩展依赖于基础的单精度指令子集 F。
(((double-precision, floating point)))
(((floating point, double precision)))

=== D 寄存器状态

D 扩展将 32 个浮点寄存器 `f0-f31` 扩展到 64 位（<<fprs>> 中的 FLEN=64）。这些 `f` 寄存器现在可以保存 32 位或 64 位浮点值，如下文 <<nanboxing>> 中所描述。

[NOTE]
====
FLEN 可以是 32、64 或 128，具体取决于支持的 F、D 和 Q 扩展。最多可以支持四种不同的浮点精度，包括 H、F、D 和 Q。
====
(((floating-point, supported precisions)))

[[nanboxing]]
=== 较窄值的 NaN 装箱 （NaN Boxing）

当支持多种浮点精度时，较窄的 _n_ 位类型（_n_<FLEN）的有效值会以 NaN 装箱的方式表示在 FLEN 位的 NaN 值的低 _n_ 位中。有效的 NaN 装箱值（NaN-boxed）的高位必须全部为 1。 因此，当以任意更宽的 _m_ 位值（_n_ < _m_ &#8804; FLEN）查看时，合法的 NaN 包装 _n_ 位值会显示为负静默 NaN（qNaN）。任何将较窄结果写入 'f' 寄存器的操作，必须将所有 1 写入最高的 FLEN-_n_ 位，以产生合法的 NaN 包装值。
(((floating-point, requirements)))

[NOTE]
====
软件可能无法知道浮点寄存器中当前存储的数据类型，但必须能够保存和恢复寄存器的值。因此，使用更宽操作传输更窄值的结果必须是明确定义的。一个常见的情况是对于被调用者保存的寄存器，但对于包括可变参数、用户级线程库、虚拟机迁移和调试等功能，标准约定也是必要的。
====

浮点 _n_ 位传输操作将以 IEEE 标准格式保存的外部值传入和传出 `f` 寄存器，包括浮点加载和存储操作（FL__n__/FS__n__）以及浮点移动指令（FMV._n_.X/FMV.X._n_）。将较窄的 _n_ 位值(_n_<FLEN)传输移入 `f` 寄存器时，将创建一个有效的 NaN 装箱值。将较窄的 _n_ 位值从浮点寄存器传出时，将传输寄存器的低 _n_ 位，忽略高 FLEN-_n_ 位。

除了前述的传输操作外，所有其他浮点操作在处理较窄的 __n__ 位操作（n < FLEN）时，会检查输入操作数是否正确地进行了 NaN 装箱，即所有高于 FLEN-_n_ 的位是否为 1。如果是，输入的 _n_ 低位将作为输入值，否则输入值将被视为 _n_ 位标准 NaN。

[TIP]
====
该文档的早期版本没有定义将较窄或较宽操作数的结果输入到操作中的行为，除了要求较宽的操作数保存和恢复时会保留较窄操作数的值。新的定义移除了这一特定实现的行为，同时仍然适应浮点单元的非重新编码和重新编码实现。新的定义还通过在值被错误使用时传播 NaN 来帮助捕捉软件错误。

非重新编码实现会在每次浮点操作的输入和输出时，将操作数解包并打包为 IEEE 标准格式。对于非重新编码实现，NaN 装箱的代价主要在于检查较窄操作的高位是否表示一个合法的 NaN 装箱值，并在结果的高位写入所有 1。

重新编码实现使用更方便的内部格式来表示浮点值，并增加了一个指数位以允许所有值保持标准化。重新编码实现的代价主要是需要额外的标签来跟踪内部类型和符号位，但这可以通过在指数字段内部重新编码 NaN 来完成，而不需要增加新的状态位。传输值进出重新编码格式的流水线需要做一些小的修改，但数据通路和延迟代价最小。无论如何，重新编码过程必须处理宽操作数的输入次正规值的移位，而提取 NaN 装箱值的过程与标准化类似，只是跳过前导 1 位而不是跳过前导 0 位，从而允许共享数据通路的多路选择器。
====

[[fld_fsd]]
=== 双精度加载和存储指令

FLD 指令将双精度浮点值从内存加载到浮点寄存器 _rd_ 中。FSD 指令将浮点寄存器中的双精度值存储到内存。
(((floating point, load and store)))

[NOTE]
====
双精度值可以是一个 NaN 装箱的单精度值。
====

include::images/wavedrom/double-ls.adoc[]
[[double-ls]]
//.双精度加载和存储

只有当有效地址自然对齐且 XLEN&#8805;64 时，FLD 和 FSD 才能保证原子性执行。

FLD 和 FSD 不会修改被传输的位；特别地，非正规 NaN 的有效载荷会被保留。

=== 双精度浮点计算指令

双精度浮点数计算指令的定义与其单精度对应指令类似，但它们操作的是双精度操作数，并生成双精度结果。

include::images/wavedrom/double-fl-compute.adoc[]
[[fl-compute]]
//.双精度浮点计算

=== 双精度浮点转换与移动指令

浮点数到整数和整数到浮点数的转换指令被编码在 OP-FP 主操作码空间中。FCVT.W.D 或 FCVT.L.D 分别将浮点寄存器 _rs1_ 中的双精度浮点数转换为有符号 32 位或 64 位整数，并存储在整数寄存器 _rd_ 中。FCVT.D.W 或 FCVT.D.L 分别将整数寄存器 rs1 中的 32 位或 64 位有符号整数转换为双精度浮点数，并存储在浮点寄存器 _rd_ 中。FCVT.WU.D、FCVT.LU.D、FCVT.D.WU 和 FCVT.D.LU 变体用于在无符号整数值之间进行转换。对于 RV64，FCVT.W[U].D 对 32 位结果进行符号扩展。FCVT.L[U].D 和 FCVT.D.L[U] 是 RV64 专用指令。FCVT._int_.D 的有效输入范围和无效输入的行为与 FCVT._int_.S 相同。
(((floating point, convert and move)))

所有浮点数到整数和整数到浮点数的转换指令都根据 _rm_ 字段进行舍入。请注意，FCVT.D.W[U] 总是产生精确结果，不受舍入模式的影响。

include::images/wavedrom/double-fl-convert-mv.adoc[]
[[fl-convert-mv]]
//.双精度浮点转换和移动

双精度到单精度和单精度到双精度的转换指令，FCVT.S.D 和 FCVT.D.S，编码在 OP-FP 主操作码空间中，源操作数和目标操作数都是浮点寄存器。_rs2_ 字段编码源操作数的数据类型，_fmt_ 字段编码目标操作数的数据类型。FCVT.S.D 根据 RM 字段进行舍入；FCVT.D.S 则从不进行舍入。
(((double-precision, to single-precision)))
(((single-precision, to double-precision )))

include::images/wavedrom/fcvt-sd-ds.adoc[]
[[fcvt-sd-ds]]
//.双精度 FCVT.S.D 和 FCVT.D.S

浮点数到浮点数的符号注入指令，FSGNJ.D、FSGNJN.D 和 FSGNJX.D，定义方式类似于单精度符号注入指令。
//FSGNJ.D、FSGNJN.D 和 FSGNJX.D

include::images/wavedrom/fsjgnjnx-d.adoc[]
//.双精度符号注入

仅对于 XLEN&#8805;64，提供了将位模式在浮点寄存器和整数寄存器之间移动的指令。FMV.X.D 将浮点寄存器 _rs1_ 中的双精度值移动到整数寄存器 _rd_ 中，采用 IEEE 754-2008 标准编码表示。FMV.D.X 将整数寄存器 _rs1_ 中采用 IEEE 754-2008 标准编码的双精度值移动到浮点寄存器 _rd_ 中。

FMV.X.D 和 FMV.D.X 不会修改被传输的位；特别地，非标准 NaN 的有效载荷会被保留。

include::images/wavedrom/d-xwwx.adoc[]
[[fmvxddx]]
//.双精度浮点移动到 _rd_

[TIP]
====
早期版本的 RISC-V 指令集架构（ISA）包含了额外的指令，以允许 RV32 系统在 64 位浮点寄存器的上半部分和下半部分与整数寄存器之间进行传输。然而，这些指令将是唯一具有部分寄存器写入的指令，并且会在实现了重新编码浮点数或寄存器重命名的系统中增加复杂性，需要一个流水线读取-修改-写入的序列。如果它们遵循这种模式，扩展到处理四倍精度的 RV32 和 RV64 系统也需要额外的指令。该 ISA 的定义旨在减少显式的整数与浮点寄存器之间的传输，通过让转换和比较指令将结果写入适当的寄存器文件，因此我们预期这些指令的效益低于其他 ISA。

我们注意到，对于实现了 64 位浮点单元，包括融合乘加（FMA）支持以及 64 位浮点加载和存储的系统，将数据路径从 32 位转换为 64 位整数的数据路径的边际硬件成本较低，并且可以使用支持 32 位宽地址空间和指针的软件 ABI，以避免静态数据和动态内存流量的增长。
====

=== 双精度浮点比较指令

双精度浮点数比较指令的定义与其单精度对应指令类似，但它们操作的是双精度操作数。
(((floating-point, compare)))

include::images/wavedrom/double-fl-compare.adoc[]
[[fl-compare]]
//.双精度浮点比较

=== 双精度浮点分类指令

双精度浮点数分类指令 FCLASS.D 的定义与其单精度对应指令类似，但它操作的是双精度操作数。
(((floating-point, classify)))

include::images/wavedrom/double-fl-class.adoc[]
[[fl-class]]
//.双精度浮点分类
