[[extending]]
== 扩展 RISC-V

除了支持标准的通用软件开发外，RISC-V 的另一个目标是为更专业的指令集扩展或定制加速器提供基础。指令编码空间和可选的可变长度指令编码的设计目的是使构建定制处理器时能够更容易地利用标准 ISA 工具链进行软件开发。例如，RISC-V 旨在继续为仅使用标准 I 基础的实现提供完整的软件支持，同时与多个非标准指令集扩展兼容。

本章介绍了扩展 RISC-V 基础 ISA 的多种方法，并讨论了独立小组开发的指令集扩展的管理方案。本卷仅涉及非特权 ISA，但第二卷中描述的监督级扩展也采用相同的方法与术语。

=== 扩展术语

本节定义了一些描述 RISC-V 扩展的标准术语。

==== 标准扩展与非标准扩展

任何 RISC-V 处理器实现必须支持一个基础整数 ISA（RV32I、RV32E、RV64I、RV64E 或 RV128I）。此外，处理器可以选择支持一个或多个扩展。我们将扩展分为两大类：标准和非标准。

* 标准扩展指那些通常有用，并且在设计上不会与其他标准扩展冲突的扩展。目前，本手册的其他章节中描述的 "MAFDQLCBTPV" 是已完成或计划中的标准扩展。
* 非标准扩展可能具有高度的专业性，并且可能与其他标准或非标准扩展冲突。我们预计，随着时间推移，许多非标准扩展将被开发出来，其中一些可能最终被提升为标准扩展。

==== 指令编码空间和前缀

指令编码空间是指在其中存放基础 ISA 或 ISA 扩展的指令位的区域。RISC-V 支持不同的指令长度，即便在单一指令长度下，也存在多种编码空间大小。例如，基础 ISA 在 30 位编码空间内定义（32 位指令的 31-2 位），而原子扩展 "A" 则适合在 25 位编码空间内（32 位指令的 31-7 位）。

我们使用术语前缀来指代指令编码空间右侧的位（因为 RISC-V 中的指令获取采用小端序，右侧的位存储在较低的内存地址中，因此在指令获取顺序中形成前缀）。标准基础 ISA 编码的前缀是 32 位字中的 1-0 位中的 "11" 字段，而标准原子扩展 "A" 的前缀是 32 位字中 AMO 主操作码的 6-0 位中的 "0101111" 字段。编码格式的一个特点是，3 位 funct3 字段用于编码次操作码，在 32 位指令格式中与主操作码位不连续，但依然被视为 22 位指令空间前缀的一部分。

尽管指令编码空间的大小可以是任意的，采用一组较小的常见大小有助于简化将独立开发的扩展合并到单个全局编码中的过程。<<encodingspaces>> 给出了 RISC-V 建议的编码空间大小。

[[encodingspaces]]
.建议的标准 RISC-V 指令编码空间大小。
[%autowidth,float="center",align="center",cols="^,<,>,>,>,>", options="header"]
|===
|大小 |用途 
4+^| 标准指令长度中可用的数量
| | |16 位 |32 位 |48 位 |64 位

6+|
|14 位 |压缩 16 位编码的象限 |3 | | |

6+|
|22 位 |基础 32 位编码中的次操作码 | |latexmath:[$2^{8}$]
|latexmath:[$2^{20}$] |latexmath:[$2^{35}$]

|25 位 |基础 32 位编码中的主操作码 | |32
|latexmath:[$2^{17}$] |latexmath:[$2^{32}$]

|30 位 |基础 32 位编码的象限 | |1 |latexmath:[$2^{12}$]
|latexmath:[$2^{27}$]

6+|
|32 位 |48 位编码中的次操作码 | | |latexmath:[$2^{10}$]
|latexmath:[$2^{25}$]

|37 位 |48 位编码中的主操作码 | | |32 |latexmath:[$2^{20}$]

|40 位 |48 位编码的象限 | | |4 |latexmath:[$2^{17}$]

6+|
|45 位 |64 位编码中的次次操作码 | | | |latexmath:[$2^{12}$]

|48 位 |64 位编码中的次操作码 | | | |latexmath:[$2^{9}$]

|52 位 |64 位编码中的主操作码 | | | |32
|===

==== 绿地扩展与棕地扩展

我们使用术语绿地扩展（greenfield extension）来描述那些填充新指令编码空间的扩展，因此它们只会在前缀级别引发编码冲突。我们使用术语棕地扩展来描述在已有指令空间内进行的扩展，这些扩展围绕先前定义的编码展开。棕地扩展（brownfield extension）必然与特定的绿地父编码相关，一个绿地父编码可能关联多个棕地扩展。例如，基础 ISA 是 30 位指令空间的绿地编码，而 FDQ 浮点扩展则作为棕地扩展，添加到基础 ISA 30 位编码空间中。

请注意，标准 A 扩展被视为绿地编码，因为它在完整的 32 位基础指令编码的最左侧位置定义了一个新的、之前为空的 25 位编码空间，尽管其标准前缀使其定位于父基础 ISA 的 30 位编码空间内。只需调整其 7 位前缀，即可将 A 扩展移动到不同的 30 位编码空间，这时仅需要关注前缀级别的冲突，而不是编码空间内的冲突。

[[exttax]]
.标准指令集扩展的二维分类。
[cols="^,^,^",options="header",]
[%autowidth, float="center", align="center"]
|===
|           |增加状态           |无新状态
|绿地扩展 |RV32I(30), RV64I(30) |A(25)
|棕地扩展 |F(I), D(F), Q(D)     |M(I)
|===

<<exttax>> 显示了基础和标准扩展在简单二维分类中的位置。一个轴用于区分扩展是绿地扩展还是棕地扩展，另一个轴用于区分扩展是否增加了架构状态。绿地扩展的指令编码空间大小在括号中给出，而棕地扩展则给出其所基于的（绿地或棕地）名称。增加用户级架构状态通常意味着需要对监督级系统或标准调用约定进行更改。

需要注意的是，RV64I 并不是 RV32I 的扩展，而是一个完全独立的基础编码。

==== 标准兼容的全局编码

对于实际的 RISC-V 实现，完整或全局编码必须为每个包含的指令编码空间分配一个唯一且不冲突的前缀。基础和每个标准扩展都已分配标准前缀，确保它们能够在全局编码中共存。

标准兼容的全局编码指的是基础和每个标准扩展都使用其标准前缀的编码。标准兼容的全局编码可以包含与标准扩展不冲突的非标准扩展。如果未包含相关的标准扩展，标准兼容的全局编码依然可以为非标准扩展使用标准前缀。换句话说，标准扩展必须在标准兼容的全局编码中使用其标准前缀，但在其他情况下，其前缀可以重新分配。这些约束使得通用工具链能够支持任何 RISC-V 标准兼容的全局编码的标准子集。

==== 保证的非标准编码空间

为了支持专有定制扩展的开发，标准扩展必须确保永远不会使用编码空间的某些特定部分。

=== RISC-V 扩展设计理念

我们计划通过鼓励扩展开发者在指令编码空间内进行操作，并提供工具将这些扩展打包到标准兼容的全局编码中，从而通过分配唯一前缀来支持大量独立开发的扩展。一些扩展更自然地作为现有扩展的棕地增强，并与其父绿地扩展共享分配的前缀。标准扩展前缀有效避免了核心功能编码中的虚假不兼容，同时也为更多偏门扩展提供了定制打包的灵活性。

这种将 RISC-V 扩展重新打包到不同标准兼容全局编码中的能力可在多种场景下使用。

一种典型用例是开发高度专业化的定制加速器，这些加速器主要用于执行特定应用领域的核心任务。这些加速器通常希望去除除基础整数 ISA 之外的所有功能，仅添加所需的扩展。基础 ISA 的设计旨在对硬件实现的要求最小，其编码仅占用 32 位指令编码空间的一小部分。

另一个用例是为新型指令集扩展构建研究原型。在这种情况下，研究人员可能不希望实现可变长度指令获取单元，因此更倾向于使用简单的 32 位固定宽度指令编码来原型化其扩展。然而，这些扩展可能过于庞大，无法与标准扩展共存于 32 位编码空间内。如果研究工作不需要所有标准扩展，标准兼容的全局编码可以移除未使用的标准扩展，并将其前缀重新分配，放置拟议扩展（proposed extension）到非标准位置，从而简化原型开发。标准工具链仍能支持现有基础和标准扩展，以减少开发时间。一旦扩展通过评估并得到改进，它可以打包进更大的可变长度编码空间，以避免与标准扩展发生冲突。

以下部分介绍了开发具有新指令集扩展实现的逐步策略，这些策略主要适用于高度定制、教育或实验架构，而不是 RISC-V ISA 开发的主流路径。

[[fix32b]]
=== 固定宽度 32 位指令格式内的扩展

本节讨论仅支持基础固定宽度 32 位指令格式的实现的扩展。
[NOTE]
====
我们预计，最简单的 32 位固定宽度编码将受到许多受限加速器和研究原型的广泛应用。
====
==== 可用的 30 位指令编码空间

在标准编码中，三个可用的 30 位指令编码空间（前缀为 `00`、`01` 和 `10` 的 2 位）被保留用于启用可选的压缩指令扩展。然而，如果不需要压缩指令集扩展，这三个 30 位编码空间将变为可用空间，从而使得 32 位格式中的可用编码空间增加了四倍。

==== 可用的 25 位指令编码空间

25 位指令编码空间对应于基础和标准扩展编码中的主操作码。

有四个明确保留用于自定义扩展的主操作码 <<opcodemap>>，每个代表一个 25 位编码空间。两个主操作码保留给 RV128 基础编码使用（分别是 OP-IMM-64 和 OP-64），但在 RV32 和 RV64 的非标准扩展中也可以使用。

为 RV64 保留的两个主操作码（OP-IMM-32 和 OP-32）同样可以用于 RV32 的非标准扩展。

如果实现中不需要浮点功能，可以重新使用为标准浮点扩展保留的七个主操作码（LOAD-FP、STORE-FP、MADD、MSUB、NMSUB、NMADD、OP-FP）。同样，如果不需要标准原子扩展，也可以重新使用 AMO 主操作码。

如果实现不需要超过 32 位的指令，可以使用另外四个主操作码（在 <<opcodemap>> 中标记为灰色）。

基础 RV32I 编码使用 11 个主操作码和 3 个保留操作码，最多有 18 个主操作码可供扩展使用。基础 RV64I 编码使用 13 个主操作码和 3 个保留操作码，最多有 16 个主操作码可供扩展使用。

==== 可用的 22 位指令编码空间

22 位编码空间对应于基础和标准扩展编码中的 funct3 次操作码空间。若干主操作码的 funct3 字段未完全占用，导致有多个可用的 22 位编码空间。

通常，主操作码用于在指令的其他位中编码操作数格式，扩展应遵循主操作码的操作数格式，这样可以简化硬件解码过程。

==== 其他空间

在某些主操作码下，编码空间较为有限，且并非所有次操作码都完全填充这些空间。

=== 添加对齐的 64 位指令扩展

为扩展提供空间的最简单方式是添加自然对齐的 64 位指令，这些指令对于基础的 32 位固定宽度指令格式过大。实现仍然需要支持 32 位基础指令格式，但可以要求 64 位指令按照 64 位边界对齐，以简化指令获取，必要时可使用 32 位 NOP 指令进行对齐填充。

为了简化标准工具的使用，64 位指令应按 <<instlengthcode, Table 1>> 中规定的方式进行编码。然而，某些实现可以选择非标准的 64 位指令长度编码，同时保留 32 位指令的标准编码。例如，如果不需要压缩指令，可以通过在指令的前两位中设置零位来编码 64 位指令。
[NOTE]
====
我们预计处理器生成器将生成能够自动处理所有支持的可变长度指令编码组合的指令获取单元。
====
=== 支持 VLIW 编码

虽然 RISC-V 不是专为纯 VLIW 机器设计，但可以通过几种替代方法将 VLIW 编码作为扩展添加。在所有实现中，都必须支持基础的 32 位编码，以便能够使用标准软件工具。

==== 固定大小的指令组

最简单的方式是定义一个自然对齐的大指令格式（例如 128 位），用于编码 VLIW 操作。在传统的 VLIW 设计中，这种方法可能会浪费指令内存来存储 NOP，但在 RISC-V 兼容实现中，必须支持基础 32 位指令，这将 VLIW 代码的大小限制在加速函数的范围内。

==== 编码长度组

另一种方式是利用 <<instlengthcode>> 中的标准长度编码来表示并行指令组，从而压缩 VLIW 指令中的 NOP。例如，64 位指令可以包含两个 28 位操作，96 位指令可以包含三个 28 位操作等；或者，48 位指令可以包含一个 42 位操作，96 位指令可以包含两个 42 位操作等。

此方法的优点是保留了包含单一操作的基础 ISA 编码，但缺点是需要为 VLIW 指令中的操作引入新的 28 位或 42 位编码，且较大指令组的获取可能未对齐。可以采取一种简化方法，避免 VLIW 指令跨越一些微架构中的关键边界（如缓存行或虚拟内存页）。

==== 固定大小的指令包

另一种方法，类似于 Itanium，采用更大且自然对齐的固定指令包（例如 128 位）来编码并行操作组。此方法简化了指令获取，但将复杂性转移到组执行引擎（group execution engine）。为了保持 RISC-V 兼容，必须支持基础 32 位指令。

==== 前缀中的组结束位

上述方法未能保留 VLIW 指令中单个操作的 RISC-V 编码。另一种方法是重新利用固定宽度 32 位编码中的两个前缀位：一个用于指示“组结束（end-of-group）”（如果设置），另一个用于指示是否在谓词控制下执行（如果清除）。由不支持 VLIW 扩展的工具生成的标准 RISC-V 32 位指令将同时设置这两个前缀位（11），因此它们具备正确的语义——每个指令在组结束时且不受谓词控制。

这种方法的缺点是，基础 ISA 并未提供激进 VLIW 系统中常见的复杂谓词支持，且在标准 30 位编码空间中，难以扩展以支持更多谓词寄存器的指定。

