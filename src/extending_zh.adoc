[[extending]]
== 扩展 RISC-V

除了支持标准的通用软件开发，RISC-V 的另一个目标是为更专业的指令集扩展或更定制化的加速器提供基础。指令编码空间和可选的可变长度指令编码旨在使构建更定制化的处理器时更容易利用标准 ISA 工具链的软件开发工作。例如，目的是继续为仅使用标准 I 基础的实现提供完整的软件支持，可能与许多非标准指令集扩展一起使用。

本章描述了扩展 RISC-V 基础 ISA 的各种方法，以及独立小组开发的指令集扩展的管理方案。本卷仅涉及非特权 ISA，尽管第二卷中描述的监督级扩展也使用相同的方法和术语。

=== 扩展术语

本节定义了一些描述 RISC-V 扩展的标准术语。

==== 标准扩展与非标准扩展

任何 RISC-V 处理器实现必须支持一个基础整数 ISA（RV32I、RV32E、RV64I、RV64E 或 RV128I）。此外，实现可以支持一个或多个扩展。我们将扩展分为两大类：_标准_ 与 _非标准_。

* 标准扩展是指通常有用且设计上不与任何其他标准扩展冲突的扩展。目前，本手册其他章节中描述的 "MAFDQLCBTPV" 是已完成或计划中的标准扩展。
* 非标准扩展可能高度专业化，并且可能与其他标准或非标准扩展冲突。我们预计随着时间的推移会开发出各种非标准扩展，其中一些最终会被提升为标准扩展。

==== 指令编码空间和前缀

指令编码空间是指在其中编码基础 ISA 或 ISA 扩展的某些指令位。RISC-V 支持不同的指令长度，但即使在单一指令长度内，也有各种大小的编码空间可用。例如，基础 ISA 在 30 位编码空间内定义（32 位指令的 31-2 位），而原子扩展 "A" 适合在 25 位编码空间内（32 位指令的 31-7 位）。

我们使用术语 _前缀_ 来指代指令编码空间右侧的位（由于 RISC-V 中的指令获取是小端序，右侧的位存储在较早的内存地址中，因此在指令获取顺序中形成前缀）。标准基础 ISA 编码的前缀是 32 位字的 1-0 位中的两位 "11" 字段，而标准原子扩展 "A" 的前缀是 32 位字中表示 AMO 主操作码的 6-0 位中的七位 "0101111" 字段。编码格式的一个特点是，用于编码次操作码的 3 位 funct3 字段在 32 位指令格式中与主操作码位不连续，但被视为 22 位指令空间的前缀的一部分。

尽管指令编码空间可以是任何大小，但采用一组较小的常见大小简化了将独立开发的扩展打包到单个全局编码中的过程。<<encodingspaces>> 给出了 RISC-V 的建议大小。

[[encodingspaces]]
.建议的标准 RISC-V 指令编码空间大小。
[%autowidth,float="center",align="center",cols="^,<,>,>,>,>", options="header"]
|===
|大小 |用途 
4+^| 标准指令长度中可用的数量
| | |16 位 |32 位 |48 位 |64 位

6+|
|14 位 |压缩 16 位编码的象限 |3 | | |

6+|
|22 位 |基础 32 位编码中的次操作码 | |latexmath:[$2^{8}$]
|latexmath:[$2^{20}$] |latexmath:[$2^{35}$]

|25 位 |基础 32 位编码中的主操作码 | |32
|latexmath:[$2^{17}$] |latexmath:[$2^{32}$]

|30 位 |基础 32 位编码的象限 | |1 |latexmath:[$2^{12}$]
|latexmath:[$2^{27}$]

6+|
|32 位 |48 位编码中的次操作码 | | |latexmath:[$2^{10}$]
|latexmath:[$2^{25}$]

|37 位 |48 位编码中的主操作码 | | |32 |latexmath:[$2^{20}$]

|40 位 |48 位编码的象限 | | |4 |latexmath:[$2^{17}$]

6+|
|45 位 |64 位编码中的次次操作码 | | | |latexmath:[$2^{12}$]

|48 位 |64 位编码中的次操作码 | | | |latexmath:[$2^{9}$]

|52 位 |64 位编码中的主操作码 | | | |32
|===

==== 绿地扩展与棕地扩展

我们使用术语 _绿地扩展_ 来描述开始填充新指令编码空间的扩展，因此只能在前缀级别引起编码冲突。我们使用术语 _棕地扩展_ 来描述围绕先前定义的指令空间中的现有编码进行的扩展。棕地扩展必然与特定的绿地父编码相关，并且可能有多个棕地扩展与同一个绿地父编码相关。例如，基础 ISA 是 30 位指令空间的绿地编码，而 FDQ 浮点扩展都是添加到父基础 ISA 30 位编码空间的棕地扩展。

请注意，我们认为标准 A 扩展具有绿地编码，因为它在完整的 32 位基础指令编码的最左边位中定义了一个新的先前为空的 25 位编码空间，尽管其标准前缀将其定位在其父基础 ISA 的 30 位编码空间内。仅更改其单个 7 位前缀即可将 A 扩展移动到不同的 30 位编码空间，同时只需担心前缀级别的冲突，而不是编码空间内的冲突。

[[exttax]]
.标准指令集扩展的二维分类。
[cols="^,^,^",options="header",]
[%autowidth, float="center", align="center"]
|===
|           |增加状态           |无新状态
|绿地扩展 |RV32I(30), RV64I(30) |A(25)
|棕地扩展 |F(I), D(F), Q(D)     |M(I)
|===

<<exttax>> 显示了基础和标准扩展在简单二维分类中的位置。一个轴是扩展是绿地还是棕地，另一个轴是扩展是否增加了架构状态。对于绿地扩展，指令编码空间的大小在括号中给出。对于棕地扩展，扩展所基于的（绿地或棕地）名称在括号中给出。增加用户级架构状态通常意味着对监督级系统或标准调用约定的更改。

请注意，RV64I 不被视为 RV32I 的扩展，而是不同的完整基础编码。

==== 标准兼容的全局编码

实际 RISC-V 实现的完整或 _全局_ 编码必须为每个包含的指令编码空间分配一个唯一的不冲突前缀。基础和每个标准扩展都已分配了标准前缀，以确保它们都可以在全局编码中共存。

_标准兼容_ 的全局编码是指基础和每个包含的标准扩展都使用其标准前缀的编码。标准兼容的全局编码可以包含与包含的标准扩展不冲突的非标准扩展。如果未包含相关的标准扩展，标准兼容的全局编码也可以将标准前缀用于非标准扩展。换句话说，标准扩展在标准兼容的全局编码中必须使用其标准前缀，但在其他情况下，其前缀可以重新分配。这些约束允许通用工具链针对任何 RISC-V 标准兼容的全局编码的标准子集。

==== 保证的非标准编码空间

为了支持专有定制扩展的开发，保证标准扩展永远不会使用编码空间的某些部分。

=== RISC-V 扩展设计理念

我们打算通过鼓励扩展开发者在指令编码空间内操作，并提供工具将这些扩展打包到标准兼容的全局编码中，通过分配唯一前缀来支持大量独立开发的扩展。一些扩展更自然地实现为现有扩展的棕地增强，并将共享分配给其父绿地扩展的前缀。标准扩展前缀避免了核心功能编码中的虚假不兼容，同时允许更偏门扩展的定制打包。

这种将 RISC-V 扩展重新打包到不同标准兼容全局编码中的能力可以以多种方式使用。

一种用例是开发高度专业化的定制加速器，旨在运行重要应用领域的内核。这些可能希望删除除基础整数 ISA 之外的所有内容，并仅添加任务所需的扩展。基础 ISA 设计的目的是对硬件实现的要求最小，并且编码仅使用 32 位指令编码空间的一小部分。

另一种用例是为新型指令集扩展构建研究原型。研究人员可能不希望花费精力实现可变长度指令获取单元，因此希望使用简单的 32 位固定宽度指令编码来原型化其扩展。然而，这种新扩展可能太大，无法与 32 位空间中的标准扩展共存。如果研究实验不需要所有标准扩展，标准兼容的全局编码可能会删除未使用的标准扩展，并重新使用其前缀将拟议的扩展放置在非标准位置，以简化研究原型的工程。标准工具仍然能够针对存在的基础和任何标准扩展，以减少开发时间。一旦评估和改进了指令集扩展，它可以打包到更大的可变长度编码空间中，以避免与所有标准扩展的冲突。

以下部分描述了开发具有新指令集扩展的实现的越来越复杂的策略。这些主要用于高度定制、教育或实验架构，而不是 RISC-V ISA 开发的主线。

[[fix32b]]
=== 固定宽度 32 位指令格式内的扩展

本节讨论仅支持基础固定宽度 32 位指令格式的实现的扩展。
[NOTE]
====
我们预计最简单的固定宽度 32 位编码将受到许多受限加速器和研究原型的欢迎。
====
==== 可用的 30 位指令编码空间

在标准编码中，三个可用的 30 位指令编码空间（前缀为 `00`、`01` 和 `10` 的 2 位）用于启用可选的压缩指令扩展。然而，如果不需要压缩指令集扩展，则这三个 30 位编码空间将变得可用。这使得 32 位格式中的可用编码空间增加了四倍。

==== 可用的 25 位指令编码空间

25 位指令编码空间对应于基础和标准扩展编码中的主操作码。

有四个明确指定用于自定义扩展的主操作码 <<opcodemap>>，每个代表一个 25 位编码空间。其中两个保留供 RV128 基础编码最终使用（将是 OP-IMM-64 和 OP-64），但可以用于 RV32 和 RV64 的非标准扩展。

保留给 RV64 的两个主操作码（OP-IMM-32 和 OP-32）也可以用于 RV32 的非标准扩展。

如果实现不需要浮点，则可以重新使用为标准浮点扩展保留的七个主操作码（LOAD-FP、STORE-FP、MADD、MSUB、NMSUB、NMADD、OP-FP）。同样，如果不需要标准原子扩展，则可以重新使用 AMO 主操作码。

如果实现不需要超过 32 位的指令，则可以使用另外四个主操作码（在 <<opcodemap>> 中标记为灰色的那些）。

基础 RV32I 编码仅使用 11 个主操作码加 3 个保留操作码，留下多达 18 个可用于扩展。基础 RV64I 编码仅使用 13 个主操作码加 3 个保留操作码，留下多达 16 个可用于扩展。

==== 可用的 22 位指令编码空间

22 位编码空间对应于基础和标准扩展编码中的 funct3 次操作码空间。几个主操作码有一个未完全占用的 funct3 字段次操作码，留下几个可用的 22 位编码空间。

通常，主操作码选择用于在指令的其余位中编码操作数的格式，理想情况下，扩展应遵循主操作码的操作数格式，以简化硬件解码。

==== 其他空间

在某些主操作码下有较小的空间，并且并非所有次操作码都完全填充。

=== 添加对齐的 64 位指令扩展

为扩展提供空间的最简单方法是添加自然对齐的 64 位指令，这些扩展对于基础 32 位固定宽度指令格式来说太大。实现仍然必须支持 32 位基础指令格式，但可以要求 64 位指令在 64 位边界上对齐，以简化指令获取，必要时使用 32 位 NOP 指令作为对齐填充。

为了简化标准工具的使用，64 位指令应按 <<instlengthcode, 表 1>> 中描述的方式编码。
然而，实现可能会选择 64 位指令的非标准指令长度编码，同时保留 32 位指令的标准编码。例如，如果不需要压缩指令，则可以使用指令的前两位中的一个或多个零位来编码 64 位指令。
[NOTE]
====
我们预计处理器生成器将生成能够自动处理任何支持的可变长度指令编码组合的指令获取单元。
====
=== 支持 VLIW 编码

尽管 RISC-V 不是为纯 VLIW 机器设计的，但可以使用几种替代方法将 VLIW 编码添加为扩展。在所有情况下，都必须支持基础 32 位编码，以允许使用任何标准软件工具。

==== 固定大小的指令组

最简单的方法是定义一个自然对齐的大指令格式（例如 128 位），在其中编码 VLIW 操作。在传统 VLIW 中，这种方法往往会浪费指令内存来保存 NOP，但 RISC-V 兼容实现还必须支持基础 32 位指令，将 VLIW 代码大小扩展限制在 VLIW 加速的函数中。

==== 编码长度组

另一种方法是使用 <<instlengthcode>> 中的标准长度编码来编码并行指令组，允许压缩 VLIW 指令中的 NOP。例如，64 位指令可以包含两个 28 位操作，而 96 位指令可以包含三个 28 位操作，等等。或者，48 位指令可以包含一个 42 位操作，而 96 位指令可以包含两个 42 位操作，等等。

这种方法的优点是保留了包含单个操作的指令的基础 ISA 编码，但缺点是需要为 VLIW 指令中的操作引入新的 28 位或 42 位编码，并且较大组的指令获取未对齐。一个简化方法是不允许 VLIW 指令跨越某些微架构上重要的边界（例如缓存行或虚拟内存页）。

==== 固定大小的指令包

另一种方法，类似于 Itanium，是使用更大的自然对齐固定指令包大小（例如 128 位），在其中编码并行操作组。这简化了指令获取，但将复杂性转移到组执行引擎。为了保持 RISC-V 兼容，仍然必须支持基础 32 位指令。

==== 前缀中的组结束位

上述方法都没有保留 VLIW 指令中单个操作的 RISC-V 编码。另一种方法是重新利用固定宽度 32 位编码中的两个前缀位。一个前缀位可以用于指示 "组结束"（如果设置），而第二个位可以指示在谓词下执行（如果清除）。由不了解 VLIW 扩展的工具生成的标准 RISC-V 32 位指令将同时设置两个前缀位（11），因此具有正确的语义，每个指令在组结束时且不受谓词控制。

这种方法的主要缺点是基础 ISA 缺乏通常在激进 VLIW 系统中所需的复杂谓词支持，并且在标准 30 位编码空间中很难增加指定更多谓词寄存器的空间。

