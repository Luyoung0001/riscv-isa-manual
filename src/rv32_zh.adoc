[[rv32]]
== RV32I 基本整数指令集，版本 2.1

本章描述了 RV32I 基本整数指令集。

[TIP]
====
RV32I 的设计旨在足以作为编译器的目标架构，并支持现代操作系统环境。该指令集架构（ISA）还专门设计为减少最小实现所需的硬件资源。RV32I 包含 40 条独特的指令，尽管在一个简单的实现中，可能通过一个始终触发陷阱的 SYSTEM 硬件指令来替代 ECALL/EBREAK 指令，并且可能将 FENCE 指令实现为 NOP（无操作指令），从而将基础指令总数减少到 38 条。RV32I 可以模拟几乎所有其他 ISA 扩展（除了 A 扩展，它需要额外的硬件支持以保证原子性）。

实际上，包括机器模式特权架构的硬件实现还需要额外的 6 条 CSR 指令。

基础整数 ISA 的子集可能在教学中有所帮助，但由于基础架构的设计，实际硬件实现中几乎没有必要进一步精简指令集，除非是去掉对不对齐内存访问的支持，或者将所有 SYSTEM 指令统一视为一个陷阱指令。
====

[NOTE]
====
标准的 RISC-V 汇编语言语法已在《汇编程序员手册》中进行详细说明 cite:[riscv-asm-manual]。
====

[NOTE]
====
大部分关于 RV32I 的说明同样适用于 RV64I 基础指令集。
====

=== 基本整数 ISA 的程序员模型

<<gprs>> 描述了非特权基本整数 ISA 的状态。对 RV32I 而言，32 个 `x` 寄存器每个都是 32 位宽，也就是 `XLEN=32`。寄存器 `x0` 的所有位都硬连线到 0。
各种指令将会把通用寄存器 `x1-x31` 保存的值解释为布尔值集合或二进制补码有符号整数或无符号二进制整数。

<<gprs>> 说明了基础整数 ISA 的非特权状态。对于 RV32I，32 个 `x` 寄存器每个宽度为 32 位，即 XLEN=32。寄存器 `x0` 硬连接为全零。通用寄存器 `x1-x31` 存储不同指令解释的值，这些值可以是布尔值的集合、二进制补码有符号整数或二进制无符号整数。

还有一个额外的非特权寄存器：程序计数器 `pc` 存储当前指令的地址。

[[gprs]]
.RISC-V 基本非特权整数寄存器状态。
[cols="<,^,>",options="header",width="50%",align="center",grid="rows"]
|===
<| [.small]#XLEN-1#| >| [.small]#0#
3+^| [.small]#x0/zero#
3+^| [.small]#x1#
3+^| [.small]#x2#
3+^| [.small]#x3#
3+^| [.small]#x4#
3+^| [.small]#x5#
3+^| [.small]#x6#
3+^| [.small]#x7#
3+^| [.small]#x8#
3+^| [.small]#x9#
3+^| [.small]#x10#
3+^| [.small]#x11#
3+^| [.small]#x12#
3+^| [.small]#x13#
3+^| [.small]#x14#
3+^| [.small]#x15#
3+^| [.small]#x16#
3+^| [.small]#x17#
3+^| [.small]#x18#
3+^| [.small]#x19#
3+^| [.small]#x20#
3+^| [.small]#x21#
3+^| [.small]#x22#
3+^| [.small]#x23#
3+^| [.small]#x24#
3+^| [.small]#x25#
3+^| [.small]#x26#
3+^| [.small]#x27#
3+^| [.small]#x28#
3+^| [.small]#x29#
3+^| [.small]#x30#
3+^| [.small]#x31#
3+^| [.small]#XLEN#
| [.small]#XLEN-1#| >| [.small]#0#
3+^|  [.small]#pc#
3+^| [.small]#XLEN#
|===
[NOTE]
====
在基本整数 ISA 中，没有专门的栈指针或子程序返回地址链接寄存器；指令编码允许任何 `x` 寄存器用于这些目的。然而，标准的软件调用约定使用寄存器 `x1` 来保存调用的返回地址，同时寄存器 `x5` 可作为备用的链接寄存器。标准调用约定还使用寄存器 `x2` 作为栈指针。

硬件可以选择使用 `x1` 或 `x5` 来加速函数调用和返回的操作。具体请参见 JAL 和 JALR 指令的描述。

可选的压缩 16 位指令格式是基于假设 `x1` 是返回地址寄存器，`x2` 是栈指针寄存器来设计的。使用其他约定的软件仍然可以正常运行，但可能会导致更大的代码大小。

可用的体系结构寄存器数量对代码大小、性能和能耗有很大影响。虽然 16 个寄存器可以足够支持运行已编译代码的整数 ISA，但在 16 位指令中使用三地址格式来编码完整的 ISA 是不可能的。虽然两地址格式是可行的，但会增加指令数量并降低效率。我们希望避免中间指令大小（如 Xtensa 的 24 位指令），以简化基础硬件实现，并且一旦采用了 32 位指令大小，支持 32 个整数寄存器变得相对容易实现。更多的整数寄存器还有助于高性能代码的执行，在这类代码中，循环展开、软件流水线和缓存切片的使用非常广泛。

出于这些考虑，我们为 RV32I 选择了 32 个整数寄存器的传统配置。动态寄存器的使用通常由少数频繁访问的寄存器主导，因此寄存器文件实现可以通过优化，减少频繁访问寄存器的访问能耗 cite:[jtseng:sbbci]。可选的压缩 16 位指令格式主要访问 8 个寄存器，因此可以提供高效的指令编码；而如果需要，额外的指令集扩展可以支持更大规模的寄存器空间（无论是扁平式还是分层式）。

对于资源受限的嵌入式应用，我们定义了 RV32E 子集（<<rv32e>>），该子集仅包含 16 个寄存器。 。
====
=== 基本指令格式
在基础的 RV32I ISA 中，有四种核心指令格式（R/I/S/U），如 <<base_instr>> 所示。所有指令的长度都是固定的 32 位。基本 ISA 的 `IALIGN=32`，这意味着指令必须在内存中按照四字节边界对齐。如果目标地址未按 `IALIGN-bit` 对齐，在发生分支或无条件跳转时，将生成指令地址未对齐异常。此异常会在分支或跳转指令上报告，而不是在目标指令上报告。对于未被执行的条件分支，不会生成指令地址未对齐异常。

[NOTE]
====
当添加了长度为 16 位的指令扩展或其他 16 位倍数的扩展（即 IALIGN=16）时，基础指令集的对齐约束放宽为两字节边界。

指令地址未对齐异常会在导致指令未对齐的分支或跳转指令上报告，以帮助调试，并简化硬件设计，特别是对于 IALIGN=32 的系统，在这些系统中只有在分支或跳转指令处才可能发生未对齐情况。
====

解码保留指令时的行为是 UNSPECIFIED 的。

[NOTE]
====
有些平台可能要求为标准用途保留的操作码触发非法指令异常。其他平台则可能允许保留的操作码空间用于非符合规范的扩展。
====

RISC-V ISA 在所有格式中保持源（_rs1_ 和 _rs2_）和目标（_rd_）寄存器在同一个位置以简化解码。除了在 CSR 指令（<<csrinsts>>）中使用的 5 位立即数外，其他立即数均采用符号扩展，并且通常被紧凑地放置在指令中最左侧可用的比特位置，以降低硬件复杂性。特别地，所有立即数的符号位总是在指令的第 31 位，以加速符号扩展电路。

include::images/wavedrom/instruction_formats.adoc[] 
[[base_instr,基本指令格式]]
RISC-V 基本指令格式：每个立即数子字段的标注方式是使用其在最终生成的立即数值中的比特位置（imm[x]），而不是通常采用的指令中立即数字段内的比特位置。

[NOTE]
====
在处理器实现中，寄存器标识符的解码通常位于关键路径上，因此 RISC-V 选择在所有指令格式中保持寄存器标识符的位置一致，尽管这需要在不同指令格式之间重新排列立即数的比特位置（这一特性与 RISC-IV 相同，即 SPUR cite:[spur-jsscc1989]）。

实际上，大多数立即数要么很小，要么需要所有 XLEN 位。我们选择了一种非对称的立即数拆分方案（指令使用 12 位立即数，另外提供一条特殊的加载高位立即数指令，支持 20 位立即数）以增加常规指令可用的操作码空间。

所有立即数均采用符号扩展，因为我们未发现像 MIPS ISA 那样对某些立即数使用零扩展的优势，并希望尽可能简化指令集架构 (ISA)。
====

=== 立即数编码变体

根据立即数的处理方式，指令格式还有另外两种变体（B 型和 J 型），如 <<baseinstformatsimm>> 所示。

include::images/wavedrom/immediate_variants.adoc[] 
[[baseinstformatsimm,基本指令格式的立即数变体。]]
//.描述 RISC-V 基本指令格式的立即数变体。


S 型格式和 B 型格式之间的唯一区别在于，在 B 型格式中，12 位立即数字段用于编码以 2 为倍数的分支偏移量。与传统做法（在硬件中将指令编码的立即数整体左移一位）不同，在 B 型格式中，中间比特位（imm[10:1]）和符号位保持在固定位置，同时 S 型格式的最低位（inst[7]）被用作 B 型格式立即数的高位比特。

类似地，U 型格式和 J 型格式的唯一区别在于，20 位立即数在 U 型格式中左移 12 位形成 U 型立即数，而在 J 型格式中左移 1 位形成 J 型立即数。U 型和 J 型格式中的指令比特位置经过优化，以最大程度地与其他格式对齐，并提高它们之间的一致性。

<<immtypes>> 描述了每个基本指令格式生成的立即数，并标注了每个位的来源，即指令中的哪个比特位（inst[_y_]）对应于立即数的哪一位。
[[immtypes, 立即数类型]]
.RISC-V 指令生成的立即数类型。 
include::images/wavedrom/immediate.adoc[]

这些字段标注了用于构造其值的指令比特。符号扩展始终使用 inst[31]。

[NOTE]
====
符号扩展是立即数处理中最关键的操作之一（尤其是在 XLEN > 32 的情况下）。在 RISC-V 中，所有立即数的符号位始终固定在指令的第 31 位，以便在指令解码的同时并行执行符号扩展。

尽管更复杂的实现可能会为分支和跳转计算分别使用独立的加法器，因此不需要在所有指令类型中保持立即数字段位置一致，但我们希望降低最简单实现的硬件成本。通过在 B 型和 J 型立即数的指令编码中旋转比特，而不是使用动态硬件多路复用器（MUX）将立即数乘以 2，我们成功将指令信号的扇出（fanout）和立即数 MUX 的成本降低了大约 2 倍。这种重新排列的立即数编码对静态编译或提前编译（ahead-of-time compilation）的影响可以忽略不计。对于动态指令生成，可能会引入一些额外的开销，但最常见的短距离前向分支具有直观的立即数编码，因此额外开销很小。
====

=== 整数计算指令

大多数整数计算指令操作整数寄存器堆中 `XLEN` 位的值。整数计算指令要么被编码为使用 I 类型格式的寄存器-立即数操作，要么被编码为使用 R 类型格式的寄存器-寄存器操作。寄存器-立即数和寄存器-寄存器指令的目标都是寄存器 _rd_。整数计算指令不会引发算术异常。

大多数整数计算指令对 `XLEN` 位的值进行操作，这些值存储在整数寄存器文件中。整数计算指令要么采用 I 型格式（寄存器-立即数运算），要么采用 R 型格式（寄存器-寄存器运算）。无论是寄存器-立即数指令还是寄存器-寄存器指令，目标寄存器均为 _rd_。所有整数计算指令都不会引发算术异常。

[TIP]
====
我们在基础指令集中未包含专门用于整数算术运算溢出检查的指令支持，因为在 RISC-V 中，许多溢出检查可以通过分支指令以较低成本实现。对于无符号加法，溢出检查仅需在加法运算后添加一条额外的分支指令：`add t0, t1, t2; bltu t0, t1, overflow`。

对于有符号加法，如果其中一个操作数的符号已知，溢出检查仅需在加法后添加一条分支指令：`addi t0, t1, +imm; blt t0, t1, overflow`。这涵盖了加立即数这一常见情况。

对于一般的有符号加法，溢出检查需要在加法后额外执行三条指令，利用的原理是：当且仅当另一个操作数为负数时，和应小于其中一个操作数。

[source,text]
....
         add t0, t1, t2
         slti t3, t2, 0
         slt t4, t0, t1
         bne t3, t4, overflow
....

在 RV64I 中，可以通过比较操作数在 ADD 和 ADDW 指令下的结果，进一步优化对 32 位有符号加法 的溢出检查。
====

==== 整数寄存器-立即数指令

include::images/wavedrom/integer_computational.adoc[]
//.整数计算指令

`ADDI` 指令对寄存器 _rs1_ 的值与符号扩展的 12 位立即数进行加法运算。算术溢出被忽略，结果仅保留低 XLEN 位。ADDI _rd, rs1, 0_ 用于实现汇编伪指令 MV _rd, rs1_。

`SLTI`（Set Less Than Immediate）指令比较寄存器 _rs1_ 与符号扩展的立即数（均视为有符号数），如果 _rs1_ 小于该立即数，则将 1 写入 _rd_，否则写入 0。`SLTIU`（Set Less Than Immediate Unsigned）类似，但将两者视为无符号数进行比较（即立即数先符号扩展为 XLEN 位，然后按无符号数处理）。需要注意的是，SLTIU _rd, rs1, 1_ 的作用是：当 rs1 为 0 时，_rd_ 置为 1，否则置为 0（汇编伪指令 SEQZ _rd, rs_）。

`ANDI`、`ORI`、`XORI` 是逻辑运算指令，分别对寄存器 rs1 的值和符号扩展的 12 位立即数执行按位 AND、OR 和 XOR 运算，并将结果存入 rd。需要注意的是，XORI _rd, rs1, -1_ 的作用是对 rs1 进行按位取反（汇编伪指令 NOT _rd, rs_）。

include::images/wavedrom/int-comp-slli-srli-srai.adoc[]
[[int-comp-slli-srli-srai]]
//.整数寄存器-立即数，SLLI，SRLI，SRAI

按常数位移的指令是 I 型格式的一种特化形式。待移位的操作数存储在 _rs1_，移位量编码在 I 型立即数字段的低 5 位。右移的类型由指令的第 30 位进行编码。`SLLI` 是逻辑左移（低位补 0）；`SRLI` 是逻辑右移（高位补 0）；`SRAI` 是算术右移（高位填充原符号位）。

include::images/wavedrom/int-comp-lui-aiupc.adoc[]
[[int-comp-lui-aiupc]]
//.整数寄存器-立即数，U-立即数

`LUI`（Load Upper Immediate）用于构造 32 位常数，采用 U 型格式。LUI 将 32 位 U-立即数 载入目标寄存器 _rd_，并在最低 12 位填充 0。

`AUIPC`（Add Upper Immediate to pc）用于构造 `pc` 相对地址，采用 U 型格式。AUIPC 通过 U-立即数构造一个 32 位偏移量，最低 12 位填充 0，然后将该偏移量加到 AUIPC 指令所在的地址，并将结果存入寄存器 _rd_。

[NOTE]
====
`lui` 和 `auipc` 指令的汇编语法不会显示 U-立即数的最低 12 位，因为这些位始终为 0。

AUIPC 指令支持两条指令的组合序列，以访问 PC 相对的任意偏移量，可用于控制流跳转和数据访问。通过 AUIPC 与 JALR 指令中的 12 位立即数组合，可以跳转到任意 32 位 PC 相对地址。类似地，AUIPC 加上普通加载（load）或存储（store）指令中的 12 位立即数偏移，可以访问任意 32 位 PC 相对数据地址

当前 PC 的值可以通过 将 AUIPC 的 U 型立即数设为 0 来获取。虽然 JAL +4 也可以用于获取本地 PC（即 JAL 指令后续指令的地址），但在简单的微架构中可能会导致流水线断裂，而在复杂的微架构中可能会污染 BTB（分支目标缓冲区）。
====

==== 整数寄存器-寄存器运算

RV32I 定义了多种算术 R 型 操作。所有操作均以寄存器 _rs1_ 和 _rs2_ 作为源操作数，并将结果写入寄存器 _rd_。操作类型由 _funct7_ 和 _funct3_ 字段决定。

include::images/wavedrom/int_reg-reg.adoc[]
[[int-reg-reg]]
//.整数寄存器-寄存器

`ADD` 对 _rs1_ 和 _rs2_ 执行加法运算。`SUB` 计算 _rs1_ 减 _rs2_ 的结果。溢出被忽略，计算结果的低 XLEN 位被写入目标寄存器 _rd_。`SLT` 和 `SLTU` 分别执行有符号和无符号比较，如果 _rs1_ < _rs2_，则向 _rd_ 写入 1，否则写入 0。需要注意的是，SLTU _rd_, _x0_, _rs2_ 指令会在 _rs2_ ≠ 0 时将 _rd_ 置为 1，否则置为 0（对应汇编伪指令 SNEZ _rd, rs_）。`AND`、`OR` 和 `XOR` 分别执行按位 与（AND）、或（OR）和 异或（XOR）运算。

`SLL`、`SRL` 和 `SRA` 分别对 _rs1_ 进行逻辑左移（SLL）、逻辑右移（SRL）和算术右移（SRA），移位量由 _rs2_ 的低 5 位指定。

==== NOP 指令

include::images/wavedrom/nop.adoc[]
[[nop]]
//.NOP 指令

`NOP` 指令不会改变任何架构可见的状态，但会推进 `pc` 并增加任何适用的性能计数器的值。NOP 指令的编码为 ADDI _x0, x0, 0_。

[NOTE]
====
NOP 指令可用于将代码段对齐到微架构上重要的地址边界，或预留空间以便进行内联代码修改。尽管有多种可能的 NOP 编码方式，我们定义了一种标准 NOP 编码，以便支持微架构优化，同时使反汇编输出更易阅读。其他 NOP 编码可用于 <<rv32i-hints>>。

我们选择 ADDI 作为 NOP 的编码方式，因为它在各种系统上最可能以最少的资源执行（如果在解码阶段未被优化掉）。尤其是，该指令只需要读取一个寄存器。此外，在超标量设计中，ADDI 功能单元更有可能可用，因为加法是最常见的操作。特别地，地址生成单元可以使用相同的硬件执行 ADDI 指令，而寄存器-寄存器 ADD 或逻辑/移位操作 则需要额外的硬件支持。
====

=== 控制转移指令
RV32I 提供了两类控制转移指令：无条件跳转 和 条件分支。在 RV32I 中，控制转移指令没有架构可见的延迟槽（delay slot）。

如果跳转目标或被执行的分支目标发生指令访问错误或指令页错误异常，该异常会报告在目标指令上，而不是报告在跳转或分支指令上。

==== 无条件跳转
跳转并链接（`JAL`：Jump and Link）指令采用 J 型格式，其中 J 型立即数表示一个以 2 字节为单位的有符号偏移量。该偏移量经过符号扩展后，与跳转指令的地址相加，以形成跳转目标地址。因此，JAL 指令的跳转范围为 &#177;1 MiB。JAL 指令会将跳转指令后续指令的地址（`pc`+4）存入寄存器 _rd_。标准的软件调用约定使用 `x1` 作为返回地址寄存器，并使用 `x5` 作为备用链接寄存器。

[NOTE]
====
备用链接寄存器用于调用微代码（millicode）例程（例如用于在压缩代码中保存和恢复寄存器的例程），同时保留常规返回地址寄存器。寄存器 `x5` 被选作备用链接寄存器，因为它在标准调用约定中对应于一个临时寄存器，并且它的编码与常规链接寄存器仅相差 1 位。
====

普通的无条件跳转（汇编伪指令 J）被编码为 JAL，其中 _rd_=`x0`。

include::images/wavedrom/ct-unconditional.adoc[]
[[ct-unconditional]]
//.无条件跳转指令，JAL

间接跳转指令（`JALR`：Jump and Link Register）采用 I 型格式进行编码。目标地址由寄存器 _rs1_ 与符号扩展的 12 位 I 型立即数相加得到，并将计算结果的最低有效位清零。跳转指令后续指令的地址（`pc`+4）被写入寄存器 _rd_。如果不需要保存返回地址，可以使用寄存器 `x0` 作为目标寄存器。

include::images/wavedrom/ct-unconditional-2.adoc[]
[[ct-unconditional-2]]
//.间接无条件跳跃指令，JALR

[NOTE]
====
无条件跳转指令全部采用 PC 相对寻址，以支持位置无关代码（PIC）。JALR 指令 被设计为支持两条指令的组合序列，从而能够跳转到 32 位绝对地址范围 的任意位置。一条 LUI 指令可以先将目标地址的高 20 位加载到 _rs1_，然后 JALR 可以将低位加上去。同样，AUIPC + JALR 可以跳转到 32 位 PC 相对地址范围内的任意位置。

需要注意的是，JALR 指令的 12 位立即数并不像条件分支指令那样以 2 字节为单位，这避免了在硬件中增加额外的立即数格式。在实际应用中，大多数 JALR 指令的立即数要么为 0，要么与 LUI 或 AUIPC 组合使用，因此这一点对跳转范围的影响不大。

在计算 JALR 目标地址 时，将最低有效位（LSB）清零，这样既可以简化硬件，也可以利用指针的最低位存储附加信息。尽管这种方式可能会略微降低错误检测能力，但在实际应用中，如果跳转到错误的指令地址，通常会迅速触发异常。

当 JALR 的基地址寄存器 _rs1_=`x0` 时，它可以实现单条指令的子程序调用，从地址空间的任意位置跳转到最低或最高地址区域，这可以用于快速调用小型运行时库。或者，某个 ABI（应用二进制接口）也可以专门保留一个通用寄存器，用于指向地址空间中的库。
====

如果 JAL 或 JALR 指令的目标地址未对齐至 4 字节边界，则会触发指令地址未对齐（instruction-address-misaligned）异常。

[NOTE]
====
在支持 16 位对齐指令（例如压缩指令集扩展 C）的机器上，不会发生指令地址未对齐（instruction-address-misaligned）异常。
====

返回地址预测栈（Return-Address Prediction Stacks，RAS）是高性能指令取指单元中的常见功能，但要有效工作，必须准确检测用于过程调用和返回的指令。在 RISC-V 中，指令的用途提示（HINTS）是通过使用的寄存器编号来隐式编码的。JAL 指令仅在 _rd_ 为 `x1` 或 `x5` 时，才应将返回地址压入 返回地址栈（RAS）。JALR 指令的 RAS 推入/弹出 规则如 <<rashints>> 所示。

[[rashints]]
.JALR 指令中由寄存器操作数编码的返回地址栈预测提示。
[%autowidth,float="center",align="center",cols="^,^,^,<",options="header"]
|===
|_rd_ 为 _x1/x5_ |_rs1_ 为 _x1/x5_ |_rd_=_rs1_ |RAS 操作

|No |No |-- |无（None）

|No |No |-- |弹出（Pop）

|Yes |No |-- |压入（Push）

|Yes |Yes |Yes |弹出后压入（Pop, then push）

|Yes |Yes |Yes |压入（Push）
|===


[NOTE]
====
某些其他 ISA 在它们的间接跳转指令中添加了显式提示位，用于引导返回地址栈（RAS）的操作。而在 RISC-V 中，我们采用了基于寄存器编号和调用约定的隐式提示机制，从而减少了编码空间的占用。

当两个不同的链接寄存器（`x1` 和 `x5`）分别用于 _rs1_ 和 _rd_ 时，RAS 会同时执行弹出（pop）和压入（push）操作，以支持协程（coroutines）。如果 _rs1_ 和 _rd_ 是相同的链接寄存器（`x1` 或 `x5`），则 RAS 仅执行压入（push）操作，以支持宏指令融合（macro-op fusion），如以下指令序列：`lui ra, imm20; jalr ra, imm12(ra)_ 和 _auipc ra, imm20; jalr ra, imm12(ra)`
====

==== 条件分支

所有分支指令均采用 B 型指令格式。12 位 B 型立即数以 2 字节为单位编码有符号偏移量。该偏移量经过符号扩展后，与分支指令的地址相加，以计算目标地址。条件分支的跳转范围为 &#177;4 KiB。

include::images/wavedrom/ct-conditional.adoc[]
[[ct-conditional]]
//.条件分支

分支指令用于比较两个寄存器。BEQ 和 BNE 分别在寄存器 _rs1_ 和 _rs2_ 相等或不等时跳转。BLT 和 BLTU 分别在有符号和无符号比较中，当 _rs1_ 小于 _rs2_ 时跳转。BGE 和 BGEU 分别在有符号和无符号比较中，当 _rs1_ 大于或等于 _rs2_ 时跳转。注意，BGT、BGTU、BLE 和 BLEU 可以通过交换 BLT、BLTU、BGE 和 BGEU 的操作数来合成。

[NOTE]
====
带符号的数组边界检查可以通过单条 BLTU 指令完成，因为任何负索引都会被判定为大于任意非负边界。
====

软件应优化顺序执行路径，使其成为最常见的执行路径，并将较少执行的代码路径放置在主线代码之外。此外，软件应假设后向分支（backward branches）默认会被预测为执行，而前向分支（forward branches）默认在首次遇到时被预测为不跳转。动态预测器应该能够快速学习任何可预测的分支行为。

与某些其他架构不同，RISC-V 无条件跳转应始终使用跳转指令（JAL，且 _rd_=`x0`），而不是使用条件分支指令并设定一个始终为真的条件。RISC-V 跳转指令也是 PC 相对寻址，支持的偏移范围比分支指令更广，并且不会污染条件分支预测表。

[TIP]
====
条件分支指令被设计旨在包含两个寄存器之间的算数比较操作（与 PA-RISC、Xtensa 和 MIPS R6 类似），而不是使用条件码（condition codes）（如 x86、ARM、SPARC、PowerPC），也不是仅仅将一个寄存器与零进行比较（如 Alpha、MIPS），或者仅比较两个寄存器是否相等（如 MIPS）。这一设计的动机在于，合并比较与分支的指令（compare-and-branch）可以很好地适配常规流水线，避免引入额外的条件码状态或使用临时寄存器，同时减少静态代码体积以及动态指令取指流量。另一个考虑点是，与零进行比较所需的电路延迟不可忽视（尤其在先进工艺转向静态逻辑后更是如此），其延迟几乎与算术大小比较相当。融合比较与分支指令的另一优点在于，分支能够在前端指令流中更早地被识别，从而更早地进行预测。虽然在基于相同条件码可以采取多个分支的情况下，使用条件码的设计可能具有一定优势，但我们认为这种情况相对较少。

我们曾考虑在指令编码中加入静态分支提示（static branch hints），但最终未被采纳。这些提示虽然可以降低动态预测器的压力，但会占用更多的指令编码空间，并且需要软件进行性能分析以达到最佳效果；如果实际生产运行与性能分析的环境不匹配，反而可能导致性能下降。

我们曾考虑过但并未采用条件移动（conditional moves）或谓词指令（predicated instructions），这两者都能有效替代不可预测的短程前向分支。条件移动较为简单，但在涉及可能引发异常的条件代码（如内存访问和浮点运算）时使用起来较为困难。谓词化则需要为系统增加额外的标志状态，增加设置和清除这些标志的指令，并且每条指令还会因此增加额外的编码开销。无论是条件移动还是谓词指令，都给乱序微架构（out-of-order microarchitecture）带来额外复杂性，因为如果谓词为假，就需要将目标架构寄存器的原始值复制到重命名后的目标物理寄存器中，从而隐含地引入了第三个源操作数。此外，在编译时静态决定使用谓词化而非分支，可能会在那些不包含在编译器训练集中的输入上导致性能下降，尤其是在不可预测分支本就稀少且随着分支预测技术的改进而愈加罕见的情况下。

我们注意到，存在各种微架构技术，可以动态地将不可预测的短程前向分支转换为内部谓词化代码，以避免因分支预测错误而刷新流水线的开销 cite:[heil-tr1996], cite:[Klauser-1998], cite:[Kim-micro2005]，并且这些技术已在商用处理器中得到应用 cite:[ibmpower7]。最简单的技术仅通过只刷新分支影区（branch shadow，或称为“分支预测区”）中的指令而非整个取指流水线，或利用宽取指（wide instruction fetch）或空闲取指槽（idle instruction fetch slots）同时从两个方向取指，从而减少从预测错误的短程前向分支中恢复的代价。对于乱序执行核心（out-of-order cores），更复杂的技术则在分支影区中的指令上增加内部谓词，该内部谓词的值由分支指令写入，从而使该分支及其后续指令能够相对于其他代码进行投机性和乱序执行。
====

如果条件分支指令的目标地址未对齐至 4 字节边界，并且分支条件计算结果为真，则会触发指令地址未对齐异常。如果分支条件计算结果为假，则不会触发该异常。

[NOTE]
====
在支持 16 位对齐指令（例如压缩指令集扩展 C）的机器上，不会发生指令地址未对齐异常。
====

[[ldst]]
=== 加载和存储指令

RV32I 是一种加载-存储（load-store）架构，其中只有加载和存储指令可以访问内存，而算术指令仅能对 CPU 寄存器进行操作。RV32I 提供了32 位地址空间，并采用字节寻址。EEI（Execution Environment Interface，执行环境接口）将定义地址空间的哪些部分可以被哪些指令访问（例如，某些地址可能仅可读，或仅支持字（word）访问）。如果加载指令的目标寄存器是 `x0`，尽管加载的值会被丢弃，但仍然必须触发异常，并引发所有相关的副作用。

EEI 还将定义内存系统的字节序（小端或大端）。在 RISC-V 中，无论采用大端还是小端格式，内存中每个字节的地址分布始终保持不变。

[TIP]
====
在字节序与字节地址无关的系统中，以下性质成立：如果以某种字节序将一个字节存储到某个内存地址，那么无论采用何种字节序，从该地址加载一个字节时，都应返回存储的值。

在小端序（little-endian）配置下，多字节存储操作将寄存器中最低有效字节存放在最低的内存字节地址，其余寄存器字节按有效性从低到高的顺序依次存放。加载操作也会相应地将较低内存字节地址中的内容传送到寄存器中较低有效性的字节位置。

在大端序（big-endian）配置下，多字节存储操作将寄存器中最高有效字节存放在最低的内存字节地址，其余寄存器字节按有效性从高到低的顺序依次存放。加载操作则将较高内存字节地址中的内容传送到寄存器中较低有效性的字节位置。
====

include::images/wavedrom/load_store.adoc[]
[[load-store,加载和存储]]
//.加载和存储指令

加载和存储指令用于在寄存器和内存之间传递数值。加载指令采用 I 型格式进行编码，而存储指令采用 S 型格式。有效地址由寄存器 _rs1_ 与经过符号扩展的 12 位偏移量相加得到。加载指令从内存读取值并存入寄存器 _rd_，存储指令则将寄存器 _rs2_ 的值写入内存。

LW 指令将一个 32 位的值从内存加载到寄存器 _rd_ 中。LH 指令从内存加载一个 16 位的值，并在存入 _rd_ 前进行符号扩展至 32 位。LHU 指令从内存加载 16 位的值，但在存入 _rd_ 前进行零扩展至 32 位。LB 和 LBU 指令对 8 位值的加载方式类似。SW、SH 和 SB 指令分别从寄存器 _rs2_ 的低位中取出 32 位、16 位和 8 位数据存入内存。

无论 EEI 如何定义，对于有效地址自然对齐的加载和存储，都不应引发地址未对齐异常。而那些有效地址没有自然对齐到所引用数据类型（即有效地址不能被访问大小（以字节为单位）整除）的加载和存储，其行为则依赖于 EEI 的规定。

一个 EEI 可能保证对未对齐的加载和存储操作提供完全支持，因此在执行环境中运行的软件永远不会遭遇受控或致命的地址未对齐陷阱。在这种情况下，未对齐的加载和存储可以由硬件直接处理，或通过对执行环境实现的隐式陷阱（invisible trap）处理，亦或根据地址采用硬件和隐式陷阱相结合的方式。

另一方面，一个 EEI 可能不保证对未对齐的加载和存储操作进行隐式处理。在这种情况下，未自然对齐的加载和存储操作可能会成功完成执行，也可能引发异常。引发的异常可以是地址未对齐异常，也可以是访问错误异常。对于原本能够完成的内存访问，如果仅因为未对齐而无法完成，并且该未对齐访问不应被模拟（例如，因为对该内存区域的访问具有副作用），则可以引发访问错误异常而不是地址未对齐异常。当 EEI 不保证对未对齐加载和存储操作进行隐式处理时，EEI 必须定义因地址未对齐而引发的异常是产生受控陷阱（允许执行环境内的软件处理该陷阱）还是致命陷阱（导致执行终止）。

[TIP]
====
在移植遗留代码时，有时需要进行未对齐访问；而在使用任何形式的 packeted-SIMD 扩展或处理外部打包数据结构时，未对齐访问也有助于提高性能。我们允许 EEI 选择通过常规加载和存储指令来支持未对齐访问，其理由在于简化增加未对齐硬件支持的过程。一种选择本来是禁止在基础 ISA 中进行未对齐访问，然后为未对齐访问提供单独的 ISA 支持——无论是通过特殊指令来帮助软件处理未对齐访问，还是通过引入新的未对齐访问硬件寻址模式。然而，特殊指令使用起来较为困难，不仅会增加 ISA 的复杂性，还常常引入新的处理器状态（例如 SPARC VIS 对齐地址偏移寄存器），或者使得对现有处理器状态的访问变得更为复杂（例如 MIPS LWL/LWR 部分寄存器写操作）。此外，对于面向循环的 packeted-SIMD 代码，操作数未对齐所产生的额外开销，会促使软件根据操作数的对齐情况提供多种循环形式，这不仅使代码生成过程变得复杂，也增加了循环启动时的开销。新的未对齐硬件寻址模式在指令编码中要么占用较多空间，要么要求采用非常简化的寻址方式（例如，仅支持寄存器间接寻址）。
====

即使未对齐的加载和存储操作成功完成，这些访问的速度仍可能非常慢，具体取决于其实现方式（例如，当通过隐式陷阱实现时）。此外，虽然自然对齐的加载和存储操作保证原子执行，但未对齐的加载和存储操作可能不具备原子性，因此需要额外的同步措施以确保原子性。

[NOTE]
====
我们不强制要求未对齐访问具备原子性，因此执行环境的实现可以使用隐式机器陷阱和软件处理程序来处理部分或全部的未对齐访问。如果提供了硬件对未对齐访问的支持，软件只需简单地使用常规加载和存储指令即可利用这一特性。硬件则可以根据运行时地址是否对齐自动优化访问。
====

[[fence]]
=== 内存排序指令

include::images/wavedrom/mem_order.adoc[]
[[mem-order]]
//.内存排序指令

FENCE 指令用于对设备 I/O 和内存访问进行排序，使其他 RISC-V hart 以及外部设备或协处理器看到的访问顺序符合预期。设备输入（I）、设备输出（O）、内存读取（R）和内存写入（W）的任何组合，都可以彼此之间建立顺序关系。换句话说，其他 RISC-V hart 或外部设备不会在观察到 FENCE 前面的操作（前驱集合，_predecessor_）完成之前，就看到 FENCE 后面的操作（后继集合，_successor_）。<<memorymodel>> 提供了 RISC-V 内存一致性模型的精确定义。

FENCE 指令还会对 hart 执行的内存读写操作进行排序，使其在外部设备进行的内存读写操作中得到一致的观察。然而，FENCE 不会对外部设备使用其他信号机制所观察到的事件进行排序。

[NOTE]
====
设备可能通过某种外部通信机制观察到对内存地址的访问，例如，通过内存映射的控制寄存器来驱动中断控制器的中断信号。这种通信超出了 FENCE 排序机制的范围，因此 FENCE 指令无法保证中断信号的变化何时能被中断控制器观察到。特定设备可能会提供额外的排序保证以降低软件开销，但这些内容超出了 RISC-V 内存模型的定义范围。
====

EEI 将定义哪些 I/O 操作是可能的，特别是哪些内存地址在被加载和存储指令访问时，会分别被视为设备输入和设备输出操作，而不是内存读取和写入。例如，内存映射 I/O 设备通常会通过未缓存的加载和存储进行访问，并且按照 FENCE 指令中的 I 和 O 位而非 R 和 W 位进行排序。指令集扩展还可能描述新的 I/O 指令，这些指令同样会使用 FENCE 指令中的 I 和 O 位进行排序。

[[fm]]
[float="center",align="center",cols="^1,^1,<3",options="header"]
.Fence 模式编码
|===
|_fm_ 字段 |助记符 |含义
|0000 |_none_ |普通 Fence
|1000 |TSO |使用 `FENCE RW,RW`：排除写-读排序；否则：保留供未来使用。
2+|other|保留供未来使用。
|===

模式字段 _fm_ 定义了 `FENCE` 的语义。对于 _fm_=`0000` 的 `FENCE` 指令，其会将前驱集合中的所有内存操作排序在后继集合中的所有内存操作之前。

`FENCE.TSO` 指令编码为 _fm_=`1000` 的 `FENCE` 指令，同时其前驱字段设置为 `RW`，后继字段也设置为 `RW`。`FENCE.TSO` 会将其前驱集合中的所有加载操作排序在后继集合中的所有内存操作之前，并将其前驱集合中的所有存储操作排序在后继集合中的所有存储操作之前。这使得 `FENCE.TSO` 的前驱集合中的非原子内存操作（`non-AMO` store）与后继集合中的非原子内存操作（`non-AMO` load）之间的执行顺序不受约束。

[NOTE]
====
由于 FENCE RW,RW 所施加的顺序约束是 FENCE.TSO 所施加的顺序约束的超集，因此忽略 _fm_ 字段，将 FENCE.TSO 实现为 FENCE RW,RW 是正确的。
====

FENCE 指令中未使用的字段 _rs1_ 和 _rd_ 保留用于未来扩展中更细粒度的栅栏。为实现向前兼容，基础实现应忽略这些字段，而标准软件应将这些字段置零。同样，<<fm>> 中许多 _fm_ 以及前驱/后继集合的设置也保留以供将来使用。基础实现应将所有此类保留配置视为 _fm_=0000 的普通栅栏，而标准软件则应仅使用非保留配置。

[TIP]
====
我们选择了宽松的内存模型，以便从简单的机器实现以及未来可能的协处理器或加速器扩展中获得高性能。我们将 I/O 排序与内存读写排序分离，以避免在设备驱动 hart 内部产生不必要的串行化，同时也支持通过非内存路径控制附加的协处理器或 I/O 设备。简单的实现甚至可以忽略 _predecessor_ 和 _successor_ 字段，总是对所有操作执行一个保守的 fence 操作。
====

=== 环境调用和断点
`SYSTEM` 指令用于访问可能需要特权访问的系统功能，并采用 I 型指令格式编码。这些指令主要分为两大类：一类是对控制和状态寄存器（CSR）进行原子读-修改-写操作的指令，另一类是所有其他可能需要特权的指令。CSR 指令的详细说明见 <<csrinsts>>，而基础的非特权指令将在下一节中介绍。


[TIP]
====
SYSTEM 指令的设计允许简单实现总是转入一个单一的软件陷阱处理程序。更复杂的实现则可能在硬件上执行更多的 SYSTEM 指令操作。
====

include::images/wavedrom/env_call-breakpoint.adoc[]
[[env-call]]
//.环境调用和断点指令

这两条指令会导致向支持它们的执行环境发起一个精确的请求陷阱。

`ECALL` 指令用于向执行环境发起服务请求。EEI 将定义服务请求参数的传递方式，但通常这些参数会存放在整数寄存器文件的预定位置。

`EBREAK` 指令用于将控制权交还给调试环境。

[NOTE]
====
ECALL 和 EBREAK 以前分别称为 SCALL 和 SBREAK。这两条指令的功能和编码保持不变，但改名后的名称反映了它们不仅限于调用超级用户级操作系统或调试器，而是可以更广泛地使用。
====

[TIP]
====
EBREAK 最初主要设计用于由调试器调用，使执行停止并退回到调试器中。标准的 gcc 编译器也使用 EBREAK 来标记不应执行的代码路径。

另外，EBREAK 还用于支持“半主机（semihosting）”模式，此模式下执行环境包含一个调试器，能够通过围绕 EBREAK 指令构建的另一种系统调用接口提供服务。由于 RISC-V 基础 ISA 只提供一种 EBREAK 指令，RISC-V 半主机模式采用了一组特殊的指令序列，以区分半主机模式下的 EBREAK 与调试器插入的 EBREAK。

[source,asm]
....
    slli x0, x0, 0x1f   # 入口空操作
    ebreak              # 中断进入调试器
    srai x0, x0, 7      # 用于半主机调用编号为 7 的空操作编码
....

请注意，这三条指令必须是 32 位宽的指令，也就是说，它们不能属于 <<compressed>> 中描述的 16 位压缩指令。

移位 NOP 指令仍然可用作为 HINTs。

半主机是一种服务调用方式，更自然的编码方式是使用现有 ABI 的 ECALL，但这要求调试器能够截获 ECALL，而这一功能是调试标准的较新扩展。我们打算转而使用带有标准 ABI 的 ECALL，这样半主机就可以与现有标准共享服务 ABI。

我们注意到，ARM 处理器在较新设计中也已经从使用 BKPT 改为使用 SVC 来进行半主机调用。
====

=== HINT 指令
//[#rv32i-hints,HINT 指令]

[[rv32i-hints,HINT 指令]]

RV32I 为 HINT 指令保留了大量的编码空间，这些指令通常用于向微架构传递性能提示。与 NOP 指令类似，HINT 指令不会改变任何架构可见的状态，除非用于更新程序计数器 (`pc`) 和任何适用的性能计数器。实现可以始终忽略这些编码的提示。

大多数 RV32I 的 HINT 指令被编码为 _rd_=x0 的整数计算指令。其余的 RV32I HINT 指令则被编码为前驱和后继集合为空、_fm_=0 的 FENCE 指令。

[NOTE]
====
这些 HINT 指令的编码方式被设计成简单的实现可以完全忽略 HINT，而将其当作普通指令执行，只不过该指令不会改变架构可见的状态。例如，当目标寄存器为 `x0` 时，ADD 指令就被视为 HINT；而 _rs1_ 和 _rs2_ 的 5 位字段则用于编码 HINT 的参数。然而，简单的实现可以直接将该 HINT 当作一条 ADD 指令执行，即将 _rs1_ 和 _rs2_ 相加并将结果写入 `x0`，从而不会产生任何架构可见的影响。

另一个例子是：一个 _pred_ 字段和 _fm_ 字段均为零的 FENCE 指令被视为一条 HINT；而 _succ_、_rs1_ 和 _rd_ 字段则对 HINT 的参数进行编码。简单的实现可以直接将该 HINT 当作一条 FENCE 指令执行，其效果是将空的先前内存访问集合排序在 _succ_ 字段所编码的任意后续内存访问之前。由于先前集合与后续集合的交集为空，该指令不会施加任何内存排序，从而不会产生任何架构可见的影响。
====

<<t-rv32i-hints>> 列出了所有 RV32I HINT 指令的编码点。91% 的 HINT 空间被保留用于标准 HINT，而剩余部分则指定用于自定义 HINT：在该子空间内永远不会定义任何标准 HINT。

[TIP]
====
我们预计未来的标准 HINT 将涵盖内存系统的空间和时间局部性提示、分支预测提示、线程调度提示、安全标签，以及用于仿真/模拟的插桩标志。
====

// 这张表格可能仍存在一些问题——某些行可能没有正确对齐，需要逐个单元格仔细检查。

[[t-rv32i-hints]]
.RV32I 提示指令。
[float="center",align="center",cols="<,<,^,<",options="header"]
|===
|指令 |约束 |代码点 |目的

|LUI |_rd_=`x0` |latexmath:[$2^{20}$] .8+<.^m|设计用于未来标准使用。

|AUIPC |_rd_=`x0` |latexmath:[$2^{20}$]

|ADDI |_rd_=`x0`，且 _rs1_&#8800;``x0`` 或 _imm_&#8800;0 |latexmath:[$2^{17}-1$]

|ANDI |_rd_=`x0` |latexmath:[$2^{17}$]

|ORI |_rd_=`x0` |latexmath:[$2^{17}$]

|XORI |_rd_=`x0` |latexmath:[$2^{17}$]

|ADD |_rd_=`x0`, _rs1_&#8800;``x0`` |latexmath:[$2^{10}-32$]

|ADD |_rd_=`x0`, _rs1_=`x0`, _rs2_&#8800;``x2-x5`` | 28

|ADD |_rd_=`x0`, _rs1_=`x0`, _rs2_=`x2-x5` |4|(_rs2_=`x2`) NTL.P1 + 
(_rs2_=`x3`) NTL.PALL +
(_rs2_=`x4`) NTL.S1 +
(_rs2_=`x5`) NTL.ALL

|SUB |_rd_=`x0` |latexmath:[$2^{10}$] .11+<.^m|设计用于未来标准使用。

|AND |_rd_=`x0` |latexmath:[$2^{10}$]

|OR |_rd_=`x0` |latexmath:[$2^{10}$]

|XOR |_rd_=`x0` |latexmath:[$2^{10}$]

|SLL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRA |_rd_=`x0` |latexmath:[$2^{10}$]

|FENCE|_rd_=`x0`, _rs1_&#8800;``x0``, _fm_=0, and either _pred_=0 or _succ_=0| latexmath:[$2^{10}-63$]

|FENCE|_rd_&#8800;``x0``, _rs1_=`x0`, _fm_=0, and either _pred_=0 or _succ_=0| latexmath:[$2^{10}-63$]

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=0, _succ_&#8800;0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_&#8800;W, _succ_=0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=W, _succ_=0 |1 |PAUSE

4+| 

|SLTI |_rd_=`x0` |latexmath:[$2^{17}$] .7+<.^m|设计用于自定义使用。

|SLTIU|_rd_=`x0` |latexmath:[$2^{17}$]

|SLLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRAI |_rd_=`x0` |latexmath:[$2^{10}$]

|SLT |_rd_=`x0` |latexmath:[$2^{10}$]

|SLTU |_rd_=`x0` |latexmath:[$2^{10}$]
|===

