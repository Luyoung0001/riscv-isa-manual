[[rv32]]
== RV32I 基本整数指令集，版本 2.1

本章描述了 RV32I 基本整数指令集。

[TIP]
====
RV32I 的设计旨在足以作为编译器的目标架构，并支持现代操作系统环境。该指令集架构（ISA）还专门设计为减少最小实现所需的硬件资源。RV32I 包含 40 条独特的指令，尽管在一个简单的实现中，可能通过一个始终触发陷阱的 SYSTEM 硬件指令来替代 ECALL/EBREAK 指令，并且可能将 FENCE 指令实现为 NOP（无操作指令），从而将基础指令总数减少到 38 条。RV32I 可以模拟几乎所有其他 ISA 扩展（除了 A 扩展，它需要额外的硬件支持以保证原子性）。

实际上，包括机器模式特权架构的硬件实现还需要额外的 6 条 CSR 指令。

基础整数 ISA 的子集可能在教学中有所帮助，但由于基础架构的设计，实际硬件实现中几乎没有必要进一步精简指令集，除非是去掉对不对齐内存访问的支持，或者将所有 SYSTEM 指令统一视为一个陷阱指令。
====

[NOTE]
====
标准的 RISC-V 汇编语言语法已在《汇编程序员手册》中进行详细说明 cite:[riscv-asm-manual]。
====

[NOTE]
====
大部分关于 RV32I 的说明同样适用于 RV64I 基础指令集。
====

=== 基本整数 ISA 的程序员模型

<<gprs>> 描述了非特权基本整数 ISA 的状态。对 RV32I 而言，32 个 `x` 寄存器每个都是 32 位宽，也就是 `XLEN=32`。寄存器 `x0` 的所有位都硬连线到 0。
各种指令将会把通用寄存器 `x1-x31` 保存的值解释为布尔值集合或二进制补码有符号整数或无符号二进制整数。

<<gprs>> 说明了基础整数 ISA 的非特权状态。对于 RV32I，32 个 `x` 寄存器每个宽度为 32 位，即 XLEN=32。寄存器 `x0` 硬连接为全零。通用寄存器 `x1-x31` 存储不同指令解释的值，这些值可以是布尔值的集合、二进制补码有符号整数或二进制无符号整数。

还有一个额外的非特权寄存器：程序计数器 `pc` 存储当前指令的地址。

[[gprs]]
.RISC-V 基本非特权整数寄存器状态。
[cols="<,^,>",options="header",width="50%",align="center",grid="rows"]
|===
<| [.small]#XLEN-1#| >| [.small]#0#
3+^| [.small]#x0/zero#
3+^| [.small]#x1#
3+^| [.small]#x2#
3+^| [.small]#x3#
3+^| [.small]#x4#
3+^| [.small]#x5#
3+^| [.small]#x6#
3+^| [.small]#x7#
3+^| [.small]#x8#
3+^| [.small]#x9#
3+^| [.small]#x10#
3+^| [.small]#x11#
3+^| [.small]#x12#
3+^| [.small]#x13#
3+^| [.small]#x14#
3+^| [.small]#x15#
3+^| [.small]#x16#
3+^| [.small]#x17#
3+^| [.small]#x18#
3+^| [.small]#x19#
3+^| [.small]#x20#
3+^| [.small]#x21#
3+^| [.small]#x22#
3+^| [.small]#x23#
3+^| [.small]#x24#
3+^| [.small]#x25#
3+^| [.small]#x26#
3+^| [.small]#x27#
3+^| [.small]#x28#
3+^| [.small]#x29#
3+^| [.small]#x30#
3+^| [.small]#x31#
3+^| [.small]#XLEN#
| [.small]#XLEN-1#| >| [.small]#0#
3+^|  [.small]#pc#
3+^| [.small]#XLEN#
|===
[NOTE]
====
在基本整数 ISA 中，没有专门的栈指针或子程序返回地址链接寄存器；指令编码允许任何 `x` 寄存器用于这些目的。然而，标准的软件调用约定使用寄存器 `x1` 来保存调用的返回地址，同时寄存器 `x5` 可作为备用的链接寄存器。标准调用约定还使用寄存器 `x2` 作为栈指针。

硬件可以选择使用 `x1` 或 `x5` 来加速函数调用和返回的操作。具体请参见 JAL 和 JALR 指令的描述。

可选的压缩 16 位指令格式是基于假设 `x1` 是返回地址寄存器，`x2` 是栈指针寄存器来设计的。使用其他约定的软件仍然可以正常运行，但可能会导致更大的代码大小。

可用的体系结构寄存器数量对代码大小、性能和能耗有很大影响。虽然 16 个寄存器可以足够支持运行已编译代码的整数 ISA，但在 16 位指令中使用三地址格式来编码完整的 ISA 是不可能的。虽然两地址格式是可行的，但会增加指令数量并降低效率。我们希望避免中间指令大小（如 Xtensa 的 24 位指令），以简化基础硬件实现，并且一旦采用了 32 位指令大小，支持 32 个整数寄存器变得相对容易实现。更多的整数寄存器还有助于高性能代码的执行，在这类代码中，循环展开、软件流水线和缓存切片的使用非常广泛。

出于这些考虑，我们为 RV32I 选择了 32 个整数寄存器的传统配置。动态寄存器的使用通常由少数频繁访问的寄存器主导，因此寄存器文件实现可以通过优化，减少频繁访问寄存器的访问能耗 cite:[jtseng:sbbci]。可选的压缩 16 位指令格式主要访问 8 个寄存器，因此可以提供高效的指令编码；而如果需要，额外的指令集扩展可以支持更大规模的寄存器空间（无论是扁平式还是分层式）。

对于资源受限的嵌入式应用，我们定义了 RV32E 子集 (<<rv32e>>)，该子集仅包含 16 个寄存器。 。
====
=== 基本指令格式
在基础的 RV32I ISA 中，有四种核心指令格式（R/I/S/U），如 <<base_instr>> 所示。 所有指令的长度都是固定的 32 位。基本 ISA 的 `IALIGN=32`，这意味着指令必须在内存中按照四字节边界对齐。如果目标地址未按 `IALIGN-bit` 对齐，在发生分支或无条件跳转时，将生成指令地址未对齐异常。此异常会在分支或跳转指令上报告，而不是在目标指令上报告。对于未被执行的条件分支，不会生成指令地址未对齐异常。

[NOTE]
====
当添加了长度为 16 位的指令扩展或其他 16 位倍数的扩展（即 IALIGN=16）时，基础指令集的对齐约束放宽为两字节边界。

指令地址未对齐异常会在导致指令未对齐的分支或跳转指令上报告，以帮助调试，并简化硬件设计，特别是对于 IALIGN=32 的系统，在这些系统中只有在分支或跳转指令处才可能发生未对齐情况。
====

解码保留指令时的行为是 UNSPECIFIED 的。

[NOTE]
====
有些平台可能要求为标准用途保留的操作码触发非法指令异常。其他平台则可能允许保留的操作码空间用于非符合规范的扩展。
====

RISC-V ISA 在所有格式中保持源（_rs1_ 和 _rs2_）和目标（_rd_）寄存器在同一个位置以简化解码。除了在 CSR 指令 (<<csrinsts>>) 中使用的 5 位立即数外，其他立即数均采用符号扩展，并且通常被紧凑地放置在指令中最左侧可用的比特位置，以降低硬件复杂性。特别地，所有立即数的符号位总是在指令的第 31 位，以加速符号扩展电路。

include::images/wavedrom/instruction_formats.adoc[] 
[[base_instr,基本指令格式]]
RISC-V 基本指令格式：每个立即数子字段的标注方式是使用其在最终生成的立即数值中的比特位置（imm[x]），而不是通常采用的指令中立即数字段内的比特位置。

[NOTE]
====
在处理器实现中，寄存器标识符的解码通常位于关键路径上，因此 RISC-V 选择在所有指令格式中保持寄存器标识符的位置一致，尽管这需要在不同指令格式之间重新排列立即数的比特位置（这一特性与 RISC-IV相同，即 SPUR cite:[spur-jsscc1989]）。

实际上，大多数立即数要么很小，要么需要所有 XLEN 位。我们选择了一种非对称的立即数拆分方案（指令使用 12 位立即数，另外提供一条特殊的加载高位立即数指令，支持 20 位立即数）以增加常规指令可用的操作码空间。

所有立即数均采用符号扩展，因为我们未发现像 MIPS ISA 那样对某些立即数使用零扩展的优势，并希望尽可能简化指令集架构 (ISA)。
====

=== 立即数编码变体

根据立即数的处理方式，指令格式还有另外两种变体（B 型和 J 型），如 <<baseinstformatsimm>> 所示。

include::images/wavedrom/immediate_variants.adoc[] 
[[baseinstformatsimm,基本指令格式的立即数变体。]]
//.描述 RISC-V 基本指令格式的立即数变体。


S 型格式和 B 型格式之间的唯一区别在于，在 B 型格式中，12 位立即数字段用于编码以 2 为倍数的分支偏移量。与传统做法（在硬件中将指令编码的立即数整体左移一位）不同，在 B 型格式中，中间比特位（imm[10:1]）和符号位保持在固定位置，同时 S 型格式的最低位（inst[7]）被用作 B 型格式立即数的高位比特。。

类似地，U 型格式和 J 型格式的唯一区别在于，20 位立即数在 U 型格式中左移 12 位形成 U 型立即数，而在 J 型格式中左移 1 位形成 J 型立即数。U 型和 J 型格式中的指令比特位置经过优化，以最大程度地与其他格式对齐，并提高它们之间的一致性。。

<<immtypes>> 描述了每个基本指令格式生成的立即数，并标注了每个位的来源，即指令中的哪个比特位（inst[_y_]）对应于立即数的哪一位。
[[immtypes, 立即数类型]]
.RISC-V 指令生成的立即数类型。 
include::images/wavedrom/immediate.adoc[]

这些字段标注了用于构造其值的指令比特。符号扩展始终使用 inst[31]。

[NOTE]
====
符号扩展是立即数处理中最关键的操作之一（尤其是在 XLEN > 32 的情况下）。在 RISC-V 中，所有立即数的符号位始终固定在指令的 第 31 位，以便在指令解码的同时并行执行符号扩展。

尽管更复杂的实现可能会为分支和跳转计算分别使用独立的加法器，因此不需要在所有指令类型中保持立即数字段位置一致，但我们希望降低最简单实现的硬件成本。通过在 B 型和 J 型立即数的指令编码中旋转比特，而不是使用动态硬件多路复用器 (MUX) 将立即数乘以 2，我们成功将指令信号的扇出（fanout）和立即数 MUX 的成本降低了大约 2 倍。这种重新排列的立即数编码对静态编译或提前编译（ahead-of-time compilation）的影响可以忽略不计。对于动态指令生成，可能会引入一些额外的开销，但最常见的短距离前向分支具有直观的立即数编码，因此额外开销很小。
====

=== 整数计算指令

大多数整数计算指令操作整数寄存器堆中 `XLEN` 位的值。整数计算指令要么被编码为使用 I 类型格式的寄存器-立即数操作，要么被编码为使用 R 类型格式的寄存器-寄存器操作。寄存器-立即数和寄存器-寄存器指令的目标都是寄存器 _rd_。整数计算指令不会引发算术异常。

大多数整数计算指令对 `XLEN` 位的值进行操作，这些值存储在整数寄存器文件中。整数计算指令要么采用 I 型格式（寄存器-立即数运算），要么采用 R 型格式（寄存器-寄存器运算）。无论是寄存器-立即数指令还是寄存器-寄存器指令，目标寄存器均为 _rd_。所有整数计算指令都不会引发算术异常。

[TIP]
====
我们在基础指令集中未包含专门用于整数算术运算溢出检查的指令支持，因为在 RISC-V 中，许多溢出检查可以通过分支指令以较低成本实现。对于无符号加法，溢出检查仅需在加法运算后添加一条额外的分支指令：`add t0, t1, t2; bltu t0, t1, overflow`。

对于有符号加法，如果其中一个操作数的符号已知，溢出检查仅需在加法后添加一条分支指令：`addi t0, t1, +imm; blt t0, t1, overflow`。 这涵盖了加立即数这一常见情况。

对于一般的有符号加法，溢出检查需要在加法后额外执行三条指令，利用的原理是：当且仅当另一个操作数为负数时，和应小于其中一个操作数。

[source,text]
....
         add t0, t1, t2
         slti t3, t2, 0
         slt t4, t0, t1
         bne t3, t4, overflow
....

在 RV64I 中，可以通过比较操作数在 ADD 和 ADDW 指令下的结果，进一步优化对 32 位有符号加法 的溢出检查。
====

==== 整数寄存器-立即数指令

include::images/wavedrom/integer_computational.adoc[]
//.整数计算指令

ADDI 指令对寄存器 _rs1_ 的值与符号扩展的 12 位立即数进行加法运算。算术溢出被忽略，结果仅保留低 XLEN 位。ADDI _rd, rs1, 0_ 用于实现汇编伪指令 MV _rd, rs1_。

SLTI（set less than immediate）指令比较寄存器 _rs1_ 与符号扩展的立即数（均视为有符号数），如果 _rs1_ 小于该立即数，则将 1 写入 _rd_，否则写入 0。SLTIU（Set Less Than Immediate Unsigned）类似，但将两者视为无符号数进行比较（即立即数先符号扩展为 XLEN 位，然后按无符号数处理）。需要注意的是，SLTIU _rd, rs1, 1_ 的作用是：当 rs1 为 0 时，_rd_ 置为 1，否则置为 0（汇编伪指令 SEQZ _rd, rs_）。

ANDI、ORI、XORI 是逻辑运算指令，分别对寄存器 rs1 的值和符号扩展的 12 位立即数执行 按位 AND、OR 和 XOR 运算，并将结果存入 rd。需要注意的是，XORI _rd, rs1, -1_ 的作用是对 rs1 进行按位取反（汇编伪指令 NOT _rd, rs_）。

include::images/wavedrom/int-comp-slli-srli-srai.adoc[]
[[int-comp-slli-srli-srai]]
//.整数寄存器-立即数，SLLI，SRLI，SRAI

按常数位移的指令是 I 型格式的一种特化形式。待移位的操作数存储在 _rs1_，移位量编码在 I 型立即数字段的低 5 位。右移的类型由指令的第 30 位进行编码。SLLI 是逻辑左移（低位补 0）；SRLI 是逻辑右移（高位补 0）；SRAI 是算术右移（高位填充原符号位）。

include::images/wavedrom/int-comp-lui-aiupc.adoc[]
[[int-comp-lui-aiupc]]
//.整数寄存器-立即数，U-立即数

LUI（Load Upper Immediate）用于构造 32 位常数，采用 U 型格式。LUI 将 32 位 U-立即数 载入目标寄存器 _rd_，并在最低 12 位填充 0。

AUIPC（Add Upper Immediate to pc）用于构造 `pc` 相对地址，采用 U 型格式。AUIPC 通过 U-立即数构造一个 32 位偏移量，最低 12 位填充 0，然后将该偏移量加到 AUIPC 指令所在的地址，并将结果存入寄存器 _rd_。

[NOTE]
====
`lui` 和 `auipc` 指令的汇编语法不会显示 U-立即数的最低 12 位，因为这些位始终为 0。

AUIPC 指令支持两条指令的组合序列，以访问 PC 相对的任意偏移量，可用于控制流跳转和数据访问。通过 AUIPC 与 JALR 指令中的 12 位立即数组合，可以跳转到任意 32 位 PC 相对地址。类似地，AUIPC 加上普通加载（load）或存储（store）指令中的 12 位立即数偏移，可以访问任意 32 位 PC 相对数据地址

当前 PC 的值可以通过 将 AUIPC 的 U 型立即数设为 0 来获取。虽然 JAL +4 也可以用于获取本地 PC（即 JAL 指令后续指令的地址），但在简单的微架构中可能会导致流水线断裂，而在复杂的微架构中可能会污染 BTB（分支目标缓冲区）。
====

==== 整数寄存器-寄存器运算

RV32I 定义了多种算术 R 型 操作。所有操作均以寄存器 _rs1_ 和 _rs2_ 作为源操作数，并将结果写入寄存器 _rd_。操作类型由 _funct7_ 和 _funct3_ 字段决定。

include::images/wavedrom/int_reg-reg.adoc[]
[[int-reg-reg]]
//.整数寄存器-寄存器

ADD 对 _rs1_ 和 _rs2_ 执行加法运算。SUB 计算 _rs1_ 减 _rs2_ 的结果。溢出被忽略，计算结果的低 XLEN 位被写入目标寄存器 _rd_。SLT 和 SLTU 分别执行有符号和无符号比较，如果 _rs1_ < _rs2_，则向 _rd_ 写入 1，否则写入 0。需要注意的是，SLTU _rd_, _x0_, _rs2_ 指令会在 _rs2_ ≠ 0 时将 _rd_ 置为 1，否则置为 0（对应汇编伪指令 SNEZ _rd, rs_）。AND、OR 和 XOR 分别执行按位 与（AND）、或（OR） 和 异或（XOR） 运算。

SLL、SRL 和 SRA 分别对 _rs1_ 进行逻辑左移（SLL）、逻辑右移（SRL） 和算术右移（SRA），移位量由 _rs2_ 的低 5 位 指定。

==== NOP 指令

include::images/wavedrom/nop.adoc[]
[[nop]]
//.NOP 指令

NOP 指令 不会改变任何架构可见的状态，但会推进 `pc` 并增加任何适用的性能计数器的值。NOP 指令的编码为 ADDI _x0, x0, 0_。

[NOTE]
====
NOP 指令 可用于将代码段对齐到微架构上重要的地址边界，或预留空间以便进行内联代码修改。尽管有多种可能的 NOP 编码方式，我们定义了一种标准 NOP 编码，以便支持微架构优化，同时使反汇编输出更易阅读。其他 NOP 编码可用于 <<rv32i-hints>>。

我们选择 ADDI 作为 NOP 的编码方式，因为它在各种系统上最可能以最少的资源执行（如果在解码阶段未被优化掉）。尤其是，该指令只需要读取一个寄存器。此外，在超标量设计中，ADDI 功能单元更有可能可用，因为加法是最常见的操作。特别地，地址生成单元可以使用相同的硬件执行 ADDI 指令，而寄存器-寄存器 ADD 或逻辑/移位操作 则需要额外的硬件支持。
====

=== 控制转移指令
RV32I 提供了两类控制转移指令：无条件跳转 和 条件分支。在 RV32I 中，控制转移指令没有架构可见的延迟槽（delay slot）。

如果跳转目标或被执行的分支目标发生指令访问错误或指令页错误异常，该异常会报告在目标指令上，而不是报告在跳转或分支指令上。

==== 无条件跳转
跳转并链接（JAL） 指令采用 J 型格式，其中 J 型立即数表示一个以 2 字节为单位的有符号偏移量。该偏移量经过符号扩展后，与跳转指令的地址相加，以形成跳转目标地址。因此，JAL 指令的跳转范围为 &#177;1 MiB。JAL 指令会将跳转指令后续指令的地址（'pc'+4）存入寄存器 _rd_。标准的软件调用约定使用 'x1' 作为返回地址寄存器，并使用 'x5' 作为备用链接寄存器。

[NOTE]
====
备用链接寄存器用于调用微代码（millicode）例程（例如用于在压缩代码中保存和恢复寄存器的例程），同时保留常规返回地址寄存器。寄存器 'x5' 被选作备用链接寄存器，因为它在标准调用约定中对应于一个临时寄存器，并且它的编码与常规链接寄存器仅相差 1 位。
====

普通的无条件跳转（汇编伪指令 J）被编码为 JAL，其中 _rd_=`x0`。

include::images/wavedrom/ct-unconditional.adoc[]
[[ct-unconditional]]
//.无条件跳转指令，JAL

间接跳转指令 JALR（Jump and Link Register） 采用 I 型格式进行编码。目标地址由寄存器 _rs1_ 与符号扩展的 12 位 I 型立即数相加得到，并将计算结果的最低有效位清零。跳转指令后续指令的地址（`pc`+4）被写入寄存器 _rd_。如果不需要保存返回地址，可以使用寄存器 'x0' 作为目标寄存器。

include::images/wavedrom/ct-unconditional-2.adoc[]
[[ct-unconditional-2]]
//.间接无条件跳跃指令，JALR

[NOTE]
====
无条件跳转指令全部采用 PC 相对寻址，以支持位置无关代码（PIC）。JALR 指令 被设计为支持两条指令的组合序列，从而能够跳转到 32 位绝对地址范围 的任意位置。一条 LUI 指令可以先将目标地址的高 20 位加载到 _rs1_，然后 JALR 可以将低位加上去。同样，AUIPC + JALR 可以跳转到 32 位 PC 相对地址范围内的任意位置。

需要注意的是，JALR 指令的 12 位立即数并不像条件分支指令那样以 2 字节为单位，这避免了在硬件中增加额外的立即数格式。在实际应用中，大多数 JALR 指令的立即数要么为 0，要么与 LUI 或 AUIPC 组合使用，因此这一点对跳转范围的影响不大。

在计算 JALR 目标地址 时，将最低有效位（LSB）清零，这样既可以简化硬件，也可以利用指针的最低位存储附加信息。尽管这种方式可能会略微降低错误检测能力，但在实际应用中，如果跳转到错误的指令地址，通常会迅速触发异常。

当 JALR 的基地址寄存器 _rs1_=`x0` 时，它可以实现单条指令的子程序调用，从地址空间的任意位置跳转到最低或最高地址区域，这可以用于快速调用小型运行时库。或者，某个 ABI（应用二进制接口）也可以专门保留一个通用寄存器，用于指向地址空间中的库。
====

如果 JAL 或 JALR 指令的目标地址未对齐至 4 字节边界，则会触发指令地址未对齐（instruction-address-misaligned） 异常。

[NOTE]
====
在支持 16 位对齐指令（例如压缩指令集扩展 C）的机器上，不会发生指令地址未对齐（instruction-address-misaligned） 异常。
====

返回地址预测栈（Return-Address Prediction Stacks，RAS） 是高性能指令取指单元中的常见功能，但要有效工作，必须准确检测用于过程调用和返回的指令。在 RISC-V 中，指令的用途提示（hints）是通过使用的寄存器编号来隐式编码的。JAL 指令仅在 _rd_ 为 'x1' 或 'x5' 时，才应将返回地址压入 返回地址栈（RAS）。JALR 指令的 RAS 推入/弹出 规则如 <<rashints>> 所示。

[[rashints]]
.JALR 指令中由寄存器操作数编码的返回地址栈预测提示。
[%autowidth,float="center",align="center",cols="^,^,^,<",options="header"]
|===
|_rd_ 为 _x1/x5_ |_rs1_ 为 _x1/x5_ |_rd_=_rs1_ |RAS 操作

|否 |否 |-- |无

|否 |是 |-- |弹出

|是 |否 |-- |压入

|是 |是 |是 |弹出后压入

|是 |是 |是 |压入
|===


[NOTE]
====
某些其他 ISA 在它们的间接跳转指令中添加了显式提示位，用于引导返回地址栈（RAS）的操作。而在 RISC-V 中，我们采用了基于寄存器编号和调用约定的隐式提示机制，从而减少了编码空间的占用。

当 两个不同的链接寄存器（`x1` 和 `x5`）分别用于 _rs1_ 和 _rd_ 时，RAS 会同时执行弹出（pop）和压入（push）操作，以支持协程（coroutines）。如果 _rs1_ 和 _rd_ 是相同的链接寄存器（`x1` 或 `x5`），则 RAS 仅执行压入（push）操作，以支持宏指令融合（macro-op fusion），如以下指令序列：`lui ra, imm20; jalr ra, imm12(ra)_ 和 _auipc ra, imm20; jalr ra, imm12(ra)`
====

==== 条件分支

所有分支指令均采用 B 型指令格式。12 位 B 型立即数 以 2 字节 为单位编码有符号偏移量。该偏移量经过符号扩展后，与分支指令的地址相加，以计算目标地址。条件分支的跳转范围为 &#177;4 KiB。

include::images/wavedrom/ct-conditional.adoc[]
[[ct-conditional]]
//.条件分支

分支指令比较两个寄存器。当寄存器 _rs1_ 和 _rs2_ 分别相等或不等时 BEQ 或 BNE 跳转。如果 _rs1_ 小于 _rs2_，分别使用有符号和无符号比较来执行 BLT 和 BLTU 分支。如果 _rs1_ 大于或等于 _rs2_，分别使用有符号和无符号比较来执行 BGE 和 BGEU 分支。 注意，BGT、BGTU、BLE 和 BLEU 可以通过分别逆转 BLT、BLTU、BGE 和 BGEU 的操作数来实现。

[NOTE]
====
带符号的数组边界检查可以通过单条 BLTU 指令完成，因为任何负索引都会被判定为大于任意非负边界。
====

软件应优化顺序执行路径，使其成为最常见的执行路径，并将较少执行的代码路径放置在主线代码之外。此外，软件应假设向后分支（backward branches）默认会被预测为执行，而向前分支（forward branches）默认会被预测为不执行，至少在它们首次遇到时如此。动态预测器应该能够快速学习可预测的分支行为。

与某些其他架构不同，RISC-V 无条件跳转 应始终使用 跳转指令（JAL，且 _rd_=`x0`），而不是使用条件分支指令并设定一个始终为真的条件。RISC-V 跳转指令 采用 PC 相对寻址，支持的偏移范围比分支指令更广，并且不会污染条件分支预测表。

[TIP]
====
条件分支指令被设计为直接在两个寄存器之间执行算术比较（与 PA-RISC、Xtensa 和 MIPS R6 类似），而不是使用条件码（condition codes）（如 x86、ARM、SPARC、PowerPC），也不是仅将一个寄存器与零比较（如 Alpha、MIPS），或仅支持两个寄存器的相等性比较（如 MIPS）。这一设计的动机在于，合并比较与分支的指令（compare-and-branch） 可以很好地适应流水线结构，避免额外的条件码状态或临时寄存器的使用，并且可以减少静态代码大小以及动态指令取指流量。另一个考虑点是，对零的比较在电路实现上并非简单（特别是在先进制程转向静态逻辑后），其延迟几乎与算术大小比较相当。此外，融合的比较-分支指令 使得分支指令可以更早在指令流前端被检测到，从而更早进行预测。在某些情况下，基于条件码的设计 可能有一定优势，例如多个分支可以基于相同的条件码执行，但我们认为这种情况相对罕见。

我们曾考虑在指令编码中加入静态分支提示（static branch hints），但最终未采纳。静态分支提示可以减少对动态预测器的压力，但它们需要占用额外的指令编码空间，并且需要依赖软件分析（profiling） 才能获得最佳效果。此外，如果实际运行环境（production runs）与分析环境（profiling runs）不匹配，可能会导致性能下降。

我们曾考虑加入条件移动（conditional moves）或谓词化指令（predicated instructions），它们可以有效替代不可预测的短向前分支，但最终未采纳。条件移动是两者中更简单的方案，但如果条件代码涉及可能引发异常的操作（如内存访问或浮点运算），使用起来会较为困难。谓词化指令会引入额外的标志状态，需要额外的指令 来设置和清除标志，并且增加每条指令的编码开销。此外，条件移动和谓词化指令都会增加乱序执行微架构（out-of-order microarchitecture）的复杂度，因为当谓词条件为假时，仍需将目标架构寄存器的原始值复制到重命名的物理寄存器，这相当于引入了一个隐式的第三源操作数。此外，编译时静态决定使用谓词化而非分支 可能会在未包含在编译器训练集中的输入上导致性能下降。特别是考虑到不可预测的分支较为罕见，而且随着分支预测技术的改进，它们变得越来越少，这种问题会更加突出。

我们注意到，已有多种微架构技术可用于动态转换不可预测的短向前分支为内部谓词化代码，以避免分支预测失败时的流水线清空开销 cite:[heil-tr1996], cite:[Klauser-1998], cite:[Kim-micro2005]，并且这些技术已在商业处理器中得到应用 cite:[ibmpower7]。最简单的技术仅降低短向前分支预测失败后的恢复开销，方法是仅清空分支阴影（branch shadow）内的指令，而非整个取指流水线，或者通过宽指令取指（wide instruction fetch） 或空闲指令取指槽（idle instruction fetch slots），同时从分支的两侧取指。对于乱序执行核心（out-of-order cores），更复杂的技术会在分支阴影中的指令上添加内部谓词（internal predicates），并由分支指令写入谓词值，使得分支及其后续指令可以相对于其他代码进行推测执行和乱序执行。
====

如果条件分支指令的目标地址未对齐至 4 字节边界，并且分支条件计算结果为真，则会触发 instruction-address-misaligned（指令地址未对齐） 异常。如果分支条件计算结果为假，则不会触发该异常。

[NOTE]
====
在支持 16 位对齐指令（例如压缩指令集扩展 C）的机器上，不会发生 instruction-address-misaligned（指令地址未对齐） 异常。
====

[[ldst]]
=== 加载和存储指令

RV32I 是一种 加载-存储（load-store）架构，其中只有加载和存储指令可以访问内存，而算术指令仅能对 CPU 寄存器进行操作。RV32I 提供了32 位地址空间，并采用字节寻址。EEI（Execution Environment Interface，执行环境接口） 将定义 地址空间的哪些部分可以被哪些指令访问（例如，某些地址可能仅可读，或仅支持字（word）访问）。如果加载指令的目标寄存器是 'x0'，尽管加载的值会被丢弃，但仍然必须触发异常，并引发所有相关的副作用。

EEI 还将定义内存系统的字节序（小端或大端）。在 RISC-V 中，字节序对字节地址是不变的（byte-address invariant）。

[TIP]
====
在字节序对字节地址不变（byte-address invariant）的系统中，以下性质成立：如果在某种字节序下将一个字节存入某个内存地址，那么无论采用何种字节序，从该地址加载一个字节时，都应返回存储的值。

在小端（little-endian）配置中，多字节存储操作会将寄存器的最低有效字节存入最低的内存字节地址，随后按从低到高的顺序存储其他字节。加载时，同样将较低内存地址的字节传输到寄存器的低有效字节。

在大端（big-endian）配置中，多字节存储操作会将寄存器的最高有效字节存入最低的内存字节地址，随后按从高到低的顺序存储其他字节。加载时，同样将较高内存地址的字节传输到寄存器的低有效字节。
====

include::images/wavedrom/load_store.adoc[]
[[load-store,加载和存储]]
//.加载和存储指令

加载和存储指令负责在寄存器和内存之间传输数据。加载指令采用 I 型格式进行编码，而存储指令采用 S 型格式。有效地址由寄存器 _rs1_ 与符号扩展的 12 位偏移量相加得到。加载指令从内存读取值并存入寄存器 _rd_，存储指令则将寄存器 _rs2_ 的值写入内存。

LW 指令从内存加载 32 位值到 _rd_。 LH 指令从内存加载 16 位 值，并在存入 rd 前进行符号扩展至 32 位。LHU 指令从内存加载 16 位 值，但在存入 _rd_ 前进行零扩展至 32 位。LB 和 LBU 指令对 8 位 值的加载方式类似。SW、SH 和 SB 指令分别从寄存器 _rs2_ 的低位取出 32 位、16 位 和 8 位 数据，并存入内存。

无论 EEI 如何定义，自然对齐（naturally aligned） 的加载和存储指令不会触发地址未对齐（address-misaligned）异常。但如果有效地址未按数据类型自然对齐（即地址不能被访问数据的字节大小整除），其行为则由 EEI 规定。

EEI 可以保证完全支持不对齐的加载和存储，因此在执行环境中运行的软件将永远不会遇到限制性或致命的地址不对齐陷阱。在这种情况下，不对齐的加载和存储可以在硬件中处理，或通过 EEI 中的一个不可见陷阱（invisible trap）来处理，或者可能视地址情况结合使用硬件和不可见陷阱。

EEI 可能无法保证以隐性方式处理不对齐的加载和存储。在这种情况下，那些未自然对齐的加载和存储要么成功完成执行，要么引发异常。引发的异常可以是地址不对齐异常或访问故障异常。对于由于不对齐而无法完成的内存访问，如果不应模拟未对齐访问（例如，访问内存区域有副作用），可以引发访问故障异常，而不是地址不对齐异常。当 EEI 不保证未对齐的加载和存储以隐性方式处理时，EEI 必须定义地址未对齐导致的异常是引发限制性陷阱（允许执行环境中的软件处理该陷阱）还是引发致命陷阱（终止执行）。

[TIP]
====
在移植旧代码时，偶尔需要未对齐访问，并且在使用任意形式的 packeted-SIMD 扩展或处理外部打包的数据结构时，它们有助于提高应用程序的性能。允许 EEI 通过常规加载和存储指令来选择支持未对齐访问的理由是为了简化不对齐硬件支持的实现。一个选项是禁止在基础 ISA 中进行未对齐访问，然后提供一些单独的 ISA 支持未对齐访问，或是特别的指令来帮助软件处理未对齐访问，或者是对未对齐访问提供新的硬件寻址模式。特殊指令难以使用，复杂化 ISA，并且通常需要添加新的处理器状态（例如，SPARC VIS 对齐地址偏移寄存器）或使对现有处理器状态的访问复杂化（例如，MIPS LWL/LWR 部分寄存器写入）。此外，对于面向循环的 packeted-SIMD 代码，当操作数未对齐时增加的额外开销促使软件根据操作数对齐提供多种形式的循环，这使代码生成变得复杂，并且增加循环启动的开销。新的未对齐硬件寻址模式占据指令编码中的大量空间，或许需要非常简化的寻址模式（例如，仅支持寄存器间接寻址）。
====

即使未对齐加载和存储成功完成，这些访问根据实现可能运行得极慢（例如，通过透明陷阱实现时）。此外，虽然自然对齐的加载和存储被保证以原子方式执行，未对齐的加载和存储则不一定，因此需要额外的同步来确保原子性。

[NOTE]
====
我们不强制要求未对齐访问的原子性，因此执行环境实现可以使用不可见的机器陷阱和软件处理程序来处理部分或全部未对齐访问。如果提供了硬件未对齐支持，软件可以通过简单地使用常规的加载和存储指令来利用这一点。然后，硬件可以根据运行时地址是否对齐来自动优化访问。
====

[[fence]]
=== 内存排序指令

include::images/wavedrom/mem_order.adoc[]
[[mem-order]]
//.内存排序指令

FENCE 指令用于对其他 RISC-V 处理核和外部设备或协处理器查看的设备 I/O 和内存访问进行排序。设备输入（I）、设备输出（O）、内存读取（R）和内存写入（W）的任何组合都可以按照指定的顺序排序到任意其他的组合。 非正式地说，没有其他 RISC-V 硬件线程或外部设备可以在 FENCE 之前的 前驱（_predecessor_） 集合中的任何操作之前观察到 FENCE 之后的 后继（_successor_） 集合中的任何操作。<<memorymodel>> 精确描述了 RISC-V 内存一致性模型。

FENCE 指令还对硬件线程执行的内存读取和写入进行排序，这些内存读取和写入由外部设备观察到。然而，FENCE 不会使用任何其他信号机制来对外部设备所进行的事件观察进行排序。

[NOTE]
====
设备可能通过一些外部通信机制观察到对某个内存位置的访问，例如，一个将中断信号驱动到中断控制器的内存映射控制寄存器。这种通信不在 FENCE 排序机制的范围内，因此 FENCE 指令无法保证中断信号的变化何时对中断控制器可见。特定设备可能提供额外的排序保证以减少软件开销，但这些超出了 RISC-V 内存模型的范围。
====

EEI 将定义哪些 I/O 操作是可能的，特别是当由加载和存储指令访问时，哪些内存地址被视为设备输入和设备输出操作并排序，而非内存读取和写入。例如，内存映射 I/O 设备通常通过未缓存的加载和存储访问，这些加载和存储使用 I 和 O 位而不是 R 和 W 位进行排序。指令集扩展还可能描述新的 I/O 指令，这些指令也将使用 FENCE 中的 I 和 O 位进行排序。

[[fm]]
[float="center",align="center",cols="^1,^1,<3",options="header"]
.Fence 模式编码
|===
|_fm_ 字段 |助记符 |含义
|0000 |_none_ |普通 Fence
|1000 |TSO |使用 `FENCE RW,RW`：排除写-到-读排序；否则：保留供未来使用。
2+|其他|保留供未来使用。
|===

Fence 模式字段 _fm_ 定义了 `FENCE` 的语义。 当 `FENCE` 的 _fm_=`0000` 时将其前驱集合中的所有内存操作排在其后继集合中的所有内存操作之前。

`FENCE.TSO` 指令被编码为 _fm_=`1000`、_predecessor_=`RW` 和 _successor_=`RW` 的 `FENCE` 指令。`FENCE.TSO` 将其前驱集合中的所有加载操作排在其后继集合中的所有内存操作之前，并将其前驱集合中的所有存储操作排在其后继集合中的所有存储操作之前。这使得 `FENCE.TSO` 的前驱集合中的 `非-AMO` 存储操作与其后继集合中的 `非-AMO` 加载操作无序。

[NOTE]
====
因为 FENCE RW,RW 施加了 FENCE.TSO 施加的排序的超集，所以忽略 _fm_ 字段并将 FENCE.TSO 实现为 FENCE RW,RW 是正确的。
====

`FENCE` 指令中的未使用字段 _rs1_ 和 _rd_ 保留用于未来扩展中更精细的 fence 操作。为了向前兼容，基础实现应忽略这些字段，标准软件应将这些字段置零。同样，<<fm>> 中的许多 _fm_ 和前驱/后继集合设置也保留供将来使用。基本实现应将所有此类保留配置视为 _fm_=0000 的普通 fence，标准软件应仅使用非保留配置。

[TIP]
====
我们选择了一种宽松的内存模型，以允许简单的机器实现以及未来可能的协处理器或加速器扩展实现高性能处理。我们将 I/O 顺序与内存 R/W 顺序分开，以避免设备驱动程序处理核心中的不必要排序，并支持替代的非内存路径来控制添加的协处理器或 I/O 设备。简单的实现还可以忽略 _predecessor_ 和 _successor_ 字段，并始终对所有操作执行保守的 fence 操作。
====

=== 环境调用和断点
`SYSTEM` 指令用于访问可能需要特权访问的系统功能，并使用 I 型指令格式进行编码。这些功能可以分为两大类：以原子方式读-修改-写控制和状态寄存器 (CSR) 的指令，以及所有其他可能的特权指令。CSR 指令在 <<csrinsts>> 中描述，而基本的非特权指令在下一节中描述。


[TIP]
====
SYSTEM 指令定义为简单的实现陷入单个软件陷阱处理程序的指令。更复杂的实现可能在硬件中执行更多的 SYSTEM 指令。
====

include::images/wavedrom/env_call-breakpoint.adoc[]
[[env-call]]
//.环境调用和断点指令

这两条指令会给支持的执行环境引发精确的陷阱请求。

ECALL 指令用于对执行环境进行服务请求。EEI 将定义如何传递服务请求的参数，通常这些参数位于整数寄存器堆中。

EBREAK 指令用于返回到调试环境。

[NOTE]
====
ECALL 和 EBREAK 以前分别称为 SCALL 和 SBREAK。这些指令具有相同的功能和编码，被重命名以反映它们可以更广泛地使用，而不仅仅用于调用监督级操作系统或调试器。
====

[TIP]
====
EBREAK 主要设计用于停止程序运行并返回调试器。EBREAK 也被标准 gcc 编译器用来标记不应执行的代码路径。

EBREAK 的另一个用途是支持“半主机化”。其执行环境含有调试器，使用 EBREAK 指令替代系统调用接口提供服务。由于 RISC-V 基础 ISA 仅提供一个 EBREAK 指令，RISC-V 半主机化使用特殊的指令顺序来区分半主机化 EBREAK 和调试器插入的 EBREAK。

[source,asm]
....
    slli x0, x0, 0x1f   # 入口 NOP
    ebreak              # 跳转到调试器
    srai x0, x0, 7      # 使用 NOP 编码编号为 7 的半主机调用
....

请注意，这三条指令必须是 32 位宽指令，即，它们不应该是 <<compressed>> 中描述的 16 位压缩指令之一。

移位 NOP 指令仍然可用作为 HINTs。

半主机化是一种服务调用形式，更自然的编码方式是使用 ECALL 编码到现有的 ABI。但这需要调试器能够拦截 ECALL，这是调试标准的新功能。我们打算转向使用标准 ABI 的 ECALL，在这种情况下，半主机化可以与现有标准共享服务 ABI。

我们注意到在较新的设计中，ARM 处理器也已转向使用 SVC 而不是 BKPT 进行半主机调用。
====

=== HINT 指令
//[#rv32i-hints,HINT 指令]

[[rv32i-hints,HINT 指令]]

RV32I 为 HINT 指令预留了很大的编码空间，通常用于向微架构传达性能提示。与 NOP 指令一样，HINT 不会更改任何架构上可见的状态，除了增加 `pc` 和影响相关的性能计数器。 实现总是被允许忽略 HINT。

大多数 RV32I HINT 被编码为 _rd_=x0 的整数计算指令。其他的 RV32I HINT 被编码为 FENCE 指令，具有空的前驱或后继集合，并且 _fm_=0。

[NOTE]
====
简单的实现可以完全忽略 HINT，将 HINT 作为不改变架构状态的常规指令来执行。例如，当目标寄存器是 `x0`，ADD 指令就是一个 HINT；五位的 _rs1_ 和 _rs2_ 字段编码了 HINT 的参数。但是，简单的实现可以将 HINT 执行为 _rs1_ 和 _rs2_ 的 ADD，写入 `x0`，这对架构没有可见的影响。

另一个例子是，具有零 _pred_ 字段和零 _fm_ 字段的 FENCE 指令是 HINT；_succ_、_rs1_ 和 _rd_ 字段被编码为 HINT 的参数。简单的实现可以将这种 HINT 作为 FENCE 执行，将前驱内存访问的空集排序到任意被编码到 _succ_ 字段的后继内存访问之前。由于前驱和后继集合的交集为空，该指令不强加任何内存排序，因此在架构上没有可见的效果。
====

<<t-rv32i-hints>> 列出了所有 RV32I HINT 代码点。91% HINT 空间预留用于标准 HINT。HINT 空间的其余部分被指定用于自定义 HINT，在这个子空间中不会定义任何标准 HINT。

[TIP]
====
我们预期标准提示将最终包括内存系统的空间和时间局部性提示、分支预测提示、线程调度提示、安全标签和用于仿真/模拟的工具标志。
====

该表可能仍存在一些问题——某些行可能没有正确到位。需要逐格检查。

[[t-rv32i-hints]]
.RV32I 提示指令。
[float="center",align="center",cols="<,<,^,<",options="header"]
|===
|指令 |约束 |代码点 |目的

|LUI |_rd_=`x0` |latexmath:[$2^{20}$] .8+<.^m|设计用于未来标准使用。

|AUIPC |_rd_=`x0` |latexmath:[$2^{20}$]

|ADDI |_rd_=`x0`，且 _rs1_&#8800;``x0`` 或 _imm_&#8800;0 |latexmath:[$2^{17}-1$]

|ANDI |_rd_=`x0` |latexmath:[$2^{17}$]

|ORI |_rd_=`x0` |latexmath:[$2^{17}$]

|XORI |_rd_=`x0` |latexmath:[$2^{17}$]

|ADD |_rd_=`x0`, _rs1_&#8800;``x0`` |latexmath:[$2^{10}-32$]

|ADD |_rd_=`x0`, _rs1_=`x0`, _rs2_&#8800;``x2-x5`` | 28

|ADD |_rd_=`x0`, _rs1_=`x0`, _rs2_=`x2-x5` |4|(_rs2_=`x2`) NTL.P1 + 
(_rs2_=`x3`) NTL.PALL +
(_rs2_=`x4`) NTL.S1 +
(_rs2_=`x5`) NTL.ALL

|SUB |_rd_=`x0` |latexmath:[$2^{10}$] .11+<.^m|设计用于未来标准使用。

|AND |_rd_=`x0` |latexmath:[$2^{10}$]

|OR |_rd_=`x0` |latexmath:[$2^{10}$]

|XOR |_rd_=`x0` |latexmath:[$2^{10}$]

|SLL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRA |_rd_=`x0` |latexmath:[$2^{10}$]

|FENCE|_rd_=`x0`, _rs1_&#8800;``x0``, _fm_=0, and either _pred_=0 or _succ_=0| latexmath:[$2^{10}-63$]

|FENCE|_rd_&#8800;``x0``, _rs1_=`x0`, _fm_=0, and either _pred_=0 or _succ_=0| latexmath:[$2^{10}-63$]

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=0, _succ_&#8800;0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_&#8800;W, _succ_=0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=W, _succ_=0 |1 |PAUSE

4+| 

|SLTI |_rd_=`x0` |latexmath:[$2^{17}$] .7+<.^m|设计用于自定义使用。

|SLTIU|_rd_=`x0` |latexmath:[$2^{17}$]

|SLLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRAI |_rd_=`x0` |latexmath:[$2^{10}$]

|SLT |_rd_=`x0` |latexmath:[$2^{10}$]

|SLTU |_rd_=`x0` |latexmath:[$2^{10}$]
|===

