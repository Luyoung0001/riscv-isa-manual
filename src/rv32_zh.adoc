[[rv32]]
== RV32I 基本整数指令集，版本 2.1

本章描述了 RV32I 基本整数指令集。

[TIP]
====
设计 RV32I 是为了足够支持编译器目标以及现代操作系统环境。该 ISA 也被设计为实现最小化时减少所需的硬件。RV32I 包含 40 条唯一指令，一个简单的实现可能会使用单个系统硬件指令覆盖 ECALL/EBREAK 指令，并且可能将 FENCE 指令实现为 NOP，从而将基础指令数减少到 38。RV32I 可以模拟几乎任何其他 ISA 扩展（除了 A 扩展，因为它需要额外的硬件支持以实现原子性）。

实际上，包括机器模式特权架构的硬件实现也需要 6 条 CSR 指令。

基础整数 ISA 的子集可能对教学目的有用，但基础 ISA 已被定义为，在实际硬件实现中，除了省略对非对齐内存访问的支持并将所有 SYSTEM 指令视为单一陷阱之外，几乎没有必要再进行子集化。
====

[NOTE]
====
标准的 RISC-V 汇编语言语法记录在《汇编程序员手册》中 cite:[riscv-asm-manual]。
====

[NOTE]
====
对于 RV32I 的大部分描述也适用于 RV64I。
====

=== 基本整数 ISA 的程序员模型

<<gprs>> 描述了非特权基本整数 ISA 的状态。对 RV32I 而言，32 个 `x` 寄存器每个都是 32 位宽，也就是 `XLEN=32`。寄存器 `x0` 的所有位都硬连线到 0。
各种指令将会把通用寄存器 `x1-x31` 保存的值解释为布尔值集合或二进制补码有符号整数或无符号二进制整数。

还有一个额外的非特权寄存器：程序计数器 `pc` 保存当前指令的地址。

[[gprs]]
.RISC-V 基本非特权整数寄存器状态。
[cols="<,^,>",options="header",width="50%",align="center",grid="rows"]
|===
<| [.small]#XLEN-1#| >| [.small]#0#
3+^| [.small]#x0/zero#
3+^| [.small]#x1#
3+^| [.small]#x2#
3+^| [.small]#x3#
3+^| [.small]#x4#
3+^| [.small]#x5#
3+^| [.small]#x6#
3+^| [.small]#x7#
3+^| [.small]#x8#
3+^| [.small]#x9#
3+^| [.small]#x10#
3+^| [.small]#x11#
3+^| [.small]#x12#
3+^| [.small]#x13#
3+^| [.small]#x14#
3+^| [.small]#x15#
3+^| [.small]#x16#
3+^| [.small]#x17#
3+^| [.small]#x18#
3+^| [.small]#x19#
3+^| [.small]#x20#
3+^| [.small]#x21#
3+^| [.small]#x22#
3+^| [.small]#x23#
3+^| [.small]#x24#
3+^| [.small]#x25#
3+^| [.small]#x26#
3+^| [.small]#x27#
3+^| [.small]#x28#
3+^| [.small]#x29#
3+^| [.small]#x30#
3+^| [.small]#x31#
3+^| [.small]#XLEN#
| [.small]#XLEN-1#| >| [.small]#0#
3+^|  [.small]#pc#
3+^| [.small]#XLEN#
|===
[NOTE]
====
在基本整数 ISA 中没有专用的栈指针或子程序来返回地址链接寄存器；指令的编码允许使用任何 `x` 寄存器用于这些目的。然而，标准软件调用约定使用寄存器 `x1` 来保存调用的返回地址，寄存器 `x5` 则可用作备用链接寄存器。标准调用约定使用寄存器 `x2` 作为栈指针。

硬件可能通过使用 `x1` 或 `x5` 加速函数调用和返回。参见 JAL 和 JALR 指令的描述。

可选的压缩 16 位指令格式是基于假设 `x1` 是返回地址寄存器，`x2` 是栈指针。使用其他约定的软件将能正常运行，但可能有更大的代码量。

可用的架构寄存器数量会对代码大小、性能和能耗产生重大影响。尽管 16 个寄存器对于运行编译代码的整数 ISA 来说可能已经足够，但使用 16 位指令和 3 地址格式编码完整 ISA 是不可能的。虽然使用 2 地址格式是可能的，但会增加指令数量并降低效率。
我们希望避免中间指令长度（如 Xtensa 的 24 位指令），以简化基础硬件实现。当采用 32 位指令后，就可以很轻松地支持 32 个整数寄存器。 通过大量使用循环展开、软件流水线、缓存拼接，更多的整数寄存器还有助于高性能代码的性能提升。

出于这些原因，我们为 RV32I 选择了 32 个整数寄存器的传统大小。动态寄存器的使用往往由几个频繁访问的寄存器主导，因此寄存器堆实现可以优化以降低频繁访问寄存器的访问能耗 cite:[jtseng:sbbci]。可选的 16 位压缩指令格式大多只访问 8 个寄存器，因此可以提供紧凑的指令编码，而其他指令集扩展可以根据需要支持更大的寄存器空间（可以是平面或层次结构）。

对于资源受限的嵌入式应用，我们定义了只有 16 个寄存器的 RV32E 子集 (<<rv32e>>) 。
====
=== 基本指令格式
在 RV32I 的基本 ISA 中，有四种核心指令格式（R/I/S/U），如 <<base_instr>> 所示。 它们全都是固定的 32 位长度。基本 ISA 的 `IALIGN=32`，意味着指令必须在内存中四字节边界对齐。如果目标地址不是 `IALIGN-bit` 对齐，则在执行的分支或无条件跳转时会生成指令地址未对齐异常。该异常报告在分支或跳转指令上，而不是目标指令上。对于未执行的条件分支，不生成指令地址未对齐异常。

[NOTE]
====
当添加 16 位长度或其他奇数倍 16 位长度的指令扩展时，基本 ISA 指令的对齐约束放宽为两个字节边界（即 IALIGN=16）。

指令地址未对齐异常报告在会导致指令未对齐的分支或跳转上，以帮助调试，并简化对 IALIGN=32 系统的硬件设计。此处是唯一可能出现指令未对齐异常的地方。
====

解码保留指令时的行为是 UNSPECIFIED 的。

[NOTE]
====
有些平台可能会要求为标准用途保留的操作码引发非法指令异常。一些其他平台可以允许使用保留操作码空间用于不合规的扩展。
====

RISC-V ISA 在所有格式中保持源（_rs1_ 和 _rs2_）和目标（_rd_）寄存器在同一个位置以简化解码。除了在 CSR 指令 (<<csrinsts>>) 中使用的 5 位立即数外，其他立即数始终为符号扩展，并且通常紧靠在指令中最左侧可用位置进行放置，同时也为减少硬件复杂度进行了分配。特别地，所有立即数的符号位总是在指令的第 31 位，以加快符号扩展电路。

include::images/wavedrom/instruction_formats.adoc[] 
[[base_instr,基本指令格式]]
RISC-V 基本指令格式。每个立即子字段都标有所生成的立即值的位位置（imm[x]），而不是通常使用的指令的立即数字段内的位位置。

[NOTE]
====
解码寄存器规范符通常是在实现中的关键路径上，因此指令格式选择了保持寄存器规范符在所有格式中都在同样的位置，代价是需要在不同的格式之间移动立即数的位（与 RISC-IV，又名 SPUR 相同的特性 cite:[spur-jsscc1989]）。 

实际上，大多数立即数要么很小，要么需要所有 XLEN 位。我们选择了不对称的立即数分割（常规指令中有 12 位，加上一个具有 20 位的特殊加载上位立即数指令）以增加常规指令可用的操作码空间。

立即数是符号扩展的，因为我们没有看到像 MIPS ISA 那样为一些立即数使用零扩展的好处，并希望保持 ISA 尽可能简单。
====

=== 立即数编码变体

处理立即数时还有两种指令格式变体（B/J），如 <<baseinstformatsimm>> 所示。

include::images/wavedrom/immediate_variants.adoc[] 
[[baseinstformatsimm,基本指令格式立即数变体。]]
//.描述 RISC-V 基本指令格式的立即数变体。


S 格式和 B 格式之间的唯一区别是，在 B 格式中，12 位立即数字段用于编码以 2 为倍数的分支偏移量。与传统做法中将指令编码的立即数的所有位在硬件中左移一位不同，在 B 格式中，中间的位（imm[10:1]）和符号位保持在固定位置，而 S 格式中的最低位（inst[7]）则编码了 B 格式中的高位。

同样，U 格式和 J 格式的唯一区别是 20 位立即数在 U 格式中向左移动 12 位形成 U 立即数，J 格式中向左移动 1 位形成 J 立即数。在 U 和 J 格式立即数中的指令位位置选择是为了最大化与其他格式和彼此的重叠。

<<immtypes>> 描述了每个基本指令格式生成的立即数，并标记了哪一个指令位（inst[_y_]）生成了立即数值的每一位。
[[immtypes, 立即数类型]]
.RISC-V 指令生成的立即数的类型。 
include::images/wavedrom/immediate.adoc[]

字段以构造它们值的指令位来标记。符号扩展总是使用 inst[31]。

[NOTE]
====
符号扩展是立即数最重要的操作之一（特别是对于 XLEN>32），并且在 RISC-V 中所有立即数的符号位始终保存在指令的第 31 位，这允许符号扩展与指令解码并行进行。

虽然更复杂的实现可能在分支和跳转计算中使用单独的加法器，因此不会从在指令类型之间保持立即数位位置不变中受益，但我们希望降低最简单实现的硬件成本。通过在 B 和 J 立即数的指令编码中旋转位，而不是使用动态硬件选择器将立即数乘以 2，我们将指令信号扇出和立即数选择器成本降低了大约 2 倍。混乱的立即数编码对静态或预先编译增加的时间可以忽略。对于动态生成指令来说，会有一些小的额外开销，但最常见的短向前分支有着简单的立即数编码。
====

=== 整数计算指令

大多数整数计算指令操作整数寄存器堆中 `XLEN` 位的值。整数计算指令要么被编码为使用 I 类型格式的寄存器-立即数操作，要么被编码为使用 R 类型格式的寄存器-寄存器操作。寄存器-立即数和寄存器-寄存器指令的目标都是寄存器 _rd_。整数计算指令不会引发算术异常。

[TIP]
====
因为许多溢出检查可以用 RISC-V 分支廉价地实现，因此我们没有在基础指令集中加入对算数操作溢出检查的特别支持。对无符号加法的溢出检查仅需在加法后增加一条额外的分支指令：`add t0, t1, t2; bltu t0, t1, overflow`。

对于有符号加法，如果一个操作数的符号已知，溢出检查仅需加法后的一条分支：`addi t0, t1, +imm; blt t0, t1, overflow`。 这覆盖了使用立即数操作数加法的常见情况。

对于一般有符号加法，在加法后需要三条附加指令，基于这样的观察：如果当且仅当一个操作数为负，和应小于另一个操作数。

[source,text]
....
         add t0, t1, t2
         slti t3, t2, 0
         slt t4, t0, t1
         bne t3, t4, overflow
....

在 RV64I 中，可以对 32 位有符号加法的检查进行进一步优化，方法是比较操作数上的 ADD 和 ADDW 的结果。
====

==== 整数寄存器-立即数指令

include::images/wavedrom/integer_computational.adoc[]
//.整数计算指令

ADDI 将符号扩展的 12 位立即数加到寄存器 _rs1_。忽略算术溢出，结果仅为结果的低 XLEN 位。ADDI _rd, rs1, 0_ 用于实现 MV _rd, rs1_ 汇编伪指令。

SLTI（set less than immediate）将值 1 放到寄存器 _rd_ 中，如果寄存器 _rs1_ 小于符号扩展的立即数（两者均作为有符号数处理），否则将 0 写入 _rd_。SLTIU 类似，但将值视为无符号数进行比较（即，立即数先符号扩展为 XLEN 位，再作为无符号数处理）。注意，如果 _rs1_ 等于零，SLTIU _rd, rs1, 1_ 设置 _rd_ 为 1，否则设置 _rd_ 为 0（汇编伪指令 SEQZ _rd, rs_）。

ANDI，ORI，XORI 是逻辑操作，在寄存器 _rs1_ 和符号扩展的 12 位立即数上执行按位与、按位或和按位异或，并将结果放入 _rd_。注意，XORI _rd, rs1, -1_ 执行寄存器 _rs1_ 的按位逻辑取反（汇编伪指令 NOT _rd, rs_）。

include::images/wavedrom/int-comp-slli-srli-srai.adoc[]
[[int-comp-slli-srli-srai]]
//.整数寄存器-立即数，SLLI，SRLI，SRAI

按常量移位被编码为 I 类型格式的一种特殊格式。待移位的操作数在 _rs1_ 中，移位量编码在 I-立即数字段的低 5 位中。右移类型编码在第 30 位。 SLLI 是逻辑左移（零被移入低位）；SRLI 是逻辑右移（零被移入高位）；SRAI 是算术右移（初始符号位被复制到腾空的高位）。

include::images/wavedrom/int-comp-lui-aiupc.adoc[]
[[int-comp-lui-aiupc]]
//.整数寄存器-立即数，U-立即数

LUI（加载上部立即数）用于构建 32 位常量并使用 U 类型格式。LUI 将 32 位 U 立即数值放入目标寄存器 _rd_，用零填充最低的 12 位。

AUIPC（将高位立即数加到 `pc` 上）用于构建 `pc` 相对地址，使用 U 类型格式。AUIPC 从 U 立即数形成 32 位偏移量，用零填充最低的 12 位，将这个偏移量加到 AUIPC 指令的地址上，然后将结果放入寄存器 _rd_。

[NOTE]
====
`lui` 和 `auipc` 的汇编语法没有表示 U-立即数的低 12 位，这些位始终为零。

AUIPC 指令支持两个指令的序列，以便访问从 PC 开始的任意偏移，适用于控制流转移和数据访问。AUIPC 和 JALR 中的 12 位立即数组合，可将控制转移到任意 32 位 PC 相对地址，而 AUIPC 加上常规加载或存储指令中的 12 位立即数偏移，可以访问任何 32 位 PC 相对数据地址。

可以通过将 U-立即数设为 0 来获取当前 PC。尽管 JAL +4 指令也可用于获取本地 PC（即 JAL 之后的指令的 PC），但它可能会在较简单的微架构中引起流水线中断，或者在更复杂的微架构中造成 BTB 结构污染。
====

==== 整数寄存器-寄存器操作

RV32I 定义了几种算术 R 类型操作。所有操作均读取 _rs1_ 和 _rs2_ 寄存器作为源操作数，并将结果写入寄存器 _rd_。_funct7_ 和 _funct3_ 字段选择操作类型。

include::images/wavedrom/int_reg-reg.adoc[]
[[int-reg-reg]]
//.整数寄存器-寄存器

ADD 执行 _rs1_ 和 _rs2_ 的加法。SUB 执行从 _rs1_ 中减去 _rs2_。溢出被忽略，结果的低 XLEN 位被写入目标寄存器 _rd_。SLT 和 SLTU 分别执行有符号和无符号比较，如果 _rs1_ < _rs2_，则将 1 写入 _rd_，否则为 0。注意，SLTU _rd_, _x0_, _rs2_ 会将 _rd_ 设置为 1，如果 _rs2_ 不等于零，否则将 _rd_ 设为 0（汇编伪指令 SNEZ _rd, rs_）。AND、OR 和 XOR 执行按位逻辑运算。

SLL、SRL 和 SRA 按寄存器 _rs2_ 的低 5 位中的移位量，对寄存器 _rs1_ 中的值执行逻辑左移、逻辑右移和算术右移。

==== NOP 指令

include::images/wavedrom/nop.adoc[]
[[nop]]
//.NOP 指令

除了推进 `pc` 和增加任何适用的性能计数器外，NOP 指令不会更改任何架构上可见的状态。NOP 被编码为 ADDI _x0, x0, 0_。

[NOTE]
====
NOP 可以用来将代码段对齐到微架构上重要的地址边界，或为内联代码修改留出空间。虽然可以有多种方式来编码一个 NOP，但我们定义了一种规范的 NOP 编码，以允许微架构优化以及更具可读性的反汇编输出。其他 NOP 编码由 <<rv32i-hints>> 提供。

ADDI 被选为 NOP 的编码，因为这最有可能在众多系统中执行时占用最少资源（如果不在解码过程中优化掉）。特别是，该指令只需要读取一个寄存器。此外，ADDI 功能单元在超标量设计中更可能是可用的，因为 ADD 是最常见的操作。地址生成功能单元可以使用与 ADDI 相同的硬件计算基址加偏移地址计，而寄存器-寄存器的 ADD 或逻辑/移位操作则需要额外的硬件。
====

=== 控制转移指令
RV32I 提供两种类型的控制转移指令：无条件跳转和条件分支。RV32I 中的控制转移指令不具有在架构上可见的延迟槽。

如果跳转或执行分支的目标上发生指令访问错误或指令页面错误异常，该异常将在目标指令上报告，而不是在跳转或分支指令上报告。

==== 无条件跳转
跳转和链接（JAL）指令使用 J 类型格式，其中 J-立即数编码了以 2 字节为倍数的有符号偏移量。偏移量经过符号扩展后，加到跳转指令的地址上，形成跳转目标地址。因此，跳转可以指向 &#177;1 MiB 的范围。JAL 将跳转指令的后一条指令 ('pc'+4) 的地址存入寄存器 _rd_。标准软件调用约定使用 'x1' 作为返回地址寄存器，使用 'x5' 作为备用链接寄存器。

[NOTE]
====
备用链接寄存器支持调用微代码程序（例如，用于保存和恢复压缩代码中的寄存器），同时保留常规返回地址寄存器。选择寄存器 `x5` 作为备用链接寄存器，因为它在标准调用约定中映射到一个临时寄存器，其编码只与常规链接寄存器有一位之差。
====

简单的无条件跳转（汇编伪指令 J）被编码为 _rd_=`x0` 的 JAL。

include::images/wavedrom/ct-unconditional.adoc[]
[[ct-unconditional]]
//.无条件跳转指令，JAL

间接跳转指令 JALR（jump and link register）使用 I 型编码。目标地址是通过将符号扩展的 12 位 I 立即数加到寄存器 _rs1_ 上获得的，然后将结果的最低有效位设为零。跳转指令的后一条指令的地址 (`pc`+4) 被写入寄存器 _rd_。如果不需要结果，可以使用寄存器 `x0` 作为目标。

include::images/wavedrom/ct-unconditional-2.adoc[]
[[ct-unconditional-2]]
//.间接无条件跳跃指令，JALR

[NOTE]
====
无条件跳转指令均使用 PC 相对寻址，以帮助支持位置无关代码。JALR 指令允许两条指令跳转到 32 位绝对地址范围的任何位置。LUI 指令可以先使用目标地址的高 20 位加载 _rs1_，然后在 JALR 中添加低位。同样地，先使用 AUIPC 再通过 JALR 可以跳转到 32 位 `pc` 相对地址范围的任何位置。

注意，JALR 指令不像条件分支指令那样将 12 位立即数视为 2 字节的倍数。这就避免了硬件中多一种立即数格式。实际上，大多数使用 JALR 的情况要么是立即数为零，要么与 LUI 或 AUIPC 配对，因此范围略微减少并不重要。

在计算 JALR 目标地址时清除最低有效位，这既稍微简化了硬件，又允许函数指针的低位用于存储辅助信息。尽管在这种情况下可能会略微减少错误检查，但实际上跳转到错误的指令地址通常会很快引发异常。

当与基地址 _rs1_=`x0` 一起使用时，JALR 可用于单指令从任意地址跳转到地址空间中的最低或最高地址区域，这可以用于实现对小型运行时库的快速调用。也可以有一个 ABI 专门划定一个通用寄存器用于指向地址空间中某个地方的库。
====

如果目标地址没有对齐到四字节边界，JAL 和 JALR 指令将产生指令地址未对齐异常。

[NOTE]
====
在支持 16 位对齐指令扩展（例如压缩指令集扩展 C）的机器上，不可能出现指令地址未对齐异常。
====

返回地址预测栈是高性能指令获取单元的常见特性，但有效实现需要准确地检测函数调用和返回的指令。对于 RISC-V，关于指令用法的提示是通过使用的寄存器编号隐式编码的。仅当 _rd_ 为 'x1' 或 `x5` 时，JAL 指令将返回地址压入返回地址堆栈 (RAS)。JALR 指令应根据 <<rashints>> 中所示进行 RAS 的推入/弹出。

[[rashints]]
.JALR 指令的寄存器的操作数编码了返回地址栈预测的提示。
[%autowidth,float="center",align="center",cols="^,^,^,<",options="header"]
|===
|_rd_ 为 _x1/x5_ |_rs1_ 为 _x1/x5_ |_rd_=_rs1_ |RAS 操作

|否 |否 |-- |无

|否 |是 |-- |弹出

|是 |否 |-- |压入

|是 |是 |是 |弹出后压入

|是 |是 |是 |压入
|===


[NOTE]
====
一些其他 ISA 为返回地址栈在间接跳转指令中添加了显式提示位。我们使用与寄存器编号和调用约定相关的隐式提示以减少这些提示所使用的编码空间。

当 _rs1_ 和 _rd_ 分别被设置为两个不同的链接寄存器（`x1` 和 `x5`）时，RAS 会弹出并压入以支持协程。如果 _rs1_ 和 _rd_ 是相同的链接寄存器（`x1`或`x5`），则以下序列将推入 RAS 以启用指令融合：`lui ra, imm20; jalr ra, imm12(ra)_ 和 _auipc ra, imm20; jalr ra, imm12(ra)`
====

==== 条件分支

所有分支指令都使用 B 型指令格式。 12 位 B-立即数编码了以 2 字节为单位的有符号偏移。偏移量是符号扩展的，目标地址为分支指令的地址加上偏移量。条件分支的范围是 &#177;4 KiB。

include::images/wavedrom/ct-conditional.adoc[]
[[ct-conditional]]
//.条件分支

分支指令比较两个寄存器。当寄存器 _rs1_ 和 _rs2_ 分别相等或不等时 BEQ 或 BNE 跳转。如果 _rs1_ 小于 _rs2_，分别使用有符号和无符号比较来执行 BLT 和 BLTU 分支。如果 _rs1_ 大于或等于 _rs2_，分别使用有符号和无符号比较来执行 BGE 和 BGEU 分支。 注意，BGT、BGTU、BLE 和 BLEU 可以通过分别逆转 BLT、BLTU、BGE 和 BGEU 的操作数来实现。

[NOTE]
====
有符号数组的边界可以通过单个 BLTU 指令进行检查，因为任何负索引都将大于任何非负边界。
====

软件应该进行使得顺序代码路径成为最常用的路径，而较少使用的代码路径则置于顺序之外的优化。软件还应该假设向后分支会被预测为执行，而向前分支则被预测为不执行，至少在第一次遇到时如此。动态预测器应该迅速学习任何可预测的分支行为。

不同于一些其他架构，RISC-V 跳转（使用 _rd_=`x0` 的 JAL）指令应始终用于无条件分支，而不是使用条件始终为真的条件分支指令。RISC-V 跳转也是相对于 PC 的，支持的偏移范围比分支广得多，并且不会污染条件分支预测表。

[TIP]
====
条件分支被设计为包括在两个寄存器之间的算术比较操作（正如在 PA-RISC、Xtensa 和 MIPS R6 中所做的那样），而不是使用条件码（x86、ARM、SPARC、PowerPC）或仅将一个寄存器与零进行比较（Alpha、MIPS），或仅检查两个寄存器是否相等（MIPS）。这个设计的动机是观察到合并的比较和分支指令更适合常规流水线，避免了额外的条件码状态或使用临时寄存器，并减少静态代码大小和动态指令提取流量。另一个观点是，与零进行比较会要求复杂的电路延时（尤其是在先进工艺中转向静态逻辑之后），因此与大小比较的代价几乎相同。融合比较和分支指令的另一个优点是分支在前端指令流中可以更早地出现，因此可以更早地被预测。在使用条件码并且多个分支基于相同条件码的情况下，设计可能会有一些优势，但我们相信这种情况相对较少。

我们考虑过，但并没有在指令编码中包含静态分支提示。这可以减少动态预测器的压力，但需要更多的指令编码空间和软件分析以获得最佳结果，且如果生成的代码不匹配分析的运行情况将导致性能下降。

我们考虑过，但没有采纳条件移动或预测指令，这些指令可以有效替代不可预测的短正向分支（short forward branches）。条件移动是其中较简单的，但难以用于处理可能引发异常（内存访问和浮点操作）的条件代码。预测指令为系统添加了额外的标志状态、设置和清除标志的额外指令，以及每条指令的额外编码开销。条件移动和谓词指令都增加了乱序微架构的复杂性，由于需要在谓词为假时将目标结构寄存器的初始值复制到重命名的目标物理寄存器中，因此添加了一个隐含的第三个源操作数。此外，静态编译时决定使用预测而不是分支可能会导致编译器训练集中未包含的输入的性能降低，特别是考虑到不可预测的分支很少见，并且随着分支预测技术的改进而变得越来越少见。

我们注意到，一些微架构技术可以动态地将不可预测的短正向分支转换为内部预测代码，以减少分支错误预测时冲刷流水线的代价 cite:[heil-tr1996], cite:[Klauser-1998], cite:[Kim-micro2005] 而这些技术已在商用处理器中实现 cite:[ibmpower7]。最简单的技术是通过仅冲刷分支阴影（branch shadow）中的指令而不是整个流水线，或通过使用宽指令获取或空闲指令获取槽以从两侧获取指令来减少从错误预测的短正向分支恢复的惩罚。对于乱序内核的复杂技术在分支阴影中的指令上添加内部预测，内部预测的值由分支指令写入，从而允许分支指令和后续指令与其他代码相对乱序地推测执行。
====

如果目标地址没有对齐到四字节边界且分支条件为真，条件分支指令将产生指令地址不对齐异常。如果分支条件为假，则不会产生指令地址不对齐异常。

[NOTE]
====
在支持具有 16 位对齐指令扩展（例如压缩指令集扩展 C）的机器上，不可能出现指令地址未对齐异常。
====

[[ldst]]
=== 加载和存储指令
RV32I 是一种加载-存储架构，只有加载和存储指令可以访问内存，而算术指令仅在 CPU 寄存器上操作。RV32I 提供 32 位的字节寻址地址空间。EEI 定义地址空间哪些部分可以合法访问以及哪些指令可以访问（例如，某些地址可能只能读取，或只支持字访问）。即使加载的值被丢弃，目标寄存器为 `x0` 的加载仍然必须引发任何异常并造成副作用。

EEI 将定义内存系统是小端序还是大端序。在 RISC-V 中，字节序是字节地址不变的。

[TIP]
====
在字节序是字节地址不变的系统中，以下属性成立：如果一个字节以某种字节序存储到内存的某个地址，那么从该地址以任何字节序加载字节大小的数据都会返回存储的值。

在小端配置中，多字节存储将最低有效寄存器字节写在最低的内存字节地址，然后按有效位升序写入其他寄存器字节。类似地，加载指令传输较小内存字节地址的内容到较低有效的寄存器字节。

在大端配置中，多字节存储将最高有效寄存器字节写在最低的内存字节地址，然后按有效位降序写入其他寄存器字节。类似地，加载指令传输较大内存字节地址的内容到较低有效的寄存器字节。
====

include::images/wavedrom/load_store.adoc[]
[[load-store,加载和存储]]
//.加载和存储指令

加载和存储指令在寄存器和内存之间传输值。 加载使用 I 型格式编码，存储使用 S 型格式编码。有效地址是通过将寄存器 _rs1_ 加上符号扩展的 12 位偏移获得的。加载将一个值从内存复制到寄存器 _rd_。存储将寄存器 _rs2_ 中的值复制到内存。

LW 指令将一个 32 位值从内存加载到 _rd_。 LH 从内存加载一个 16 位值，然后符号扩展到 32 位后存储到 _rd_ 中。LHU 从内存加载一个 16 位值，随后零扩展到 32 位后存储到 _rd_ 中。LB 和 LBU 分别定义为 8 位值的类似操作。SW、SH 和 SB 指令从寄存器 _rs2_ 的低位向内存存储 32 位、16 位和 8 位值。

无论在什么 EEI 下，加载和存储在其有效地址自然对齐时都不应引发地址不对齐异常。其有效地址未自然对齐到所引用数据类型的加载和存储（即，有效地址不能被访问的字节大小整除）的行为取决于 EEI。

EEI 可以保证完全支持不对齐的加载和存储，因此在执行环境中运行的软件将永远不会遇到限制性或致命的地址不对齐陷阱。在这种情况下，不对齐的加载和存储可以在硬件中处理，或通过 EEI 中的一个不可见陷阱（invisible trap）来处理，或者可能视地址情况结合使用硬件和不可见陷阱。

EEI 可能无法保证以隐性方式处理不对齐的加载和存储。在这种情况下，那些未自然对齐的加载和存储要么成功完成执行，要么引发异常。引发的异常可以是地址不对齐异常或访问故障异常。对于由于不对齐而无法完成的内存访问，如果不应模拟未对齐访问（例如，访问内存区域有副作用），可以引发访问故障异常，而不是地址不对齐异常。当 EEI 不保证未对齐的加载和存储以隐性方式处理时，EEI 必须定义地址未对齐导致的异常是引发限制性陷阱（允许执行环境中的软件处理该陷阱）还是引发致命陷阱（终止执行）。

[TIP]
====
在移植旧代码时，偶尔需要未对齐访问，并且在使用任意形式的 packeted-SIMD 扩展或处理外部打包的数据结构时，它们有助于提高应用程序的性能。允许 EEI 通过常规加载和存储指令来选择支持未对齐访问的理由是为了简化不对齐硬件支持的实现。一个选项是禁止在基础 ISA 中进行未对齐访问，然后提供一些单独的 ISA 支持未对齐访问，或是特别的指令来帮助软件处理未对齐访问，或者是对未对齐访问提供新的硬件寻址模式。特殊指令难以使用，复杂化 ISA，并且通常需要添加新的处理器状态（例如，SPARC VIS 对齐地址偏移寄存器）或使对现有处理器状态的访问复杂化（例如，MIPS LWL/LWR 部分寄存器写入）。此外，对于面向循环的 packeted-SIMD 代码，当操作数未对齐时增加的额外开销促使软件根据操作数对齐提供多种形式的循环，这使代码生成变得复杂，并且增加循环启动的开销。新的未对齐硬件寻址模式占据指令编码中的大量空间，或许需要非常简化的寻址模式（例如，仅支持寄存器间接寻址）。
====

即使未对齐加载和存储成功完成，这些访问根据实现可能运行得极慢（例如，通过透明陷阱实现时）。此外，虽然自然对齐的加载和存储被保证以原子方式执行，未对齐的加载和存储则不一定，因此需要额外的同步来确保原子性。

[NOTE]
====
我们不强制要求未对齐访问的原子性，因此执行环境实现可以使用不可见的机器陷阱和软件处理程序来处理部分或全部未对齐访问。如果提供了硬件未对齐支持，软件可以通过简单地使用常规的加载和存储指令来利用这一点。然后，硬件可以根据运行时地址是否对齐来自动优化访问。
====

[[fence]]
=== 内存排序指令

include::images/wavedrom/mem_order.adoc[]
[[mem-order]]
//.内存排序指令

FENCE 指令用于对其他 RISC-V 处理核和外部设备或协处理器查看的设备 I/O 和内存访问进行排序。设备输入（I）、设备输出（O）、内存读取（R）和内存写入（W）的任何组合都可以按照指定的顺序排序到任意其他的组合。 非正式地说，没有其他 RISC-V 硬件线程或外部设备可以在 FENCE 之前的 前驱（_predecessor_） 集合中的任何操作之前观察到 FENCE 之后的 后继（_successor_） 集合中的任何操作。<<memorymodel>> 精确描述了 RISC-V 内存一致性模型。

FENCE 指令还对硬件线程执行的内存读取和写入进行排序，这些内存读取和写入由外部设备观察到。然而，FENCE 不会使用任何其他信号机制来对外部设备所进行的事件观察进行排序。

[NOTE]
====
设备可能通过一些外部通信机制观察到对某个内存位置的访问，例如，一个将中断信号驱动到中断控制器的内存映射控制寄存器。这种通信不在 FENCE 排序机制的范围内，因此 FENCE 指令无法保证中断信号的变化何时对中断控制器可见。特定设备可能提供额外的排序保证以减少软件开销，但这些超出了 RISC-V 内存模型的范围。
====

EEI 将定义哪些 I/O 操作是可能的，特别是当由加载和存储指令访问时，哪些内存地址被视为设备输入和设备输出操作并排序，而非内存读取和写入。例如，内存映射 I/O 设备通常通过未缓存的加载和存储访问，这些加载和存储使用 I 和 O 位而不是 R 和 W 位进行排序。指令集扩展还可能描述新的 I/O 指令，这些指令也将使用 FENCE 中的 I 和 O 位进行排序。

[[fm]]
[float="center",align="center",cols="^1,^1,<3",options="header"]
.Fence 模式编码
|===
|_fm_ 字段 |助记符 |含义
|0000 |_none_ |普通 Fence
|1000 |TSO |使用 `FENCE RW,RW`：排除写-到-读排序；否则：保留供未来使用。
2+|其他|保留供未来使用。
|===

Fence 模式字段 _fm_ 定义了 `FENCE` 的语义。 当 `FENCE` 的 _fm_=`0000` 时将其前驱集合中的所有内存操作排在其后继集合中的所有内存操作之前。

`FENCE.TSO` 指令被编码为 _fm_=`1000`、_predecessor_=`RW` 和 _successor_=`RW` 的 `FENCE` 指令。`FENCE.TSO` 将其前驱集合中的所有加载操作排在其后继集合中的所有内存操作之前，并将其前驱集合中的所有存储操作排在其后继集合中的所有存储操作之前。这使得 `FENCE.TSO` 的前驱集合中的 `非-AMO` 存储操作与其后继集合中的 `非-AMO` 加载操作无序。

[NOTE]
====
因为 FENCE RW,RW 施加了 FENCE.TSO 施加的排序的超集，所以忽略 _fm_ 字段并将 FENCE.TSO 实现为 FENCE RW,RW 是正确的。
====

`FENCE` 指令中的未使用字段 _rs1_ 和 _rd_ 保留用于未来扩展中更精细的 fence 操作。为了向前兼容，基础实现应忽略这些字段，标准软件应将这些字段置零。同样，<<fm>> 中的许多 _fm_ 和前驱/后继集合设置也保留供将来使用。基本实现应将所有此类保留配置视为 _fm_=0000 的普通 fence，标准软件应仅使用非保留配置。

[TIP]
====
我们选择了一种宽松的内存模型，以允许简单的机器实现以及未来可能的协处理器或加速器扩展实现高性能处理。我们将 I/O 顺序与内存 R/W 顺序分开，以避免设备驱动程序处理核心中的不必要排序，并支持替代的非内存路径来控制添加的协处理器或 I/O 设备。简单的实现还可以忽略 _predecessor_ 和 _successor_ 字段，并始终对所有操作执行保守的 fence 操作。
====

=== 环境调用和断点
`SYSTEM` 指令用于访问可能需要特权访问的系统功能，并使用 I 型指令格式进行编码。这些功能可以分为两大类：以原子方式读-修改-写控制和状态寄存器 (CSR) 的指令，以及所有其他可能的特权指令。CSR 指令在 <<csrinsts>> 中描述，而基本的非特权指令在下一节中描述。


[TIP]
====
SYSTEM 指令定义为简单的实现陷入单个软件陷阱处理程序的指令。更复杂的实现可能在硬件中执行更多的 SYSTEM 指令。
====

include::images/wavedrom/env_call-breakpoint.adoc[]
[[env-call]]
//.环境调用和断点指令

这两条指令会给支持的执行环境引发精确的陷阱请求。

ECALL 指令用于对执行环境进行服务请求。EEI 将定义如何传递服务请求的参数，通常这些参数位于整数寄存器堆中。

EBREAK 指令用于返回到调试环境。

[NOTE]
====
ECALL 和 EBREAK 以前分别称为 SCALL 和 SBREAK。这些指令具有相同的功能和编码，被重命名以反映它们可以更广泛地使用，而不仅仅用于调用监督级操作系统或调试器。
====

[TIP]
====
EBREAK 主要设计用于停止程序运行并返回调试器。EBREAK 也被标准 gcc 编译器用来标记不应执行的代码路径。

EBREAK 的另一个用途是支持“半主机化”。其执行环境含有调试器，使用 EBREAK 指令替代系统调用接口提供服务。由于 RISC-V 基础 ISA 仅提供一个 EBREAK 指令，RISC-V 半主机化使用特殊的指令顺序来区分半主机化 EBREAK 和调试器插入的 EBREAK。

[source,asm]
....
    slli x0, x0, 0x1f   # 入口 NOP
    ebreak              # 跳转到调试器
    srai x0, x0, 7      # 使用 NOP 编码编号为 7 的半主机调用
....

请注意，这三条指令必须是 32 位宽指令，即，它们不应该是 <<compressed>> 中描述的 16 位压缩指令之一。

移位 NOP 指令仍然可用作为 HINTs。

半主机化是一种服务调用形式，更自然的编码方式是使用 ECALL 编码到现有的 ABI。但这需要调试器能够拦截 ECALL，这是调试标准的新功能。我们打算转向使用标准 ABI 的 ECALL，在这种情况下，半主机化可以与现有标准共享服务 ABI。

我们注意到在较新的设计中，ARM 处理器也已转向使用 SVC 而不是 BKPT 进行半主机调用。
====

=== HINT 指令
//[#rv32i-hints,HINT 指令]

[[rv32i-hints,HINT 指令]]

RV32I 为 HINT 指令预留了很大的编码空间，通常用于向微架构传达性能提示。与 NOP 指令一样，HINT 不会更改任何架构上可见的状态，除了增加 `pc` 和影响相关的性能计数器。 实现总是被允许忽略 HINT。

大多数 RV32I HINT 被编码为 _rd_=x0 的整数计算指令。其他的 RV32I HINT 被编码为 FENCE 指令，具有空的前驱或后继集合，并且 _fm_=0。

[NOTE]
====
简单的实现可以完全忽略 HINT，将 HINT 作为不改变架构状态的常规指令来执行。例如，当目标寄存器是 `x0`，ADD 指令就是一个 HINT；五位的 _rs1_ 和 _rs2_ 字段编码了 HINT 的参数。但是，简单的实现可以将 HINT 执行为 _rs1_ 和 _rs2_ 的 ADD，写入 `x0`，这对架构没有可见的影响。

另一个例子是，具有零 _pred_ 字段和零 _fm_ 字段的 FENCE 指令是 HINT；_succ_、_rs1_ 和 _rd_ 字段被编码为 HINT 的参数。简单的实现可以将这种 HINT 作为 FENCE 执行，将前驱内存访问的空集排序到任意被编码到 _succ_ 字段的后继内存访问之前。由于前驱和后继集合的交集为空，该指令不强加任何内存排序，因此在架构上没有可见的效果。
====

<<t-rv32i-hints>> 列出了所有 RV32I HINT 代码点。91% HINT 空间预留用于标准 HINT。HINT 空间的其余部分被指定用于自定义 HINT，在这个子空间中不会定义任何标准 HINT。

[TIP]
====
我们预期标准提示将最终包括内存系统的空间和时间局部性提示、分支预测提示、线程调度提示、安全标签和用于仿真/模拟的工具标志。
====

该表可能仍存在一些问题——某些行可能没有正确到位。需要逐格检查。

[[t-rv32i-hints]]
.RV32I 提示指令。
[float="center",align="center",cols="<,<,^,<",options="header"]
|===
|指令 |约束 |代码点 |目的

|LUI |_rd_=`x0` |latexmath:[$2^{20}$] .8+<.^m|设计用于未来标准使用。

|AUIPC |_rd_=`x0` |latexmath:[$2^{20}$]

|ADDI |_rd_=`x0`，且 _rs1_&#8800;``x0`` 或 _imm_&#8800;0 |latexmath:[$2^{17}-1$]

|ANDI |_rd_=`x0` |latexmath:[$2^{17}$]

|ORI |_rd_=`x0` |latexmath:[$2^{17}$]

|XORI |_rd_=`x0` |latexmath:[$2^{17}$]

|ADD |_rd_=`x0`, _rs1_&#8800;``x0`` |latexmath:[$2^{10}-32$]

|ADD |_rd_=`x0`, _rs1_=`x0`, _rs2_&#8800;``x2-x5`` | 28

|ADD |_rd_=`x0`, _rs1_=`x0`, _rs2_=`x2-x5` |4|(_rs2_=`x2`) NTL.P1 + 
(_rs2_=`x3`) NTL.PALL +
(_rs2_=`x4`) NTL.S1 +
(_rs2_=`x5`) NTL.ALL

|SUB |_rd_=`x0` |latexmath:[$2^{10}$] .11+<.^m|设计用于未来标准使用。

|AND |_rd_=`x0` |latexmath:[$2^{10}$]

|OR |_rd_=`x0` |latexmath:[$2^{10}$]

|XOR |_rd_=`x0` |latexmath:[$2^{10}$]

|SLL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRL |_rd_=`x0` |latexmath:[$2^{10}$]

|SRA |_rd_=`x0` |latexmath:[$2^{10}$]

|FENCE|_rd_=`x0`, _rs1_&#8800;``x0``, _fm_=0, and either _pred_=0 or _succ_=0| latexmath:[$2^{10}-63$]

|FENCE|_rd_&#8800;``x0``, _rs1_=`x0`, _fm_=0, and either _pred_=0 or _succ_=0| latexmath:[$2^{10}-63$]

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=0, _succ_&#8800;0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_&#8800;W, _succ_=0 |15

|FENCE |_rd_=_rs1_=`x0`, _fm_=0, _pred_=W, _succ_=0 |1 |PAUSE

4+| 

|SLTI |_rd_=`x0` |latexmath:[$2^{17}$] .7+<.^m|设计用于自定义使用。

|SLTIU|_rd_=`x0` |latexmath:[$2^{17}$]

|SLLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRLI |_rd_=`x0` |latexmath:[$2^{10}$]

|SRAI |_rd_=`x0` |latexmath:[$2^{10}$]

|SLT |_rd_=`x0` |latexmath:[$2^{10}$]

|SLTU |_rd_=`x0` |latexmath:[$2^{10}$]
|===

