[[vector]]
== “V” 扩展：向量操作, 版本 1.0 

[NOTE]
====
基础向量扩展旨在提供在 32 位指令编码空间内对数据并行执行的通用支持，后续的向量扩展将为特定领域提供更丰富的功能。
====

=== 介绍

本文档是 RISC-V 向量扩展的版本 1.1 草案。

NOTE: 此版本包含自公开评审开始后收集的更新内容。规范将在批准时最终更新为版本 2.0。

本规范包括当前已冻结的完整向量指令集。其他在开发过程中已考虑但未包含于本文档中的指令不在评审和批准范围内，可能会被完全修订或放弃。<<sec-vector-extensions>>节列出了标准向量扩展，以及每个扩展支持的指令和元素宽度。

=== 实现定义的常量参数

每个支持向量扩展的硬件线程定义两个参数：

. 任意操作可以产生或使用的向量元素的最大位数，ELEN {ge} 8，且必须是 2 的幂。
. 单个向量寄存器的位数，VLEN {ge} ELEN，且必须是 2 的幂，且不大于 2^16^。

标准向量扩展（<<sec-vector-extensions>>节）和架构配置文件可能会对 ELEN 和 VLEN 设置进一步的约束。

NOTE: 未来的扩展可能允许 ELEN > VLEN，通过使用多个向量寄存器中的位来保存一个元素，但当前提案不包括这一选项。

NOTE: VLEN 的上限使得软件可以知道索引将适用于 16 位（最大的 VLMAX 为 65,536，发生在 LMUL=8 和 SEW=8 时，且 VLEN=65,536）。任何超过 64Kib 的向量寄存器扩展将需要新的配置指令，以确保使用旧配置指令的软件不会观察到更大的向量长度。

向量扩展支持在特定约束下编写二进制代码，该代码可以在具有不同 VLEN 参数值的硬件线程上可移植执行，前提是这些硬件线程支持所需的元素类型和指令。

NOTE: 可以编写代码来暴露实现参数的差异。

NOTE: 通常情况下，具有激活向量状态的线程上下文在执行过程中不能在具有不同 VLEN 或 ELEN 参数的硬件线程之间迁移。

=== 向量扩展编程模型

向量扩展向基础的标量 RISC-V ISA 添加了 32 个向量寄存器，以及七个非特权控制和状态寄存器（CSRs）：vstart、vxsat、vxrm、vcsr、vtype、vl 和 vlenb。

.新的向量 CSRs
[cols="2,2,2,10"]
[%autowidth,float="center",align="center",options="header"]
|===
| 地址 | 权限 | 名称   | 描述

| 0x008 | URW | vstart | 向量开始位
| 0x009 | URW | vxsat  | 定点饱和标志
| 0x00A | URW | vxrm   | 定点舍入模式
| 0x00F | URW | vcsr   | 向量控制和状态寄存器
| 0xC20 | URO | vl     | 向量长度
| 0xC21 | URO | vtype  | 向量数据类型寄存器
| 0xC22 | URO | vlenb  | VLEN/8 (以字节表示的向量寄存器长度)
|===

NOTE: 四个控制和状态寄存器（CSR）编号 0x00B-0x00E 暂时保留给未来的向量 ，其中一些可能会镜像到 `vcsr`。

==== 向量寄存器

向量扩展向基础的标量 RISC-V ISA 添加了 32 个架构向量寄存器（`v0`-`v31`）。

每个向量寄存器具有固定的 VLEN 位状态。

==== 向量上下文状态在mstatus中

向 `mstatus[10:9]` 中添加了一个向量上下文状态字段 `VS`，并在 `sstatus[10:9]` 中进行了影射。它的定义方式类似于浮点上下文状态字段 `FS`。

当 `mstatus.VS` 设置为 Off 时，尝试执行任何向量指令或访问向量控制状态寄存器时会引发非法指令异常。

当 `mstatus.VS` 设置为初始（initial）或清洁（clean）时，执行任何改变向量状态的指令（包括向量控制状态寄存器）将使 `mstatus.VS` 更改为脏（dirty）。实现也可以在任何时候将 `mstatus.VS` 从初始或清洁更改为脏，即使向量状态没有发生变化。

NOTE: 准确设置 `mstatus.VS` 是一种优化。软件通常会利用 VS 来减少上下文交换的开销。

如果 `mstatus.VS` 为脏，则 `mstatus.SD` 设置为 1；否则，`mstatus.SD` 将根据现有规范进行设置。

实现可能具有可写的 `misa.V` 字段。类似于浮点单元的处理方式，`mstatus.VS` 字段可能存在，即使 `misa.V` 被清除。

NOTE: 允许在 `misa.V` 清除时存在 `mstatus.VS`，这样可以支持向量仿真，并简化在具有可写 `misa.V` 的系统中对 `mstatus.VS` 的处理。

==== 向量上下文状态在 `vsstatus` 中

当存在虚拟化扩展时，`vsstatus[10:9]` 中会添加一个向量上下文状态字段 `VS`。它的定义方式类似于浮点上下文状态字段 `FS`。

当 V=1 时，`vsstatus.VS` 和 `mstatus.VS` 都生效：如果任一字段设置为关闭，尝试执行任何向量指令或访问向量都将引发非法指令异常。

当 V=1 并且 `vsstatus.VS` 和 `mstatus.VS` 都没有设置为关闭时，执行任何改变向量状态的指令（包括向量 ）将使 `mstatus.VS` 和 `vsstatus.VS` 都变为脏。实现也可以在任何时候将 `mstatus.VS` 或 `vsstatus.VS` 从初始或清洁状态变为脏，即使没有发生向量状态的变化。

如果 vsstatus.VS 为脏，则 vsstatus.SD 为 1；否则，vsstatus.SD 将根据现有规范进行设置。

如果 mstatus.VS 为脏，则 mstatus.SD 为 1；否则，mstatus.SD 将根据现有规范进行设置。

对于具有可写 misa.V 字段的实现，即使 misa.V 被清除，vsstatus.VS 字段仍然可以存在。

==== 向量类型寄存器，`vtype`

只读的 XLEN 宽的向量类型控制状态寄存器，`vtype` 提供了用于解释向量寄存器文件内容的默认类型，并且只能通过 `vset{i}vl{i}` 指令更新。向量类型决定了每个向量寄存器中元素的组织方式，以及如何将多个向量寄存器分组。`vtype` 寄存器还指示如何处理被掩蔽掉的元素以及超出当前向量长度的元素。

NOTE: 仅允许通过 `vset{i}vl{i}` 指令更新 `vtype` 寄存器，有助于简化 `vtype` 寄存器状态的维护。

`vtype` 寄存器包含五个字段：`vill`、`vma`、`vta`、`vsew[2:0]` 和 `vlmul[2:0]`。位 `vtype[XLEN-2:8]` 应该被写入零，且该字段中的非零值保留供未来使用。

include::images/wavedrom/vtype-format.adoc[]

NOTE: 支持 ELEN=32 的小型实现只需要在 `vtype` 中存储七个位：`ma` 和 `ta` 各两个位，`vsew[1:0]` 两个位，以及 `vlmul[2:0]` 三个位。`vill` 表示的非法值可以使用 `vsew[1:0]` 中的非法 64 位组合进行内部编码，而无需额外的存储位来保存 `vill`。

NOTE: 未来的标准和自定义向量扩展可能会扩展这些字段，以支持更多的数据类型。

NOTE: `vtype` 的主要功能是使向量指令集能够适配 32 位的指令编码空间。在执行向量指令之前，可以使用单独的 `vset{i}vl{i}` 指令来设置 `vl` 和/或 `vtype` 字段，且实现可以选择将这两条指令融合成一个内部的向量微操作。在许多情况下，`vl` 和 `vtype` 的值可以在多个指令之间复用，从而减少来自 `vset{i}vl{i}` 指令的静态和动态指令开销。预计未来扩展的 64 位指令编码将允许在指令编码中静态指定这些字段。

===== 向量选择的元素宽度 `vsew[2:0]`

vsew 中的值设置了动态选定的元素宽度（SEW）。默认情况下，向量寄存器被视为被划分为 VLEN/SEW 个元素。

.vsew[2:0] (选定元素宽度) 编码
[cols="1,1,1,1"]
[%autowidth,float="center",align="center",options="header"]
|===
3+| vsew[2:0] | SEW

| 0 | 0 | 0 |    8
| 0 | 0 | 1 |   16
| 0 | 1 | 0 |   32
| 0 | 1 | 1 |   64
| 1 | X | X |   保留
|===

NOTE: 虽然预计较大的 `vsew[2:0]` 编码（`100`-`111`）将用于编码更大的 SEW，但这些编码目前是保留的。

.以 VLEN = 128 bits 为例子
[cols=">,>"]
[%autowidth,float="center",align="center",options="header"]
|===
| SEW | 每个向量寄存器中的元素个数

| 64 |  2
| 32 |  4
| 16 |  8
|  8 | 16
|===

支持的元素宽度可能会随着 LMUL 的变化而变化。

NOTE: 当前的标准向量扩展集不随着 LMUL 变化而变化支持的元素宽度。一些未来的扩展可能仅在使用 LMUL 将多个向量寄存器的位组合时，支持更大的 SEW。在这种情况下，依赖于大 SEW 的软件应尝试使用最大的 LMUL，因此使用最少的向量寄存器组，以增加代码能够运行的实现数量。在设置 vtype 后，应检查 vtype 中的 vill 位，以查看配置是否受支持，如果不支持，则应提供备用代码路径。或者，可以在每个 LMUL 设置下强制规定最小的 SEW。

=====  向量寄存器分组 (`vlmul[2:0]`)

多个向量寄存器可以组合在一起，使得单个向量指令可以操作多个向量寄存器。这里使用向量寄存器组这一术语，指代作为单个操作数传递给向量指令的一个或多个向量寄存器。向量寄存器组可以用于提高较长应用向量的执行效率，但其主要目的是允许双宽或更大元素与单宽元素具有相同的向量长度进行操作。当 LMUL 大于 1 时，它表示将组合多个向量寄存器形成一个向量寄存器组的默认数量。实现必须支持 LMUL 的整数值 1、2、4 和 8。

NOTE: 向量架构包括需要多个源和目标向量操作数的指令，这些操作数具有不同的元素宽度，但元素数量相同。每个向量操作数的有效 LMUL（EMUL）由所需的寄存器数量来确定，以容纳这些元素。例如，对于扩展加法操作（如将 32 位值相加以产生 64 位结果），双宽结果需要是单宽输入 LMUL 的两倍。

LMUL 还可以是一个分数值，从而减少单个向量寄存器中使用的位数。分数 LMUL 用于在处理混合宽度值时增加有效可用的向量寄存器组的数量

NOTE: 仅使用整数 LMUL 值时，操作一个范围内不同大小的循环需要为最窄的数据类型分配至少一个完整的向量寄存器（LMUL=1），然后为每个更宽的向量操作数消耗多个向量寄存器（LMUL>1）以形成一个向量寄存器组。这会限制可用的向量寄存器组数量。使用分数 LMUL 时，最宽的值仅需要占用一个单独的向量寄存器，而较窄的值可以占用一个向量寄存器的一部分，从而允许在处理混合宽度值时，即使在向量循环中，也可以使用所有 32 个架构向量寄存器名称。分数 LMUL 意味着部分向量寄存器未被使用，但在某些情况下，使用更多较短的寄存器驻留向量相对于使用更少较长的寄存器驻留向量可以提高效率。

实现必须提供分数 LMUL 设置，允许最窄支持的类型占用一个向量寄存器的一个分数部分，该分数部分对应于最窄支持的类型的宽度与最宽支持的类型的宽度之间的比例。一般来说，要求支持 LMUL ≥ SEWMIN/ELEN，其中 SEWMIN 是最窄支持的 SEW 值，ELEN 是最宽支持的 SEW 值。在标准扩展中，SEWMIN = 8。对于 ELEN=32 的标准向量扩展，必须支持分数 LMUL 值 1/2 和 1/4。对于 ELEN=64 的标准向量扩展，必须支持分数 LMUL 值 1/2、1/4 和 1/8。

NOTE: 当 LMUL < SEW~MIN~/ELEN 时，不能保证实现会在分数向量寄存器中有足够的位来存储至少一个元素，因为 VLEN=ELEN 是有效的实现选择。例如，对于 VLEN=ELEN=32，SEW~MIN~ = 8，LMUL 为 1/8 时，只会在向量寄存器中提供四个位的存储空间。

对于给定支持的分数 LMUL 设置，实现必须支持 SEW 设置，范围在 SEW~MIN~ 和 LMUL * ELEN 之间（包括这两个值）。

使用 `vtype` 编码时，LMUL < SEW~MIN~/ELEN 是保留的，但如果实现不支持这些配置，则可以设置 `vill`。

NOTE: 要求所有实现设置 `vill` 的做法会禁止未来在扩展中使用这种情况，因此为了允许未来定义 LMUL < SEW~MIN~/ELEN 行为，我们将此情况视为保留。

NOTE: 如果 `vsetvli` 指令尝试写入 LMUL < SEW~MIN~/ELEN，建议汇编器提供警告（而不是错误）。

LMUL 由 `vtype` 中的带符号 `vlmul` 字段设置（即 LMUL = 2^vlmul[2:0]^）。

衍生值 VLMAX = LMUL * VLEN / SEW 表示在当前 SEW 和 LMUL 设置下，单个向量指令可以操作的最大元素数量，如下表所示。

[cols="1,1,1,2,2,5,5"]
[%autowidth,float="center",align="center",options="header"]
|===
  3+| vlmul[2:0] | LMUL | #groups | VLMAX      | 与寄存器 n 组合的寄存器

| 1 | 0 | 0 |   -  |     -   |     -      | 保留
| 1 | 0 | 1 |   1/8|     32  | VLEN/SEW/8 | `v` __n__ (组中的单个寄存器)
| 1 | 1 | 0 |   1/4|     32  | VLEN/SEW/4 | `v` __n__ (组中的单个寄存器)
| 1 | 1 | 1 |   1/2|     32  | VLEN/SEW/2 | `v` __n__ (组中的单个寄存器)
| 0 | 0 | 0 |   1  |     32  |   VLEN/SEW | `v` __n__ (组中的单个寄存器)
| 0 | 0 | 1 |   2  |     16  | 2*VLEN/SEW | `v` __n__, `v` __n__+1
| 0 | 1 | 0 |   4  |      8  | 4*VLEN/SEW | `v` __n__, ..., `v` __n__+3
| 0 | 1 | 1 |   8  |      4  | 8*VLEN/SEW | `v` __n__, ..., `v` __n__+7
|===

当 LMUL=2 时，向量寄存器组包含向量寄存器 `v` __n__ 和向量寄存器 `v` __n__+1，提供两倍的向量长度（以位为单位）。指定 LMUL=2 向量寄存器组且使用奇数编号的向量寄存器的指令是保留的。

当 LMUL=4 时，向量寄存器组包含四个向量寄存器，且指定 LMUL=4 向量寄存器组并使用非四的倍数的寄存器编号的指令是保留的。

当 LMUL=8 时，向量寄存器组包含八个向量寄存器，且指定 LMUL=8 向量寄存器组并使用非八的倍数的寄存器编号的指令是保留的。

无论 LMUL 为何值，掩码寄存器总是包含于单个向量寄存器中。

[[sec-agnostic]]
===== `vta`: 向量尾部无关（Vector Tail Agnostic）和 `vma`: 向量掩码无关（Vector Mask Agnostic）

这两个位分别修改了目标尾部元素和目标未激活的被屏蔽元素在执行向量指令时的行为。尾部和未激活集包含在向量操作期间不会接收新结果的元素位置，具体定义见 <<sec-inactive-defs>>.

所有系统必须支持这四种选项：

[cols="1,1,3,3"]
[%autowidth,float="center",align="center",options="header"]
|===
| `vta` | `vma` | 尾部元素 | 未激活元素

|   0   |   0   | 未干扰        | 未干扰
|   0   |   1   | 未干扰        | 无关
|   1   |   0   | 无关          | 未干扰
|   1   |   1   | 无关          | 无关
|===

掩码目标尾元素总是被视为与尾部无关的，无论 `vta` 的设置如何。

当一个集合被标记为未干扰时，相应的向量寄存器组中的目标元素保持其先前持有的值。

当一个集合被标记为无关时，任何向量目标操作数中的相应目标元素可以保留其先前持有的值，或者被 1 覆盖。在单个向量指令内，每个目标元素可以是未干扰的，也可以被 1 覆盖，且当指令使用相同的输入执行时未干扰或被 1 覆盖的模式在执行时不需要是确定性的。

NOTE: 无关策略是为了适应具有向量寄存器重命名的机器。使用未干扰策略时，所有元素都必须从旧的物理目标向量寄存器读取，并复制到新的物理目标向量寄存器中。当这些未激活值或尾部值不再用于后续计算时，这会导致效率低下。

NOTE: 选择用全 1 而非全 0 的值进行覆盖，是为了避免软件开发人员依赖于写入的值。

NOTE: 一个简单的顺序执行实现可以忽略设置，并简单地使用未干扰策略执行所有向量指令。`vta` 和 `vma` 状态位仍然必须在 `vtype` 中提供，以确保兼容性并支持线程迁移。

NOTE: 一个乱序执行实现可以选择使用尾部无关 + 掩码无关，利用尾部无关 + 掩码未干扰来减少实现的复杂度。

NOTE: 无关结果策略的定义较为宽松，以便支持在小型顺序核心之间迁移应用线程（这种情况可能会保持无关区域未干扰），以及在具有寄存器重命名的大型乱序核心上迁移（这种情况下可能会将无关元素覆盖为 1）。由于可能需要在中途重新启动，因此我们允许在单个向量指令中任意混合无关策略。这种允许的策略混合也支持一些实现，它们可能会针对向量寄存器的不同粒度改变策略。例如，在一个正在积极操作的粒度中使用未干扰策略，而对于尾部的粒度则使用重命名为全 1 的策略。

此外，除了掩码加载指令外，掩码结果尾部中的任何元素也可以被写入该掩码生成操作在 `vl`=VLMAX 时计算的值。此外，对于掩码逻辑指令和 `vmsbf.m`、`vmsif.m`、`vmsof.m` 等掩码操作指令，结果尾部中的任何元素也可以被写入该掩码生成操作在 vl=VLEN，SEW=8，LMUL=8 时计算的值（即掩码寄存器的所有位都可以被覆盖）。

NOTE: 为了简化掩码数据管理，掩码尾部始终被视为无关的，可以按位粒度进行写入。对于掩码寄存器值，似乎没有太多软件需求支持尾部未干扰。允许掩码生成指令写回指令的结果避免了需要逻辑来屏蔽尾部，除了掩码加载指令不能将内存值写入目标掩码尾部，因为这将意味着访问超出软件意图的内存。

汇编语法为 vsetvli 指令添加了两个必要的标志：
----
 ta   # 尾部无关
 tu   # 尾部未干扰
 ma   # 掩码无关
 mu   # 掩码未干扰

 vsetvli t0, a0, e32, m4, ta, ma   # 尾部无关   , 掩码无关
 vsetvli t0, a0, e32, m4, tu, ma   # 尾部未干扰 , 掩码无关
 vsetvli t0, a0, e32, m4, ta, mu   # 尾部无关   , 掩码未干扰
 vsetvli t0, a0, e32, m4, tu, mu   # 尾部未干扰 , 掩码未干扰
----

NOTE: 在 v0.9 之前，当 `vsetvli` 指令未指定这些标志时，它们默认为掩码未干扰/尾部未干扰。然而，现在已经不推荐使用没有这些标志的 `vsetvli`，并且指定标志设置现在是强制性的。默认值可能应该是尾部无关/掩码无关，这样软件就必须在关心非参与元素时明确指定。但是，考虑到这些标志引入之前指令的历史意义，我们决定在未来的汇编代码中始终要求指定这些标志。

===== 向量类型非法 `vill`

`vill` 位用于编码先前的 `vset{i}vl{i}` 指令尝试将不支持的值写入 `vtype`。

NOTE: `vill` 位位于控制状态寄存器的 XLEN-1 位，用于支持通过分支到符号位检查非法值。

如果 `vill` 位被设置，则任何依赖于 `vtype` 的向量指令执行尝试将引发非法指令异常。

NOTE: `vset{i}vl{i}` 以及整个寄存器的加载和存储操作不依赖于 `vtype`。

当 `vill` 位被设置时，`vtype` 中的其他 XLEN-1 位应为零。

====  向量长度寄存器 `vl`

`vl` 是一个 XLEN 位宽的只读控制状态寄存器，只能通过 `vset{i}vl{i}` 指令以及仅故障首次(fault-only-first)向量加载指令变体进行更新。

`vl` 寄存器保存一个无符号整数，指定要通过向量指令更新的元素数量，详细内容请参见 <<sec-inactive-defs>> 部分。

NOTE: `vl` 中实现的位数取决于实现支持的最小类型的最大向量长度。例如，最小的支持 SEW=8 且 VLEN=32 的向量实现，需要至少六个位来存储值 0-32（VLEN=32，LMUL=8 和 SEW=8 时，VLMAX=32）。

==== 向量字节长度 `vlenb`

该 XLEN 位宽的只读控制状态寄存器 vlenb 保存值 VLEN/8，即向量寄存器的字节长度。

NOTE: vlenb 中的值在任何实现中都是设计时确定的常量。

NOTE: 如果没有这个控制状态寄存器，则需要使用多个指令来计算以字节为单位的 VLEN，这会干扰当前的 `vl` 和 `vtype` 设置，要求它们被保存和恢复。

==== 向量起始索引控制状态寄存器 `vstart`

该 XLEN 位宽的可读写 `vstart` 寄存器指定了向量指令执行的第一个元素的索引，具体描述见 <<sec-inactive-defs>> 部分。

通常，`vstart` 只有在向量指令发生陷阱时由硬件写入，`vstart` 的值表示触发陷阱的元素（无论是同步异常还是异步中断），并在可恢复陷阱处理后，执行将从该元素继续。

所有向量指令定义为从 `vstart` 寄存器中给出的元素编号开始执行，保持目标向量中早期的元素不变，并在执行结束时将 `vstart` 寄存器重置为零。

NOTE: 所有向量指令，包括 `vset{i}vl{i}`，都会将 `vstart` 控制状态寄存器重置为零。

`vstart` 不会被触发非法指令异常的向量指令修改。

`vstart` 控制状态寄存器被定义为仅包含足够的可写位来保存最大元素索引（即最大 VLMAX 减一）。

NOTE: 最大向量长度是通过最大的 LMUL 设置（8）和最小的 SEW 设置（8）得到的，所以 VLMAX_max = 8 * VLEN / 8 = VLEN。例如，对于 VLEN=256，`vstart` 将需要 8 位来表示从 0 到 255 的索引。

使用大于当前 `vtype` 设置的最大元素索引的 `vstart` 值是保留的。

NOTE: 如果 `vstart` 超出边界，建议实现应触发陷阱。虽然不要求触发，但未来 `vstart` 高位的潜在用途是存储不精确的陷阱信息。

`vstart` 控制状态寄存器对非特权代码可写，但非零的 `vstart` 值可能导致一些实现上的向量指令运行变慢，因此不推荐应用程序开发者使用 `vstart`。某些向量指令无法在非零 `vstart` 值下执行，并将根据下文定义引发非法指令异常。

NOTE: 让非特权代码访问 `vstart` 可以支持用户级线程库。

实现可以在尝试执行 `vstart` 值在该实现执行相同指令时永远无法产生的向量指令时，抛出非法指令异常，尤其是当执行该指令时具有相同的 `vtype` 设置时。

NOTE: 例如，一些实现永远不会在执行向量算术指令期间进行中断，而是等到指令执行完成后才进行中断。这类实现允许在尝试执行向量算术指令时，当 vstart 非零时抛出非法指令异常。

NOTE: 在两个具有不同微架构的硬件线程之间迁移软件线程时，新的硬件线程微架构可能不支持当前的 `vstart` 值。在接收硬件线程上的运行时可能需要模拟指令执行，直到下一个支持的 `vstart` 元素位置为止。或者，迁移事件可以限制为仅发生在相互支持的 `vstart` 位置。

==== 向量定点舍入模式寄存器 `vxrm`

向量定点舍入模式寄存器保存一个两位的读写舍入模式字段，位于最低有效位 (vxrm[1:0])。高位 vxrm[XLEN-1:2] 应该写为零。

向量定点舍入模式有一个单独的控制状态寄存器地址，以允许独立访问，但它也作为字段反映在 `vcsr` 中。

NOTE: 可以通过单个 csrwi 指令在保存初始舍入模式的同时设置新的舍入模式。

定点舍入算法如下所示。假设舍入前的结果为 v，并且要舍去 d 位结果。
则舍入后的结果为 (v >> d) + r，其中 r 取决于舍入模式，具体由下表指定。

.vxrm 编码
//[cols="1,1,4,10,5"]
[%autowidth,float="center",align="center",cols="<,<,<,<,<",options="header"]
|===
2+| `vxrm[1:0]` | 缩写 | 舍入模式 | 舍入增量, `r`

| 0 | 0 | rnu | 向上取整 (add +0.5 LSB)                    | `v[d-1]`
| 0 | 1 | rne | 取整到最近的偶数                            | `v[d-1] & (v[d-2:0]{ne}0 \| v[d])`
| 1 | 0 | rdn | 向下取整 (截断)                            | `0`
| 1 | 1 | rod | 取整到奇数 (OR bits into LSB, aka "jam")   | `!v[d] & v[d-1:0]{ne}0`
|===

取整功能：
----
roundoff_unsigned(v, d) = (unsigned(v) >> d) + r
roundoff_signed(v, d) = (signed(v) >> d) + r
----
在下面的指令描述中用于表示此操作。

==== 向量定点饱和标志 `vxsat`

`vxsat` 控制状态寄存器具有一个可读写的最低有效位 (`vxsat[0]`)，用于指示定点指令是否需要对输出值进行饱和，以适应目标格式。
位 `vxsat[XLEN-1:1]` 应该被写为零。

`vxsat` 位在 `vcsr` 控制状态寄存器中有一个镜像。

==== 向量控制和状态寄存器 `vcsr`

`vxrm` 和 `vxsat` 这两个独立的控制状态寄存器也可以通过 XLEN 位宽的向量控制状态寄存器 `vcsr` 中的字段进行访问。

.vcsr 布局
[cols=">2,4,10"]
[%autowidth,float="center",align="center",options="header"]
|===
| 位 | 名称   | 描述

| XLEN-1:3 |       | 保留
|  2:1 | vxrm[1:0] | 定点数舍入模式
|    0 | vxsat     | 定点累积饱和度标志
|===

==== 复位时的向量扩展状态

向量扩展在复位时必须处于一致的状态。特别是，`vtype` 和 `vl` 必须具有可以通过单条 `vsetvl` 指令读取并
恢复的值。

NOTE: 建议在复位时，将 `vtype.vill` 置为 1，`vtype` 的其余位设为零，并将 `vl` 设为零。

`vstart`、`vxrm` 和 `vxsat` 控制状态寄存器在复位时可以具有任意值。

NOTE: 大多数向量单元的使用场景都需要执行初始的 `vset{i}vl{i}`，这将重置 `vstart`。`vxrm` 和 `vxsat` 字段在使用前应通过软件显式复位。

向量寄存器在复位时可以具有任意值。

=== 向量元素到向量寄存器状态的映射

下列示意图展示了在不同的 SEW（元素宽度）和 LMUL（向量寄存器分组）设置下，向量寄存器如何存储不同宽度的元素。此外，映射方式也取决于具体实现的 VLEN（向量寄存器长度）。元素存储到向量寄存器时，最低有效字节（LSB）位于最低编号的比特位置。

该映射的选择旨在为软件提供最简单和最具移植性的模型，但在某些操作上，对于较宽的向量数据通路，可能会导致较大的布线成本。向量指令集特别设计以支持内部重新排列向量数据以适应不同 SEW 的实现，从而减少数据通路布线成本，同时在外部保持简单的软件模型。

NOTE: 例如，某些微架构可以跟踪向量寄存器的 EEW（有效元素宽度），如果使用不同的 EEW 访问该寄存器，则可以插入额外的数据重排操作。

====  LMUL = 1 时的映射方式

当 LMUL=1 时，元素按顺序从向量寄存器的最低有效位（LSB）到最高有效位（MSB）进行存储。

NOTE: 为了提高可读性，向量寄存器的布局以从右到左递增字节地址的方式绘制。元素内部的比特编号采用小端格式，从右到左递增，对应于数值大小的增加。

----
LMUL=1 示例

元素索引以十六进制表示，并显示在存储元素的最低有效字节位置。


 VLEN=32b

 Byte         3 2 1 0

 SEW=8b       3 2 1 0
 SEW=16b        1   0
 SEW=32b            0

 VLEN=64b

 Byte        7 6 5 4 3 2 1 0

 SEW=8b      7 6 5 4 3 2 1 0
 SEW=16b       3   2   1   0
 SEW=32b           1       0
 SEW=64b                   0

 VLEN=128b

 Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b      F E D C B A 9 8 7 6 5 4 3 2 1 0
 SEW=16b       7   6   5   4   3   2   1   0
 SEW=32b           3       2       1       0
 SEW=64b                   1               0

 VLEN=256b

 Byte     1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b   1F1E1D1C1B1A19181716151413121110 F E D C B A 9 8 7 6 5 4 3 2 1 0
 SEW=16b     F   E   D   C   B   A   9   8   7   6   5   4   3   2   1   0
 SEW=32b         7       6       5       4       3       2       1       0
 SEW=64b                 3               2               1               0
----

==== LMUL < 1 的映射方式

当 LMUL < 1 时，向量寄存器中仅使用前 LMUL * VLEN / SEW 个元素。
寄存器中的其余空间被视为向量尾部的一部分，因此必须遵循 vta（向量尾部操作）设置。

----
 例如, VLEN=128b, LMUL=1/4

 Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0

 SEW=8b      - - - - - - - - - - - - 3 2 1 0
 SEW=16b       -   -   -   -   -   -   1   0
 SEW=32b           -       -       -       0
----

==== LMUL > 1 的映射方式

当向量寄存器被分组时，向量寄存器组中的元素按照元素顺序连续存储。存储从编号最小的向量寄存器开始，当一个寄存器填满后，依次存入组内编号更高的寄存器。

----
 LMUL > 1 时

 VLEN=32b, SEW=8b, LMUL=2

 Byte         3 2 1 0
 v2*n         3 2 1 0
 v2*n+1       7 6 5 4

 VLEN=32b, SEW=16b, LMUL=2

 Byte         3 2 1 0
 v2*n           1   0
 v2*n+1         3   2

 VLEN=32b, SEW=16b, LMUL=4

 Byte         3 2 1 0
 v4*n           1   0
 v4*n+1         3   2
 v4*n+2         5   4
 v4*n+3         7   6

 VLEN=32b, SEW=32b, LMUL=4

 Byte         3 2 1 0
 v4*n               0
 v4*n+1             1
 v4*n+2             2
 v4*n+3             3

 VLEN=64b, SEW=32b, LMUL=2

 Byte         7 6 5 4 3 2 1 0
 v2*n               1       0
 v2*n+1             3       2

 VLEN=64b, SEW=32b, LMUL=4

 Byte         7 6 5 4 3 2 1 0
 v4*n               1       0
 v4*n+1             3       2
 v4*n+2             5       4
 v4*n+3             7       6

 VLEN=128b, SEW=32b, LMUL=2

 Byte        F E D C B A 9 8 7 6 5 4 3 2 1 0
 v2*n              3       2       1       0
 v2*n+1            7       6       5       4

 VLEN=128b, SEW=32b, LMUL=4

 Byte          F E D C B A 9 8 7 6 5 4 3 2 1 0
 v4*n                3       2       1       0
 v4*n+1              7       6       5       4
 v4*n+2              B       A       9       8
 v4*n+3              F       E       D       C
----

[[sec-mapping-mixed]]
==== 混合宽度操作的映射

向量 ISA 设计支持混合宽度操作，而无需额外的显式重排指令。在处理具有不同精度值的多个向量时，推荐的软件策略是动态修改 vtype，以保持 SEW/LMUL 不变（从而保持 VLMAX 不变）。

以下示例展示了在 VLEN=128b 的实现中，四种不同的打包元素宽度（8b、16b、32b、64b）。向量寄存器分组因子（LMUL）根据相对元素大小增加，以确保每个组能够容纳相同数量的向量元素（此示例中 VLMAX=8），从而简化循环剥离（stripmining）代码。

----
当 VLEN=128b, 而S EW/LMUL=16 时

Byte      F E D C B A 9 8 7 6 5 4 3 2 1 0
vn        - - - - - - - - 7 6 5 4 3 2 1 0  SEW=8b, LMUL=1/2

vn          7   6   5   4   3   2   1   0  SEW=16b, LMUL=1

v2*n            3       2       1       0  SEW=32b, LMUL=2
v2*n+1          7       6       5       4

v4*n                    1               0  SEW=64b, LMUL=4
v4*n+1                  3               2
v4*n+2                  5               4
v4*n+3                  7               6
----

下表展示了在包含混合宽度操作的循环中，每种可能的固定 SEW/LMUL 操作点。每一列代表一个固定的 SEW/LMUL 操作点。表中的条目是 LMUL 值，这些 LMUL 值使该行的数据宽度对应于该列的 SEW/LMUL 值。在同一列中，某个数据宽度的 LMUL 设置表明它可以与该列中其他具有 LMUL 设置的数据宽度对齐，从而确保它们都具有相同的 VLMAX。

|===
|       7+^|            SEW/LMUL 
|          | 1 |  2 |  4 |  8 | 16  | 32  |  64

| SEW=   8 | 8 |  4 |  2 |  1 | 1/2 | 1/4 |  1/8
| SEW=  16 |   |  8 |  4 |  2 |  1  | 1/2 |  1/4
| SEW=  32 |   |    |  8 |  4 |  2  |  1  |  1/2
| SEW=  64 |   |    |    |  8 |  4  |  2  |   1
|===

较大的 LMUL 设置还可以用于简单地增加向量长度，以减少指令获取和调度开销，适用于需要较少向量寄存器组的情况。

[[sec-mask-register-layout]]
==== 掩码寄存器布局

无论 SEW 和 LMUL 为何，向量掩码只占用一个向量寄存器。

在掩码向量寄存器中，每个元素对应一个单独的掩码位。元素 _i_ 的掩码位位于掩码寄存器的第 _i_ 位，而不受 SEW 或 LMUL 影响。

=== 向量指令格式
向量扩展的指令分布在两个现有的主要操作码（LOAD-FP 和 STORE-FP）以及一个新的主要操作码（OP-V）下。

向量加载和存储指令被编码在标量浮点加载和存储的主要操作码（LOAD-FP/STORE-FP）内。向量加载和存储的编码重新利用了标准标量浮点加载/存储指令的 12 位立即数字段的一部分，以提供额外的向量指令编码，其中第 25 位存储标准向量掩码位（详见 <<sec-vector-mask-encoding>>）。

include::images/wavedrom/vmem-format.adoc[]

include::images/wavedrom/valu-format.adoc[]

include::images/wavedrom/vcfg-format.adoc[]

向量指令可以使用标量或向量作为源操作数，并生成标量或向量结果。大多数向量指令可以无条件执行，或者在掩码控制下有条件执行。

向量加载和存储指令在向量寄存器元素和内存之间传输比特模式。向量算术指令在向量寄存器元素中进行运算。

==== 标量操作数
标量操作数可以是立即数，也可以来自 `x` 寄存器、`f` 寄存器或某个向量寄存器的元素 0。标量结果可以写入 `x` 或 `f` 寄存器，也可以写入某个向量寄存器的元素 0。无论当前 LMUL 设置如何，任何向量寄存器都可以用于存储标量值。

NOTE: Zfinx（"F in X"）是一个新的 ISA 扩展，其中浮点指令的参数来自整数寄存器文件。向量扩展也兼容 Zfinx，在 Zfinx 向量扩展中，向量-标量浮点指令从 `x` 寄存器获取其标量参数。

NOTE: 我们曾考虑将 `f` 寄存器与 `v` 寄存器进行重叠，但最终未采用这一方案。当前方案减少了向量寄存器的压力，避免了与标准调用约定的冲突，简化了高性能标量浮点设计，并与 Zfinx ISA 选项兼容。尽管 `f` 和 `v` 寄存器的重叠可以减少某些实现中的状态位数，但会增加高性能设计的复杂性，并阻碍与 Zfinx ISA 选项的兼容性。

[[sec-vec-operands]]
==== 向量操作数

每个向量操作数都有一个有效元素宽度（EEW）和一个有效 LMUL（EMUL），用于确定向量寄存器组中所有元素的大小和位置。默认情况下，对于大多数指令的大多数操作数，EEW=SEW，EMUL=LMUL。

某些向量指令的源和目标向量操作数具有相同数量的元素，但宽度不同，因此 EEW 和 EMUL 可能与 SEW 和 LMUL 不同，但满足 EEW/EMUL = SEW/LMUL。例如，大多数加宽算术指令的源操作数组具有 EEW=SEW 和 EMUL=LMUL，而目标操作数组的 EEW=2×SEW，EMUL=2×LMUL。缩小指令的源操作数具有 EEW=2×SEW 和 EMUL=2×LMUL，而目标操作数的 EEW=SEW，EMUL=LMUL。

向量操作数或结果可能占用一个或多个向量寄存器，具体取决于 EMUL，但始终使用编号最小的向量寄存器来指定寄存器组。使用除编号最小的寄存器以外的寄存器来指定寄存器组的行为目前是保留的。

一个向量寄存器不能在同一条指令中以不同的 EEW 作为源操作数。掩码寄存器被视为 EEW=1。如果某个编码导致同一个向量寄存器在一次指令中以两个或多个不同 EEW 被读取（包括当该寄存器在两个或多个寄存器组的不同位置出现时），则该编码是保留的。

NOTE: 实际上，在同一指令中以不同 EEW 读取同一寄存器没有软件上的好处，这一约束减少了需要根据 EEW 内部重新排列数据的实现的复杂性。

如果目标向量寄存器组与源向量寄存器组重叠，必须满足以下条件之一：

- 目标 EEW 等于源 EEW。
- 目标 EEW 小于源 EEW，并且重叠发生在源寄存器组编号最小的部分（例如，当 LMUL=1 时，`vnsrl.wi v0, v0, 3` 是合法的，但目标为 `v1` 则非法）。
- 目标 EEW 大于源 EEW，源 EMUL 至少为 1，并且重叠发生在目标寄存器组编号最大的部分（例如，当 LMUL=8 时，`vzext.vf4 v0, v6` 是合法的，但源为 `v0`、`v2` 或 `v4` 则非法）。

对于确定寄存器组重叠约束的目的，掩码元素的 EEW 被视为 1。

NOTE: 重叠约束旨在支持没有寄存器重命名的架构中的可恢复异常。

任何违反重叠约束的指令编码都是保留的。

当源和目标寄存器重叠且 EEW 不同时，该指令在执行时不会受掩码或尾部控制，无论 `vtype` 中 `vta` 和 `vma` 位的设置如何。

指令使用的最大向量寄存器组不能超过 8 个向量寄存器（即 EMUL ≤ 8）。如果某条向量指令要求寄存器组超过 8 个向量寄存器，则该指令编码保留。例如，LMUL=8 时的加宽操作会生成加宽的目标向量寄存器组，这将导致 EMUL=16，因此该操作是保留的。

加宽的标量值（例如加宽归约操作的输入和输出）存储在向量寄存器的第一个元素中，并且 EMUL=1。

==== 向量掩码

许多向量指令支持掩码。被掩码屏蔽的元素操作不会产生异常。对于目标向量寄存器中的被屏蔽元素，根据 `vtype` 中 `vma` 位的设置 ( <<sec-agnostic>>).这些元素的处理方式可以是掩码未干扰或掩码无关。

用于控制掩码向量指令执行的掩码值始终由向量寄存器 `v0` 提供。

NOTE: 掩码存储在向量寄存器中，而不是单独的掩码寄存器文件，这样可以减少整体的架构状态并简化指令集架构。

NOTE: 未来的向量扩展可能会提供更长的指令编码，以支持完整的掩码寄存器指定。

对于掩码向量指令，目标向量寄存器组不能与源掩码寄存器（`v0`）重叠，除非该目标寄存器用于存储掩码值（例如比较操作），或者用于存储归约运算的标量结果。任何违反此规则的指令编码均为保留编码。

NOTE: 该约束旨在支持使用非零 `vstart` 值进行指令重启。

其他向量寄存器可以用于存储工作掩码值，指令集也提供了掩码向量逻辑操作来执行谓词计算. [[sec-mask-vector-logical]]

根据 <<sec-agnostic>> 章节的规范，掩码目标值始终被视为尾部无关（tail-agnostic），无论 vtype 中 `vta` 位的设置如何。

[[sec-vector-mask-encoding]]
===== 掩码编码
在支持掩码的情况下，掩码信息被编码在指令 (`inst[25]`) 的单比特 vm 字段中。

[cols="1,15"]
|===
| vm | 描述

| 0 | 仅当 v0.mask[i] = 1 时，才计算向量结果
| 1 | 无掩码
|===

在汇编代码中，向量掩码被表示为另一个向量操作数，其中 `.t` 表示操作仅在 `v0.mask[i]` = `1` 时执行（`t` 代表“true”）。如果未指定掩码操作数，则默认假定为无掩码的向量执行 (`vm=1`)。

----
    vop.v*    v1, v2, v3, v0.t  # 当 v0.mask[i]=1, vm=0 时有效
    vop.v*    v1, v2, v3        # 无掩码向量操作, vm=1
----

NOTE: 尽管当前的向量扩展仅支持一个向量掩码寄存器 v0 且只支持谓词的真值形式，但汇编语法会将其完全写出，以兼容未来可能添加掩码寄存器说明符并支持真值和补码掩码值的扩展。掩码操作数上的 .t 后缀也有助于直观地编码掩码的使用。

NOTE: `.mask` 后缀不是汇编语法的一部分。我们仅在涉及掩码向量的下标表示时添加，例如 `v0.mask[i]`。

[[sec-inactive-defs]]
==== 预启动、激活、未激活、主体和尾部元素的定义

在执行向量指令时，目标元素索引可分为三个不相交的子集：

* 预启动元素是指索引小于 `vstart` 寄存器初始值的元素。预启动元素不会引发异常，也不会更新目标向量寄存器。

* 主体元素是指索引大于或等于 `vstart` 寄存器初始值，并且小于当前 `vl`（向量长度）设置的元素。主体元素可以进一步分为两个不相交的子集：

** 激活元素是在向量指令执行期间，处于主体范围内且当前掩码在该元素位置启用的元素。激活元素可以引发异常，并更新目标向量寄存器组。

** 未激活元素是在主体范围内但当前掩码在该元素位置被禁用的元素。未激活元素不会引发异常，也不会更新目标向量寄存器组，除非掩码无关模式被指定（`vtype.vma`=1），在这种情况下，未激活元素可能会被覆盖为 1。

* 尾部元素是指超出 `vl`（向量长度）设置的范围的元素。尾部元素不会引发异常，也不会更新目标向量寄存器组，除非尾部无关模式被指定（`vtype.vta`=1）。在尾部无关模式下，尾部元素可能会被覆盖为 1，或者在掩码生成指令（除掩码加载指令外）的情况下，被指令的计算结果覆盖。当 LMUL < 1 时，尾部还包括超出 VLMAX（最大向量长度）但仍存储在同一向量寄存器中的元素。

----
    for element index x
    prestart(x) = (0 <= x < vstart)
    body(x)     = (vstart <= x < vl)
    tail(x)     = (vl <= x < max(VLMAX,VLEN/SEW))
    mask(x)     = unmasked || v0.mask[x] == 1
    active(x)   = body(x) && mask(x)
    inactive(x) = body(x) && !mask(x)
----

当 `vstart` {ge} `vl` 时，不存在主体元素，并且任何目标向量寄存器组中的元素都不会被更新，包括尾部元素也不会被无关值覆盖。

NOTE: 由此可得，当 `vl`=0 时，无论 `vstart` 的值如何，目标向量寄存器组中的任何元素（包括无关元素）都不会被更新。

如果指令写入 `x` 寄存器或 `f` 寄存器，即使 `vstart` {ge} `vl`，包括 `vl=0` 的情况，这些寄存器仍会被写入。

NOTE: 某些指令（如 `vslidedown` 和 `vrgather`）可能会在源向量寄存器组中读取超出 `vl` 甚至 VLMAX 之后的索引。一般策略是，当索引大于源向量寄存器组的 VLMAX 时，返回值 0。

[[sec-vector-config]]
===  配置设定指令 (`vsetvli`/`vsetivli`/`vsetvl`) 

在处理大量元素时，常见的一种方法是分块处理，其中每次循环迭代处理一定数量的元素，并持续迭代，直到所有元素都被处理完。RISC-V 向量规范提供了对这种方法的直接且可移植的支持。应用程序指定要处理的总元素数（应用向量长度，AVL），作为 `vl` 的候选值，硬件则会通过通用寄存器返回每次迭代中硬件将实际处理的元素数量（存储在 vl 中）。这一数量通常比 AVL 小，具体取决于微架构实现和 `vtype` 设置。一个简单的循环结构（见 <<example-stripmine-sew>>）展示了代码如何轻松跟踪剩余元素数量以及每次迭代由硬件处理的元素数量。

下面提供了一组指令用于以快速配置 `vl` 和 `vtype` 的值，使其匹配应用需求。`vset{i}vl{i}` 指令根据其参数设置 `vtype` 和 `vl` 控制状态寄存器，并将 `vl` 的新值写入 `rd`。

----
 vsetvli rd, rs1, vtypei   # rd = new vl, rs1 = AVL, vtypei = new vtype setting
 vsetivli rd, uimm, vtypei # rd = new vl, uimm = AVL, vtypei = new vtype setting
 vsetvl  rd, rs1, rs2      # rd = new vl, rs1 = AVL, rs2 = new vtype value
----

include::images/wavedrom/vcfg-format.adoc[]

==== `vtype` 编码

include::images/wavedrom/vtype-format.adoc[]

新的 `vtype` 值在 `vsetvli` 和 `vsetivli` 指令的立即数字段中进行编码，而在 `vsetvl` 指令中则存储在 `rs2` 寄存器中

----
 推荐的vset{i}vli类型立即数汇编名称

 e8    # SEW=8b
 e16   # SEW=16b
 e32   # SEW=32b
 e64   # SEW=64b

 mf8  # LMUL=1/8
 mf4  # LMUL=1/4
 mf2  # LMUL=1/2
 m1   # LMUL=1, 如果缺少 m 设置，则假定为
 m2   # LMUL=2
 m4   # LMUL=4
 m8   # LMUL=8

Examples:
    vsetvli t0, a0, e8, ta, ma          # SEW= 8, LMUL=1
    vsetvli t0, a0, e8, m2, ta, ma      # SEW= 8, LMUL=2
    vsetvli t0, a0, e32, mf2, ta, ma    # SEW=32, LMUL=1/2
----

`vsetvl` 变体的操作方式类似于 `vsetvli`，不同之处在于它从 `rs2` 获取 `vtype` 值，并且可用于上下文恢复。

===== 不支持的 `vtype` 值

如果 `vtype` 值不受实现支持，则 `vtype` 中的 `vill` 位将被设置，其余位被清零，同时 `vl` 寄存器也被设置为零。

NOTE: 早期草案要求在将 `vtype` 设为非法值时触发异常。然而，这将导致指令集在控制状态寄存器写入时出现首个数据相关的异常。实现可以选择在向 `vtype` 写入非法值时触发异常，而不是设置 `vill`，以便通过仿真支持新的配置，实现前向兼容性。当前方案支持通过检查 `vill` 是否被清除来进行轻量级运行时查询，以确定支持的向量单元配置。

`vtype` 值如果 `vill` 被设置，则视为不受支持的配置。

实现必须检查 `vtype` 值的所有位，以确定配置是否受支持。如果 `vtype` 值的任何位置包含不受支持的值，则必须设置 `vill`。

NOTE: 特别地，`vsetvl` 指令的 `vtype` 参数中所有 XLEN 位都必须进行检查。实现不能忽略未实现的字段。必须检查所有位，以确保假设 `vtype` 中不受支持的向量特性的代码不会在较旧的实现上错误执行，而是会触发异常。

==== AVL encoding

The new vector
length setting is based on AVL, which for `vsetvli` and `vsetvl` is encoded in the `rs1` and `rd`
fields as follows:

.AVL used in `vsetvli` and `vsetvl` instructions
[cols="2,2,10,10"]
[%autowidth,float="center",align="center",options="header"]
|===
|  `rd`  | `rs1`  | AVL value         | Effect on `vl`
|  -     | !x0    | Value in `x[rs1]` | Normal stripmining
| !x0    |  x0    | ~0                | Set `vl` to VLMAX
|  x0    |  x0    | Value in `vl` register | Keep existing `vl` (of course, `vtype` may change)
|===

When `rs1` is not `x0`, the AVL is an unsigned integer held in the `x`
register specified by `rs1`, and the new `vl` value is also written to
the `x` register specified by `rd`.

When `rs1=x0` but `rd!=x0`, the maximum unsigned integer value (`~0`)
is used as the AVL, and the resulting VLMAX is written to `vl` and
also to the `x` register specified by `rd`.

When `rs1=x0` and `rd=x0`, the instruction operates as if the current
vector length in `vl` is used as the AVL, and the resulting value is
written to `vl`, but not to a destination register.  This form can
only be used when VLMAX and hence `vl` is not actually changed by the
new SEW/LMUL ratio.  Use of the instruction with a new SEW/LMUL ratio
that would result in a change of VLMAX is reserved.
Use of the instruction is also reserved if `vill` was 1 beforehand.
Implementations may set `vill` in either case.

NOTE: This last form of the instructions allows the `vtype` register to
be changed while maintaining the current `vl`, provided VLMAX is not
reduced.  This design was chosen to ensure `vl` would always hold a
legal value for current `vtype` setting.  The current `vl` value can
be read from the `vl` CSR.  The `vl` value could be reduced by this
instruction if the new SEW/LMUL ratio causes VLMAX to shrink, and so
this case has been reserved as it is not clear this is a generally
useful operation, and implementations can otherwise assume `vl` is not
changed by this instruction to optimize their microarchitecture.

For the `vsetivli` instruction, the AVL is encoded as a 5-bit
zero-extended immediate (0--31) in the `rs1` field.

NOTE: The encoding of AVL for `vsetivli` is the same as for regular
CSR immediate values.

NOTE: The `vsetivli` instruction provides more compact code when the
dimensions of vectors are small and known to fit inside the vector
registers, in which case there is no stripmining overhead.

==== 设置 `vl` 的约束

`vset{i}vl{i}` 指令首先根据其 `vtype` 参数设置 VLMAX，然后按照以下约束设置 `vl`：

. 如果 `AVL ≤ VLMAX`，则 `vl = AVL`
. 如果 `AVL < (2 * VLMAX)`，则 `ceil(AVL / 2) ≤ vl ≤ VLMAX`
. 如果 `AVL ≥ (2 * VLMAX)`，则 `vl = VLMAX`
. 在相同的输入 AVL 和 VLMAX 值的情况下，实现应保证 `vl` 取值是确定性的
. 以下特性是上述规则的推论：
.. `AVL = 0` 则 `vl = 0`   
.. `AVL > 0` 则 `vl > 0`  
.. `vl {le} VLMAX`
.. `vl {le} AVL`
.. 读取 `vl` 作为 `vset{i}vl{i}` 指令的 AVL 参数时，如果生成的 VLMAX 与 `vl` 被读取时的 VLMAX 相等，
   则 `vl` 保持不变

[NOTE]
--
`vl` 的设定规则被设计得足够严格，以确保在 `AVL ≤ VLMAX` 的情况下，`vl` 的行为在寄存器溢出和上下文切换时保持一致，同时又足够灵活，使得在 `AVL > VLMAX` 的情况下，能够优化向量通道的利用率。

例如，当 `VLMAX < AVL < 2 * VLMAX` 时，实现可以选择 `vl = ceil(AVL / 2)`，以便在分块处理循环的最后两次迭代中均匀分配工作量。
约束 2 确保即使在 `AVL < 2 * VLMAX` 的情况下，归约循环的第一轮分块处理迭代也能使用所有迭代中最大的向量长度。这样，软件就不需要显式计算分开处理循环过程中观察到的最大向量长度。
约束 2 还允许在 `VLMAX < AVL < 2 * VLMAX` 的情况下，将 `vl` 设为 VLMAX。
--

[[example-stripmine-sew]]
==== 分块处理与 SEW 变化示例

SEW 和 LMUL 设置可以动态更改，以在单个循环中为混合宽度的操作提供高吞吐量。
----
 # 示例：加载 16 位值，将其扩展并乘法得到 32 位结果，再将 32 位结果右移 3 位，然后存储 32 位值。
 # 入口：
 #  a0 存储要处理的总元素数量
 #  a1 存储源数组的地址
 #  a2 存储目标数组的地址

loop:
    vsetvli a3, a0, e16, m4, ta, ma  # vtype = 16 位整数向量;
                                     # 同时更新 a3 为 vl（本次迭代的元素数）
    vle16.v v4, (a1)        # 获取 16 位向量
    slli t1, a3, 1          # 将本次迭代的元素数乘以 2 字节/源元素
    add a1, a1, t1          # 增加指针
    vwmul.vx v8, v4, x10    # 在 <v8--v15> 中进行 32 位宽度乘法

    vsetvli x0, x0, e32, m8, ta, ma  # 操作 32 位值
    vsrl.vi v8, v8, 3
    vse32.v v8, (a2)        # 存储 32 位元素向量
    slli t1, a3, 2          # 将本次迭代的元素数乘以 4 字节/目标元素
    add a2, a2, t1          # 增加指针
    sub a0, a0, a3          # 将计数减去 vl
    bnez a0, loop           # 根据情况决定是否继续迭代
----

[[sec-vector-memory]]
=== 向量加载与存储

向量加载和存储用于在向量寄存器和内存之间传输数据。向量加载和存储可以使用掩码，并且仅对激活元素访问内存或触发异常。带掩码的向量加载不会更新目标向量寄存器组中的未激活元素，除非指定了掩码无关模式。所有向量加载和存储指令都可以接受并生成非零的 `vstart` 值。

==== 向量加载/存储指令编码

向量加载和存储指令编码在标量浮点加载和存储的主操作码范围内。这些指令复用了标量浮点加载/存储指令的 12 位立即数字段的一部分，以提供额外的向量指令编码。其中，第 25 位存储标准向量掩码位。（见 <<sec-vector-mask-encoding>>）。

include::images/wavedrom/vmem-format.adoc[]

[cols="4,12"]
|===
| 字段      | 描述

| rs1[4:0]   | 指定存储基地址的 x 寄存器
| rs2[4:0]   | 指定存储步幅的 x 寄存器
| vs2[4:0]   | 指定存储地址偏移的 v 寄存器
| vs3[4:0]   | 指定存储数据的 v 寄存器
| vd[4:0]    | 指定加载目标的 v 寄存器
| vm         | 指定是否启用向量掩码（0 = 启用掩码，1 = 禁用掩码）
| width[2:0] | 指定内存元素的大小，并与标量浮点区分
| mew        | 扩展的内存元素宽度。见 <<sec-vector-loadstore-width-encoding>>
| mop[1:0]   | 指定内存寻址模式
| nf[2:0]    | 指定每个段中的字段数，用于段加载/存储
| lumop[4:0]/sumop[4:0] | 额外字段，编码单元步幅指令的变体
|===

向量内存的单位步长和常量步长操作会在指令中静态编码数据传输的 EEW（元素有效宽度），以减少在混合宽度程序中访问内存时 `vtype` 变更的次数。索引操作使用指令中的显式 EEW 编码来设置用于索引的元素大小，并使用 SEW/LMUL 来指定数据宽度。

==== 向量加载/存储的寻址模式

向量扩展支持以下三种寻址模式：单位步长（unit-stride）、步长（strided）、索引。向量加载/存储的基址寄存器和步长源于通用寄存器 `x` 组。

基址计算所有向量访问的基址有效地址由 `rs1` 指定的 `x` 寄存器内容提供。

向量单位步长操作：访问的元素在内存中是连续存储的，并从基址有效地址开始存取。

向量常量步长操作：第一个元素存取基址有效地址，后续元素按照 `rs2` 指定的 `x` 寄存器中的字节偏移量进行地址递增。

向量索引操作计算每个元素的有效地址时，采用如下方式：由 `vs2` 指定的向量偏移操作数的每个元素值加上基址有效地址，计算得到每个元素的最终地址。数据向量寄存器组的 EEW=SEW，EMUL=LMUL。偏移向量寄存器组的 EEW 由指令编码决定，EMUL=(EEW/SEW)×LMUL。向量偏移操作数被视为字节地址偏移量的向量。

NOTE: 索引操作也可用于访问结构体数组中的字段。其中 vs2 向量保存指向对象基址的指针，标量 x 寄存器保存每个对象中成员字段的偏移量。支持这种情况是为什么索引操作没有被定义为按数据 EEW 缩放元素索引的原因。

若偏移向量元素宽度小于 XLEN，则零扩展至 XLEN 后再加上基址地址。若偏移向量元素宽度大于 XLEN，则仅取低 XLEN 位用于地址计算。若 EEW（元素有效宽度）不受支持，实现必须引发非法指令异常。

NOTE: 某些硬件可能会对索引 EEW 施加上限（例如仅支持最大 XLEN，小于 ELEN）。

向量寻址模式由2-bit `mop[1:0]` 字段进行编码。

.加载指令的编码
[cols="1,1,7,6"]
|===
2+| mop [1:0] | 描述 | 操作码

| 0 | 0 | 单位步长       | VLE<EEW>
| 0 | 1 | 无序索引 | VLUXEI<EEW>
| 1 | 0 | 步长           | VLSE<EEW>
| 1 | 1 | 有序索引   | VLOXEI<EEW>
|===

.存储指令的编码
[cols="1,1,7,6"]
|===
2+| mop [1:0] | 描述 | 操作码

| 0 | 0 | 单位步长       | VSE<EEW>
| 0 | 1 | 无序索引 | VSUXEI<EEW>
| 1 | 0 | 步长           | VSSE<EEW>
| 1 | 1 | 有序索引   | VSOXEI<EEW>
|===

向量单位步长和常量步长的内存访问不保证各个元素访问的顺序。向量索引加载和存储指令提供两种形式：有序和无序。索引有序指令在内存访问时会保留元素的顺序。

对于无序指令（mop[1:0] ≠ 11），元素访问的顺序不受保证。如果访问的是强序的 IO 区域，元素访问可以以任意顺序发起。

NOTE: 如果要对强顺序性 IO 区域提供有序的向量访问，则应使用索引有序指令。

对于支持精确向量异常的实现：索引无序存储的异常必须是精确的。

单位步长加载和存储指令中，使用5-bit `lumop` 和 `sumop` 字段对额外的单位步长向量寻址模式进行编码。

.lumop
[cols="1,1,1,1,1,11"]
|===
5+| lumop[4:0] | 描述

| 0 | 0 | 0 | 0 | 0 | 单位步长加载
| 0 | 1 | 0 | 0 | 0 | 单位步长, 完整寄存器加载
| 0 | 1 | 0 | 1 | 1 | 单位步长, 掩码加载, EEW=8
| 1 | 0 | 0 | 0 | 0 | 单位步长仅故障首次(fault-only-first)
| x | x | x | x | x | 保留给其它编码
|===

.sumop
[cols="1,1,1,1,1,11"]
|===
5+| sumop[4:0] | 描述

| 0 | 0 | 0 | 0 | 0 | 单位步长存储
| 0 | 1 | 0 | 0 | 0 | 单位步长, 完整寄存器存储
| 0 | 1 | 0 | 1 | 1 | 单位步长, 掩码存储, EEW=8
| x | x | x | x | x | 保留给其它编码
|===

`nf[2:0]` 字段用于编码每个段中的字段数。对于常规向量加载和存储，`nf`=0，表示每个元素位置在向量寄存器组和内存之间仅移动一个值。更大的 `nf` 值用于访问段内多个连续字段，具体说明见 <<sec-aos>>。

此外，`nf[2:0]` 字段还用于编码整个向量寄存器加载/存储指令所需传输的完整向量寄存器数量。

[[sec-vector-loadstore-width-encoding]]
==== 向量加载/存储宽度编码

向量加载和存储指令的 EEW（元素有效宽度） 直接编码在指令中。计算 EMIL 的公式为 EMUL =(EEW/SEW)*LMUL。 如果 EMUL 超出范围（即 EMUL > 8 或 EMUL < 1/8），该指令编码会被保留。选定的 EMUL 必须具有合法的寄存器组编号，否则指令编码会被保留。

向量单位步长和常量步长使用指令中编码的 EEW/EMUL 来处理数据值，而向量索引加载和存储则使用指令中编码的 EEW/EMUL 来处理索引值，使用 `vtype` 中的 SEW/LMUL 来处理数据值。

向量加载和存储使用的编码宽度是标准标量浮点加载和存储未占用的宽度值。

实现必须提供与所有支持的 SEW 设置对应的 EEW 的向量加载和存储。对于不支持的 EEW 宽度的向量加载/存储编码，必须触发非法指令异常。

.向量加载/存储的宽度编码表
[cols="5,1,1,1,1,>3,>3,>3,3"]
|===
|                  | mew位 3+| width [2:0] | 内存位 | 数据寄存器位 | 索引位 | 操作码

| Standard scalar FP   | x |   0 | 0 | 1 |   16| FLEN | -  | FLH/FSH
| Standard scalar FP   | x |   0 | 1 | 0 |   32| FLEN | -  | FLW/FSW
| Standard scalar FP   | x |   0 | 1 | 1 |   64| FLEN | -  | FLD/FSD
| Standard scalar FP   | x |   1 | 0 | 0 |  128| FLEN | -  | FLQ/FSQ
| Vector 8b element    | 0 |   0 | 0 | 0 |    8|    8 | -  | VLxE8/VSxE8
| Vector 16b element   | 0 |   1 | 0 | 1 |   16|   16 | -  | VLxE16/VSxE16
| Vector 32b element   | 0 |   1 | 1 | 0 |   32|   32 | -  | VLxE32/VSxE32
| Vector 64b element   | 0 |   1 | 1 | 1 |   64|   64 | -  | VLxE64/VSxE64
| Vector 8b index      | 0 |   0 | 0 | 0 | SEW | SEW  |  8 | VLxEI8/VSxEI8
| Vector 16b index     | 0 |   1 | 0 | 1 | SEW | SEW  | 16 | VLxEI16/VSxEI16
| Vector 32b index     | 0 |   1 | 1 | 0 | SEW | SEW  | 32 | VLxEI32/VSxEI32
| Vector 64b index     | 0 |   1 | 1 | 1 | SEW | SEW  | 64 | VLxEI64/VSxEI64
| Reserved             | 1 |   X | X | X |   - |    - | -  |
|===

内存位是内存中每个元素的大小。

数据寄存器位是寄存器中每个数据元素的大小。

索引位是寄存器中每个索引的大小。

当 mew 位（inst[28]）被设置时，预计用于编码 128 位及以上的扩展内存大小，但这些编码当前是保留的。

==== 向量单位步长指令

----
    # 向量单位步长加载和存储

    # vd 目标寄存器，rs1 基地址，vm 为掩码编码（v0.t 或 <缺失>）
    vle8.v    vd, (rs1), vm  #    8位单位步长加载
    vle16.v   vd, (rs1), vm  #   16位单位步长加载
    vle32.v   vd, (rs1), vm  #   32位单位步长加载
    vle64.v   vd, (rs1), vm  #   64位单位步长加载

    # vs3 存储数据，rs1 基地址，vm 为掩码编码（v0.t 或 <缺失>）
    vse8.v    vs3, (rs1), vm  #   8位单位步长存储
    vse16.v   vs3, (rs1), vm  #  16位单位步长存储
    vse32.v   vs3, (rs1), vm  #  32位单位步长存储
    vse64.v   vs3, (rs1), vm  #  64位单位步长存储
----

额外的单位步长掩码加载和存储指令被提供，用于将掩码值传输到内存或从内存传输。这些指令的操作与未掩码字节加载或存储（EEW=8）类似，唯一的区别是有效向量长度为``evl``=ceil(``vl``/8)（即 EMUL=1），并且目标寄存器始终使用与尾部无关的策略进行写入。

----
    # 向量单位步长掩码加载
    vlm.v vd, (rs1)    #  加载长度为 ceil(vl/8) 的字节向量

    # 向量单位步长掩码存储
    vsm.v vs3, (rs1)   #  存储长度为 ceil(vl/8) 的字节向量
----

`vlm.v` 和 `vsm.v` 与 `vle8.v` 和 `vse8.v` 使用相同的 `width[2:0]`=0 编码，但通过不同的 `lumop` 和 `sumop` 
编码加以区分。由于 `vlm.v` 和 `vsm.v` 作为字节加载和存储指令工作，因此这些指令的 `vstart` 是按字节为单位的。

NOTE: `vlm.v` 和 `vsm.v` 会遵循 `vtype` 中的 `vill` 字段，因为它们通过 `vtype` 间接依赖于 `vl` 的约束。

NOTE: 之前的汇编助记符 `vle1.v` 和 `vse1.v` 由于处理长度的方式与其他元素加载/存储指令不同，容易引起混淆。为了避免软件更新带来的麻烦，这些旧的汇编助记符被保留为别名。

NOTE: 提供掩码加载和存储的主要动机是支持那些内部重新排列数据以减少跨数据通路布线的机器。然而，这些指令也为在内存中使用打包的位向量作为掩码值提供了便捷的机制，并通过减少对 `vl` 的修改，降低了掩码溢出/填充的成本。

==== 向量步长指令

----
    # 向量步长加载和存储

    # vd 为目标寄存器，rs1 为基地址，rs2 为字节步长
    vlse8.v    vd, (rs1), rs2, vm  #    8位步长加载
    vlse16.v   vd, (rs1), rs2, vm  #   16位步长加载
    vlse32.v   vd, (rs1), rs2, vm  #   32位步长加载
    vlse64.v   vd, (rs1), rs2, vm  #   64位步长加载

    # vs3 为存储数据，rs1 为基地址，rs2 为字节步长
    vsse8.v    vs3, (rs1), rs2, vm  #    8位步长存储
    vsse16.v   vs3, (rs1), rs2, vm  #   16位步长存储
    vsse32.v   vs3, (rs1), rs2, vm  #   32位步长存储
    vsse64.v   vs3, (rs1), rs2, vm  #   64位步长存储
----

支持负步长和零步长。

在步长指令中，元素访问是无序的，元素之间没有顺序关系。

当 rs2=x0 时，允许但不要求实现执行的内存操作次数少于激活元素的数量，并且可能在同一静态指令的不同动态执行中执行不同数量的内存操作。

NOTE: 编译器必须注意，当立即步幅为 `0` 且意图要求执行所有内存访问时，不能使用 `x0` 形式作为 `rs2`。

且 `x[rs2] = 0` 时，实施必须为每个激活元素执行一次内存访问（但这些访问是无序的）。

NOTE: 与其他架构规定一样，实施必须看起来进行了每一次内存访问。微架构可以优化掉那些不会被其他代理观察到的访问，例如，在遵守 RVWMO 的幂等内存区域中。对于非幂等内存区域，由于定义上每次访问都可以被设备观察到，因此无法进行这种优化。

NOTE: 当需要对同一内存地址进行重复有序的向量访问时，可以使用有序索引操作。

==== 向量索引指令

----
   # 向量索引加载和存储

    # 向量索引-无序加载指令
    # vd 目标寄存器，rs1 基地址，vs2 字节偏移
    vluxei8.v    vd, (rs1), vs2, vm  # 无序 8位索引加载 SEW 数据
    vluxei16.v   vd, (rs1), vs2, vm  # 无序 16位索引加载 SEW 数据
    vluxei32.v   vd, (rs1), vs2, vm  # 无序 32位索引加载 SEW 数据
    vluxei64.v   vd, (rs1), vs2, vm  # 无序 64位索引加载 SEW 数据

    # 向量索引-有序加载指令
    # vd 目标寄存器，rs1 基地址，vs2 字节偏移
    vloxei8.v    vd, (rs1), vs2, vm  # 有序 8位索引加载 SEW 数据
    vloxei16.v   vd, (rs1), vs2, vm  # 有序 16位索引加载 SEW 数据
    vloxei32.v   vd, (rs1), vs2, vm  # 有序 32位索引加载 SEW 数据
    vloxei64.v   vd, (rs1), vs2, vm  # 有序 64位索引加载 SEW 数据

    # 向量索引-无序存储指令
    # vs3 存储数据，rs1 基地址，vs2 字节偏移
    vsuxei8.v   vs3, (rs1), vs2, vm # 无序 8位索引存储 SEW 数据
    vsuxei16.v  vs3, (rs1), vs2, vm # 无序 16位索引存储 SEW 数据
    vsuxei32.v  vs3, (rs1), vs2, vm # 无序 32位索引存储 SEW 数据
    vsuxei64.v  vs3, (rs1), vs2, vm # 无序 64位索引存储 SEW 数据

    # 向量索引-有序存储指令
    # vs3 存储数据，rs1 基地址，vs2 字节偏移
    vsoxei8.v    vs3, (rs1), vs2, vm  # 有序 8位索引存储 SEW 数据
    vsoxei16.v   vs3, (rs1), vs2, vm  # 有序 16位索引存储 SEW 数据
    vsoxei32.v   vs3, (rs1), vs2, vm  # 有序 32位索引存储 SEW 数据
    vsoxei64.v   vs3, (rs1), vs2, vm  # 有序 64位索引存储 SEW 数据

----

NOTE: 索引加载和存储的汇编语法使用 ``ei`` __x__ 而不是 ``e`` __x__ 以表示静态编码的 EEW 是索引的，而不是数据的。

NOTE: 索引操作的助记符使用了 "U" 或 "O" 来区分无序和有序，而其他向量寻址模式没有这个字符。虽然这种做法可能稍显不一致，但这种方式最小化了对现有软件的干扰，因为之前的 VSXEI 表示 "有序" —— 在过渡期间，可以将操作码保留为别名，帮助减少软件的变动。

==== 单位步幅仅首次故障加载（Fault-Only-First Loads）

单位步幅仅首次故障加载指令用于向量化具有数据依赖退出条件的循环（“while”循环）。这些指令作为常规加载执行，唯一的不同是它们只会在元素 0 上遇到同步异常时才会触发陷阱。如果元素 0 引发异常，`vl` 不会修改，并且陷阱会被触发。如果元素 > 0 引发异常，则不会触发相应的陷阱，且向量长度 `vl` 会减少到本应引发异常的元素的索引。

加载指令可能会覆盖在报告陷阱的元素索引之后的活跃目标向量寄存器组元素。类似地，故障只对首个元素生效的加载指令也可能更新超出导致向量长度裁剪的元素的目标元素（但不会超过初始向量长度）。这些虚假更新的值不必与内存中对应地址位置的值一致。非幂等内存位置只能在知道相应的元素加载操作不会因陷阱或向量长度裁剪而重新启动时访问。

----
    # 向量单位步长故障只对首个元素生效的加载指令

    # vd 目标寄存器，rs1 基地址，vm 是掩码编码（v0.t 或 <缺失>）
    vle8ff.v    vd, (rs1), vm  #    8位单位步长故障只对首个元素生效的加载
    vle16ff.v   vd, (rs1), vm  #   16位单位步长故障只对首个元素生效的加载
    vle32ff.v   vd, (rs1), vm  #   32位单位步长故障只对首个元素生效的加载
    vle64ff.v   vd, (rs1), vm  #   64位单位步长故障只对首个元素生效的加载
----

----
使用单位步长故障只对首个元素生效的指令的 strlen 示例

include::example/strlen_zh.s[lines=4..-1]
----

NOTE: 故障只对首个元素生效的加载指令存在安全隐患，因为它们可以用来探测有效的地址。单位步长版本只允许探测与已知区域相邻的区域，因此在非特权代码中使用时，减少了安全风险。然而，运行在S模式的代码可以建立任意的页翻译，从而允许探测由虚拟机监控程序提供的随机访客物理地址。由于编码空间的限制，幅和散射/聚集故障仅首次指令未被提供，但它们也可能代表一个更大的安全漏洞，允许即使是未特权软件也能轻松检查多个随机页面的可访问性，而不会触发陷阱。本标准未涉及故障仅首次指令可能的安全缓解措施。

即使未引发异常，实施仍然可以处理少于 `vl` 个元素，并相应地减少 `vl`，但如果 `vstart`= 0 且 `vl` >0，则必须处理至少一个元素。

当故障只对首个元素生效的指令由于中断而触发陷阱时，实施不应减少 `vl` ，而应设置 `vstart` 值。

NOTE: 当故障只对首个元素生效的指令在处理第一个元素之后触发调试数据观察点陷阱时，实施不应减少 `vl`，而应触发调试陷阱，否则该事件可能会丢失。

[[sec-aos]]
==== 向量加载/存储分段指令

向量加载/存储分段指令用于在多个连续编号的向量寄存器之间移动内存中的多个连续字段。

NOTE: “分段”这个名称表明移动的项是包含同类元素的子数组。这些操作可以用于在内存和寄存器之间转置数组，也可以通过将结构体中的每个字段解包到一个单独的向量寄存器中，支持对“结构体数组”数据类型的操作。

向量指令编码中的三位 `nf` 字段是一个无符号整数，包含每个分段中字段数减去 1 的值，表示字段的数量（即_NFIELDS_）。

[[fig-nf]]
.NFIELDS 编码
[cols="1,1,1,13"]
|===
3+| nf[2:0] | NFIELDS

| 0 | 0 | 0 | 1
| 0 | 0 | 1 | 2
| 0 | 1 | 0 | 3
| 0 | 1 | 1 | 4
| 1 | 0 | 0 | 5
| 1 | 0 | 1 | 6
| 1 | 1 | 0 | 7
| 1 | 1 | 1 | 8
|===

EMUL设置必须满足EMUL * NFIELDS ≤ 8，否则该指令编码是被保留的。

NOTE: ceil(EMUL) * NFIELDS的乘积表示将由分段加载或存储指令访问的底层向量寄存器的数量。这个约束确保总数不超过架构寄存器文件的1/4，并且与常规操作（EMUL=8）一致。

每个字段将被保存在依次编号的向量寄存器组中。当 EMUL>1 时，每个字段将占据多个依次编号的向量寄存器组，并且每个字段的向量寄存器组必须遵循常规的向量寄存器对齐约束（例如，当 EMUL=2 且 NFIELDS=4 时，每个字段的向量寄存器组必须从偶数编号的向量寄存器开始，但不必从 8 的倍数开始）。

如果分段加载或存储指令访问的向量寄存器编号超过 31 ，则指令编码将被保留。

NOTE: 这个约束有助于为可能的未来更长指令编码提供向前兼容性，这种编码可以访问更多的向量寄存器。

`vl` 寄存器给出了要移动的分段数，该数值等于每个向量寄存器组传输的元素数。掩码也应用于整个分段级别。

对于分段加载和存储，在每个分段内访问字段的单独内存访问是无序的，即使是有序的索引分段加载和存储指令也是如此。

`vstart` 值以整个分段为单位。如果在访问分段期间发生陷阱，是否执行分段内某些故障字段的访问（在触发陷阱之前）由实现定义。

===== 向量单位步长分段加载和存储

向量单位步长加载和存储分段指令将打包的连续分段移动到多个目标向量寄存器组中。

NOTE: 当分段包含具有异质大小字段的结构时，软件可以在分段加载将数据带入向量寄存器后，使用额外的指令拆包各个结构字段。

汇编器前缀 `vlseg`/`vsseg` 分别用于单位步长分段加载和存储。

----
   # 格式
    vlseg<nf>e<eew>.v vd, (rs1), vm      # 单位步长分段加载模板
    vsseg<nf>e<eew>.v vs3, (rs1), vm     # 单位步长分段存储模板

    # 示例
    vlseg8e8.v vd, (rs1), vm   # 使用八字节字段加载八个向量寄存器。

    vsseg3e32.v vs3, (rs1), vm  # 从内存中将3*4字节的打包向量（vs3, vs3+1, vs3+2）存储到内存
----

对于加载操作，`vd` 寄存器将保存从分段中加载的第一个字段。对于存储操作，`vs3` 寄存器被读取，用于提供每个分段要存储的第一个字段。

----
    # 示例 1
    # 内存结构保存打包的RGB像素（24位数据结构，8bpp）
    vsetvli a1, t0, e8, ta, ma
    vlseg3e8.v v8, (a0), vm
    # v8 保存红色像素
    # v9 保存绿色像素
    # v10 保存蓝色像素

    # 示例 2
    # 内存结构保存复数值，32位为实部，32位为虚部
    vsetvli a1, t0, e32, ta, ma
    vlseg2e32.v v8, (a0), vm
    # v8 保存实部
    # v9 保存虚部
----

还存在单位步长指令的故障只对首个元素生效版本。

----
    # 向量故障只对首个元素生效的单位步长分段加载模板
    vlseg<nf>e<eew>ff.v vd, (rs1),  vm    # 单位步长故障只对首个元素生效的分段加载
----

对于故障只对首个元素生效的分段加载，如果在访问分段过程中检测到异常，无论元素索引是否为零，都由实现定义是否加载分段的子集。

这些指令可能会覆盖在报告陷阱或向量长度裁剪点之后的目标向量寄存器组元素。

===== 向量跨步分段加载和存储

向量跨步分段加载和存储将连续的分段移动，其中每个分段由 `rs2` 寄存器指定的字节跨步偏移量分隔。

NOTE: 支持负步长和零步长。

----
    # 格式
    vlsseg<nf>e<eew>.v vd, (rs1), rs2, vm          # 跨步分段加载
    vssseg<nf>e<eew>.v vs3, (rs1), rs2, vm         # 跨步分段存储

    # 示例
    vsetvli a1, t0, e8, ta, ma
    vlsseg3e8.v v4, (x5), x6    # 将地址x5+i*x6处的字节加载到v4[i]，
                                # 并将地址x5+i*x6+1处的字节加载到v5[i]，
                                # 将地址x5+i*x6+2处的字节加载到v6[i]。

    # 示例
    vsetvli a1, t0, e32, ta, ma
    vssseg2e32.v v2, (x5), x6   # 将v2[i]中的字存储到地址x5+i*x6，
                                # 并将v3[i]中的字存储到地址x5+i*x6+4

----

每个分段内字段的访问顺序可以是任意的，包括字节跨步导致分段在内存中重叠的情况。

===== 向量索引分段加载和存储

向量索引分段加载和存储将连续的分段移动，每个分段的位置由将标量基地址（`rs1` 字段中的地址）与向量寄存器 `vs2` 中的字节偏移量相加来确定。提供了有序和无序两种形式，其中有序形式按照元素顺序访问分段。然而，即使是有序形式，对于单个分段内字段的访问也是无序的。

数据向量寄存器组的 EEW=SEW，EMUL=LMUL，而索引向量寄存器组的 EEW 在指令中编码，EMUL=(EEW/SEW)*LMUL。EMUL * NFIELDS {le} 8 这一约束适用于数据向量寄存器组。

----
    # 格式
    vluxseg<nf>ei<eew>.v vd, (rs1), vs2, vm   # 索引无序分段加载
    vloxseg<nf>ei<eew>.v vd, (rs1), vs2, vm   # 索引有序分段加载
    vsuxseg<nf>ei<eew>.v vs3, (rs1), vs2, vm  # 索引无序分段存储
    vsoxseg<nf>ei<eew>.v vs3, (rs1), vs2, vm  # 索引有序分段存储

    # 示例
    vsetvli a1, t0, e8, ta, ma
    vluxseg3ei8.v v4, (x5), v3      # 将地址 x5+v3[i] 处的字节加载到 v4[i]，
                                    # 并将地址 x5+v3[i]+1 处的字节加载到 v5[i]，
                                    # 将地址 x5+v3[i]+2 处的字节加载到 v6[i]。

    # 示例
    vsetvli a1, t0, e32, ta, ma
    vsuxseg2ei32.v v2, (x5), v5     # 将 v2[i] 中的字存储到地址 x5+v5[i]，
                                    # 并将 v3[i] 中的字存储到地址 x5+v5[i]+4
----

对于向量索引分段加载，目标向量寄存器组不能与源向量寄存器组（由 `vs2` 指定）重叠，否则指令编码将被保留。

NOTE: 这个约束支持重新启动索引分段加载，当加载结构体的过程中部分发生异常时，能够重新开始加载。

==== 向量加载/存储全寄存器指令

在 LOAD-FP 主要操作码下，向量加载整个寄存器指令的格式

////
31 29  28  27 26  25 24   20 19       15 14   12 11      7 6     0
 nf  | mew|  00  | 1| 01000 |    rs1    | width |    vd   |0000111| VL<nf>R
////

[wavedrom,,svg]
....
{reg: [
  {bits: 7, name: 0x07, attr: 'VL*R*'},
  {bits: 5, name: 'vd', attr: 'destination of load', type: 2},
  {bits: 3, name: 'width'},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 8, attr: 'lumop'},
  {bits: 1, name: 1, attr: 'vm'},
  {bits: 2, name: 0x10000, attr: 'mop'},
  {bits: 1, name: 'mew'},
  {bits: 3, name: 'nf'},
]}
....

在 STORE-FP 主要操作码下，向量存储全寄存器指令的格式

////
31 29  28  27 26  25  24  20 19       15 14   12 11      7 6     0
 nf  |  0 |  00  | 1| 01000 |    rs1    |  000  |   vs3   |0100111| VS<nf>R
////

[wavedrom,,svg]
....
{reg: [
  {bits: 7, name: 0x27, attr: 'VS*R*'},
  {bits: 5, name: 'vs3', attr: 'store data', type: 2},
  {bits: 3, name: 0x1000},
  {bits: 5, name: 'rs1', attr: 'base address', type: 4},
  {bits: 5, name: 8, attr: 'sumop'},
  {bits: 1, name: 1, attr: 'vm'},
  {bits: 2, name: 0x100, attr: 'mop'},
  {bits: 1, name: 0x100, attr: 'mew'},
  {bits: 3, name: 'nf'},
]}
....

这些指令用于加载和存储整个向量寄存器组。

NOTE: 这些指令的设计目的是在当前向量寄存器的内容类型或长度未知，或者修改 `vl` 和 `vtype` 会非常耗时的情况下，保存和恢复向量寄存器。例如，这些情况包括编译器寄存器溢出、通过向量寄存器传递值的向量函数调用、处理中断的中断处理程序和操作系统上下文切换等。软件可以通过读取 `vlenb` 寄存器来确定传输的字节数。

加载指令的 EEW 编码位于 `mew` 和 `width` 字段中，遵循常规单元步长加载的模式。

NOTE: 由于寄存器内字节布局与内存中的字节布局相同，因此无论 EEW 是什么，写入目标寄存器组的数据都是相同的。因此，实际上只提供 EEW=8 的变体就足够了。提供完整的 EEW 变体是为了使编码的 EEW 可以作为一个提示，指示目标寄存器组接下来将使用这个 EEW 进行访问，这有助于重新排列数据的实现。

向量全寄存器存储指令的编码类似于未屏蔽的单元步长元素存储，EEW=8。

`nf` 字段的含义是使用 NFIELDS 编码加载和存储多少个向量寄存器（见图 <<fig-nf>>）。编码的寄存器数目必须是 2 的幂，且向量寄存器编号必须像向量寄存器组那样对齐，否则该指令编码是保留的。NFIELDS 表示要传输的向量寄存器的数量，这些寄存器按顺序编号，从基地址开始。仅支持 NFIELDS 值为 1、2、4、8，其他值是保留的。当传输多个寄存器时，编号最小的向量寄存器将存放在内存地址中最小的地方，随后编号的向量寄存器依次排列在内存中。

这些指令使用有效向量长度 evl = NFIELDS * VLEN / EEW 进行操作，而不受当前 `vtype` 和 `vl` 设置的影响。通常的特性是，如果 `vstart` {ge} `vl` 则不写入任何元素，但对于这些指令，该属性不适用。相反，只有当 `vstart` {ge} `evl` 时，才不会写入任何元素。

这些指令的操作方式类似于未屏蔽的单元步长加载和存储指令，基地址通过由 `rs1` 指定的标量 `x` 寄存器传递。

如果基地址没有按自然对齐到编码的 EEW 字节大小（EEW/8）或实现支持的最小 SEW 字节大小（SEW_MIN/8），实现可以允许在整个寄存器加载和存储时触发地址不对齐异常。

NOTE: 允许根据与编码的 EEW 不对齐来抛出不对齐异常，可以简化这些指令的实现。一些子集实现可能不支持较小的 SEW 宽度，因此即使大于编码的 EEW，也允许报告不对齐异常。极端的非标准实现可能有 SEW_MIN > XLEN。例如，软件环境可以要求最低对齐要求，以支持 ABI。

----
    # 整个寄存器加载和存储指令的格式vl1r.v v3, (a0) # 等效于 vl1re8.v 的伪指令

    vl1re8.v v3, (a0)  # 将 v3 加载为位于 a0 地址处的 VLEN/8 字节数据 
    vl1re16.v v3, (a0) # 将 v3 加载为位于 a0 地址处的 VLEN/16 半字数据 
    vl1re32.v v3, (a0) # 将 v3 加载为位于 a0 地址处的 VLEN/32 字数据 
    vl1re64.v v3, (a0) # 将 v3 加载为位于 a0 地址处的 VLEN/64 双字数据

    vl2r.v v2, (a0)    # 等效于 vl2re8.v 的伪指令

    vl2re8.v v2, (a0)  # 将 v2-v3 加载为位于 a0 地址处的 2VLEN/8 字节数据 
    vl2re16.v v2, (a0) # 将 v2-v3 加载为位于 a0 地址处的 2VLEN/16 半字数据 
    vl2re32.v v2, (a0) # 将 v2-v3 加载为位于 a0 地址处的 2VLEN/32 字数据 
    vl2re64.v v2, (a0) # 将 v2-v3 加载为位于 a0 地址处的 2VLEN/64 双字数据

    vl4r.v v4, (a0)    # 等效于 vl4re8.v 的伪指令

    vl4re8.v v4, (a0)  # 将 v4-v7 加载为位于 a0 地址处的 4VLEN/8 字节数据 
    vl4re16.v v4, (a0) # 将 v4-v7 加载为位于 a0 地址处的 4VLEN/16 半字数据 
    vl4re32.v v4, (a0) # 将 v4-v7 加载为位于 a0 地址处的 4VLEN/32 字数据 
    vl4re64.v v4, (a0) # 将 v4-v7 加载为位于 a0 地址处的 4VLEN/64 双字数据

    vl8r.v v8, (a0)    # 等效于 vl8re8.v 的伪指令

    vl8re8.v v8, (a0)  # 将 v8-v15 加载为位于 a0 地址处的 8VLEN/8 字节数据
    vl8re16.v v8, (a0) # 将 v8-v15 加载为位于 a0 地址处的 8VLEN/16 半字数据 
    vl8re32.v v8, (a0) # 将 v8-v15 加载为位于 a0 地址处的 8VLEN/32 字数据 
    vl8re64.v v8, (a0) # 将 v8-v15 加载为位于 a0 地址处的 8VLEN/64 双字数据

    vs1r.v v3, (a1)    # 将 v3 存储到 a1 地址处 
    vs2r.v v2, (a1)    # 将 v2-v3 存储到 a1 地址处 
    vs4r.v v4, (a1)    # 将 v4-v7 存储到 a1 地址处 
    vs8r.v v8, (a1)    # 将 v8-v15 存储到 a1 地址处
----

NOTE: 实现应当在不支持的 EEW 值下，对于 vl<nf>r 指令触发非法指令异常。

NOTE: 我们曾考虑添加一个整个寄存器掩码加载指令（vl1rm.v），但决定在初始扩展中省略该指令。其主要目的是通知微架构数据将作为掩码使用。可以通过以下代码序列实现相同的效果，其成本最多为四条指令。在这些指令中，第一条指令可能不需要，因为 `vl` 通常已经在标量寄存器中，最后一条指令在接下来的向量指令需要新的 SEW/LMUL 的情况下可能已经存在。因此，在最佳情况下，只需要两条指令（其中只有一条执行向量操作）即可合成专用指令的效果：

----
  csrr t0, vl                        # 保存当前的 vl（可能不需要）
  vsetvli t1, x0, e8, m8, ta, ma     # 设置最大 VLMAX
  vlm.v v0, (a0)                     # 加载掩码寄存器 
  vsetvli x0, t0, <new type>         # 恢复 vl（可能已经存在）
----

=== 向量内存对齐约束

如果向量内存指令访问的元素没有按元素的自然大小对齐，元素要么成功传输，要么在该元素上触发地址未对齐异常。

对未对齐的向量内存访问的支持独立于实现对未对齐标量内存访问的支持。

NOTE: 一个实现可以没有、一个，或者两个标量和向量内存访问，硬件支持部分或全部的未对齐访问。应该定义一个单独的 PMA 来确定是否在相关地址范围内支持向量未对齐访问。

向量未对齐的内存访问遵循与标量未对齐内存访问相同的原子性规则。

=== 向量内存一致性模型

对外部观察者而言，向量内存指令在本地硬件线程上按程序顺序执行。

向量内存指令在指令级别遵循 RVWMO。如果实现了 Ztso 扩展，向量内存指令还会在指令级别遵循 RVTSO。

除向量索引有序加载和存储外，元素操作在指令内是无序的。

向量索引有序的加载和存储按元素顺序从内存中加载和写入元素，遵循 RVWMO 在元素级别的规则。

NOTE: Ztso 仅在指令级别施加 RVTSO；无论 Ztso 是否实现，指令内的顺序遵循 RVWMO。

NOTE: 需要更多的正式定义。

受向量长度寄存器 `vl` 影响的指令对 `vl` 具有控制依赖关系，而不是数据依赖关系。类似地，受掩码影响的向量指令对源掩码寄存器有控制依赖关系，而不是数据依赖关系。

NOTE: 将向量长度和掩码视为控制而非数据，通常与相应的标量代码的语义一致，在标量代码中通常会使用分支指令。将掩码视为控制使得掩码向量加载指令能够在掩码值尚未确定之前访问内存，无需错失恢复机制。

=== 向量算术指令格式

向量算术指令使用一个新的主操作码（OP-V = 1010111₂），该操作码与 OP-FP 相邻。三位的 funct3 字段
用于定义向量指令的子类别。

include::images/wavedrom/valu-format.adoc[]

[[sec-arithmetic-encoding]]
==== 向量算术指令编码

`funct3` 字段编码了操作数类型和源位置。

.funct3
[cols="1,1,1,3,5,5"]
|===
3+| funct3[2:0] | 算法 | 操作数 | 标量操作数类型

| 0 | 0 | 0 | OPIVV | vector-vector    |       N/A
| 0 | 0 | 1 | OPFVV | vector-vector    |       N/A
| 0 | 1 | 0 | OPMVV | vector-vector    |       N/A
| 0 | 1 | 1 | OPIVI | vector-immediate | `imm[4:0]`
| 1 | 0 | 0 | OPIVX | vector-scalar    | GPR `x` register `rs1`
| 1 | 0 | 1 | OPFVF | vector-scalar    | FP `f` register `rs1`
| 1 | 1 | 0 | OPMVX | vector-scalar    | GPR `x` register `rs1`
| 1 | 1 | 1 | OPCFG | scalars-imms     | GPR `x` register `rs1` & `rs2`/`imm`
|===

整数操作使用无符号或二进制补码的有符号整数算术进行，具体取决于操作码。

NOTE: 在本讨论中，定点运算被视为整数运算。

所有标准的向量浮点算术操作遵循 IEEE-754/2008 标准。所有向量浮点操作使用 `frm` 寄存器中的动态舍入模式。如果 `frm` 字段包含无效的舍入模式，任何向量浮点指令（即使是那些不依赖于舍入模式的指令，或者当 `vl`=0，或者当 `vstart` ≥ `vl` 时）都会保留。

NOTE: 所有向量浮点代码将依赖于 `frm` 中的有效值。实现可以使所有向量浮点指令在舍入模式无效时报告异常，以简化控制逻辑。

向量-向量操作从分别由 `vs2` 和 `vs1` 指定的向量寄存器组中获取两个操作数。

向量-标量操作可以有三种可能的形式。在这三种形式中，向量寄存器组操作数由 `vs2` 指定。第二个标量源操作数来自以下三种选择之一：

. 对于整数操作，标量可以是编码在 `rs1` 字段中的 5 位立即数 imm[4:0]，该值将符号扩展到 SEW 位，除非另有说明。

. 对于整数操作，标量可以来自由 `rs1` 指定的标量 `x` 寄存器。如果 XLEN > SEW，则使用 `x` 寄存器的最低 SEW 位，除非另有说明。如果 XLEN < SEW，则将 `x` 寄存器的值符号扩展到 SEW 位。

. 对于浮点操作，标量可以来自标量 `f` 寄存器。如果 FLEN > SEW，则会检查 `f` 寄存器中的值是否为有效的 NaN 值，如果是，则使用 `f` 寄存器的最低 SEW 位，否则使用标准的 NaN 值。如果任何浮点向量操作数的 EEW 不是支持的浮点类型宽度（包括当 FLEN < SEW 时），则保留该指令。

NOTE: 某些指令对 5 位立即数进行零扩展，并在汇编语法中将此立即数称为 `uimm`。

NOTE: 当向 Zfinx/Zdinx/Zhinx 扩展中添加向量扩展时，浮点标量参数来自 `x` 寄存器。这些扩展不支持 NaN-装箱，因此，向量浮点标量值的生成规则与整数标量操作数相同（即当 XLEN > SEW 时，使用最低 SEW 位；当 XLEN < SEW 时，使用符号扩展的值）。

向量算术指令受 `vm` 字段的控制进行掩码操作。

----
 # 向量二元算术指令的汇编语法模式

 # 返回向量结果的操作，按 vm 掩码（v0.t，<无>）

vop.vv  vd, vs2, vs1, vm  # 整数向量-向量       vd[i] = vs2[i] op vs1[i]
vop.vx  vd, vs2, rs1, vm  # 整数向量-标量       vd[i] = vs2[i] op x[rs1]
vop.vi  vd, vs2, imm, vm  # 整数向量-立即数     vd[i] = vs2[i] op imm

vfop.vv  vd, vs2, vs1, vm # 浮点向量-向量操作   vd[i] = vs2[i] fop vs1[i]
vfop.vf  vd, vs2, rs1, vm # 浮点向量-标量操作   vd[i] = vs2[i] fop f[rs1]
----

NOTE: 在编码中，`vs2` 是第一个操作数，而 `rs1/imm` 是第二个操作数。这与标准的标量操作顺序相反。此排列保留了现有的编码约定：只读取一个标量寄存器的指令从 `rs1` 中读取它，5 位立即数来自 `rs1` 字段。

----
 # 向量三元算术指令的汇编语法模式（乘加）

 # 覆盖求和输入的整数操作
vop.vv vd, vs1, vs2, vm  # vd[i] = vs1[i] * vs2[i] + vd[i]
vop.vx vd, rs1, vs2, vm  # vd[i] = x[rs1] * vs2[i] + vd[i]

 # 覆盖乘积输入的整数操作
vop.vv vd, vs1, vs2, vm  # vd[i] = vs1[i] * vd[i] + vs2[i]
vop.vx vd, rs1, vs2, vm  # vd[i] = x[rs1] * vd[i] + vs2[i]

 # 覆盖求和输入的浮点操作
vfop.vv vd, vs1, vs2, vm  # vd[i] = vs1[i] * vs2[i] + vd[i]
vfop.vf vd, rs1, vs2, vm  # vd[i] = f[rs1] * vs2[i] + vd[i]

 # 覆盖乘积输入的浮点操作
vfop.vv vd, vs1, vs2, vm  # vd[i] = vs1[i] * vd[i] + vs2[i]
vfop.vf vd, rs1, vs2, vm  # vd[i] = f[rs1] * vd[i] + vs2[i]
----

NOTE: 对于三元乘加操作，汇编语法总是首先放置目标向量寄存器，其次是 `rs1` 或 `vs1`，最后是 `vs2`。这种顺序为这些三元操作提供了更自然的阅读方式，因为乘法操作数总是放在一起。

[[sec-widening]]
==== 扩宽向量算术指令

一些向量算术指令被定义为扩宽操作，其中目标向量寄存器组的 EEW = 2SEW 且 EMUL = 2LMUL。这些指令通常会在操作码前加上 `*vw` 前缀，或者对于向量浮点指令使用 `*vfw` 前缀。

第一个向量寄存器组操作数可以是单宽度或双宽度。

----
向量扩宽算术指令的汇编语法模式

 # 双宽度结果，两个单宽度源：2*SEW = SEW op SEW
vwop.vv  vd, vs2, vs1, vm  # 整数向量-向量      vd[i] = vs2[i] op vs1[i]
vwop.vx  vd, vs2, rs1, vm  # 整数向量-标量      vd[i] = vs2[i] op x[rs1]

 # 双宽度结果，第一个源为双宽度，第二个源为单宽度：2SEW = 2SEW op SEW
vwop.wv  vd, vs2, vs1, vm  # 整数向量-向量      vd[i] = vs2[i] op vs1[i]
vwop.wx  vd, vs2, rs1, vm  # 整数向量-标量      vd[i] = vs2[i] op x[rs1]
----

NOTE: 最初操作码上使用了 `w` 后缀，但由于它可能与在双字整数中表示字操作的 `w` 后缀混淆，因此将 `w` 移动到了前缀。

NOTE: 浮点扩宽操作已更改为 `vfw*`，而不是原来的 `vwf*`，以便与将来可能写成 `fw*` 的标量扩宽浮点操作保持一致。

扩宽指令的编码必须遵循 <<sec-vec-operands>> 的约束。

[[sec-narrowing]]
==== 缩窄向量算术指令

提供了一些指令，用于将双宽度源向量转换为单宽度目标向量。这些指令将由 `vs2` 指定的向量寄存器组（EEW/EMUL = 2SEW/2LMUL）
转换为具有当前 SEW/LMUL 设置的向量寄存器组。如果有第二个源向量寄存器组（由 `vs1` 指定），则它的宽度与结果相同（即 EEW = SEW）。

NOTE: 另一种设计选择是将 SEW/LMUL 视为定义源向量寄存器组大小的标准。这里选择的方法是基于认为这种方法会减少 `vtype` 更
改的需求。

NOTE: 设置掩码寄存器的比较操作也隐式地执行缩窄操作。

操作码上使用 `vn*` 前缀来区分这些指令，或者对于缩窄的浮点操作码，使用 `vfn*` 前缀。双宽度源向量寄存器组通过源操作数后缀中的 `w` 来表示（例如，vnsra.wv）。

----
向量缩窄算术指令的汇编语法模式

 # 单宽度结果，双宽度源 vs2，单宽度源 vs1/rs1
 # SEW = 2*SEW op SEW
vnop.wv  vd, vs2, vs1, vm  # 整数向量-向量      vd[i] = vs2[i] op vs1[i]
vnop.wx  vd, vs2, rs1, vm  # 整数向量-标量      vd[i] = vs2[i] op x[rs1]
----

缩窄指令的编码必须遵循 <<sec-vec-operands>> 的约束。


[[sec-vector-integer]]
=== 向量整数算术指令

提供了一组向量整数算术指令。除非另有说明，整数操作在溢出时会回绕。

==== 向量单宽度整数加法与减法

提供了向量整数加法和减法指令。对于向量-标量形式，也提供了反向减法指令。

----
 # 整数加法
vadd.vv vd, vs2, vs1, vm   # 向量-向量
vadd.vx vd, vs2, rs1, vm   # 向量-标量
vadd.vi vd, vs2, imm, vm   # 向量-立即数

 # 整数减法
vsub.vv vd, vs2, vs1, vm   # 向量-向量
vsub.vx vd, vs2, rs1, vm   # 向量-标量

 # 整数反向减法
vrsub.vx vd, vs2, rs1, vm   # vd[i] = x[rs1] - vs2[i]
vrsub.vi vd, vs2, imm, vm   # vd[i] = imm - vs2[i]
----

NOTE: 可以使用反向减法指令与标量操作数 `x0` 来对整数值取反。提供了汇编伪指令 `vneg.v vd,vs` = `vrsub.vx vd,vs,x0`。

==== 向量扩宽整数加法/减法

扩宽加法/减法指令提供了有符号和无符号两种变体，具体取决于在形成双宽和之前，较窄的源操作数是否首先进行符号扩展或零扩展。

----
 # 无符号扩宽整数加法/减法，2*SEW = SEW +/- SEW
vwaddu.vv  vd, vs2, vs1, vm  # 向量-向量
vwaddu.vx  vd, vs2, rs1, vm  # 向量-标量
vwsubu.vv  vd, vs2, vs1, vm  # 向量-向量
vwsubu.vx  vd, vs2, rs1, vm  # 向量-标量

 # 有符号扩宽整数加法/减法，2*SEW = SEW +/- SEW
vwadd.vv  vd, vs2, vs1, vm  # 向量-向量
vwadd.vx  vd, vs2, rs1, vm  # 向量-标量
vwsub.vv  vd, vs2, vs1, vm  # 向量-向量
vwsub.vx  vd, vs2, rs1, vm  # 向量-标量

 # 无符号扩宽整数加法/减法，2SEW = 2SEW +/- SEW
vwaddu.wv  vd, vs2, vs1, vm  # 向量-向量
vwaddu.wx  vd, vs2, rs1, vm  # 向量-标量
vwsubu.wv  vd, vs2, vs1, vm  # 向量-向量
vwsubu.wx  vd, vs2, rs1, vm  # 向量-标量

 # 有符号扩宽整数加法/减法，2SEW = 2SEW +/- SEW
vwadd.wv  vd, vs2, vs1, vm  # 向量-向量
vwadd.wx  vd, vs2, rs1, vm  # 向量-标量
vwsub.wv  vd, vs2, vs1, vm  # 向量-向量
vwsub.wx  vd, vs2, rs1, vm  # 向量-标量
----

NOTE: 可以使用扩宽加法指令与标量操作数 x0 将整数值宽度加倍。提供了汇编伪指令 `vwcvt.x.x.v vd,vs,vm` = `vwadd.vx vd,vs,x0,vm` 和 `vwcvtu.x.x.v vd,vs,vm` = `vwaddu.vx vd,vs,x0,vm`。

==== 向量整数扩展

向量整数扩展指令通过零扩展或符号扩展源向量整数操作数（EEW 小于 SEW）以填充目标中大小为 SEW 的元素。源的 EEW 是 SEW 的 1/2、1/4 或 1/8，而源的 EMUL 为 (EEW/SEW)*LMUL。目标的 EEW 等于 SEW，EMUL 等于 LMUL。

----
vzext.vf2 vd, vs2, vm # 将 SEW/2 的源零扩展到 SEW 目标 
vsext.vf2 vd, vs2, vm # 将 SEW/2 的源符号扩展到 SEW 目标 
vzext.vf4 vd, vs2, vm # 将 SEW/4 的源零扩展到 SEW 目标 
vsext.vf4 vd, vs2, vm # 将 SEW/4 的源符号扩展到 SEW 目标 
vzext.vf8 vd, vs2, vm # 将 SEW/8 的源零扩展到 SEW 目标 
vsext.vf8 vd, vs2, vm # 将 SEW/8 的源符号扩展到 SEW 目标
----

如果源的 EEW 不支持，或者源的 EMUL 小于最小合法的 LMUL，则该指令编码被保留。

NOTE: 标准的向量加载指令访问的内存值与目标寄存器元素的大小相同。一些应用程序代码需要在更宽的元素范围内操作操作数的宽度，例如，从内存加载一个字节并加到一个八字节元素上。为了避免提供跨向量加载指令与数据类型（字节、字、半字，及其有符号/无符号变种）数量的交叉积，我们改为添加了显式的扩展指令，如果没有可用的适当扩展算术指令，则可以使用这些指令。

==== 向量整数加法带进位 / 减法带借位指令

为了支持多字整数算术，提供了处理进位的指令。对于每个操作（加法或减法），提供了两条指令：一条提供结果（SEW 宽度），另一条生成进位输出（单个位，编码为掩码布尔值）。

进位输入和输出通过掩码寄存器布局表示，如 <<sec-mask-register-layout>> 所述。由于编码约束，进位输入必须来自隐式的 `v0` 寄存器，但进位输出可以写入任何遵守源/目标重叠限制的向量寄存器。

`vadc` 和 `vsbc` 分别将源操作数和进位输入或借位输入相加或相减，并将结果写入向量寄存器 `vd`。这些指令被编码为掩码指令（`vm=0`），但它们作用于并写回所有主体元素。对应未掩码版本的编码（`vm=1`）被保留。

`vmadc` 和 `vmsbc` 分别将源操作数相加或相减，若掩码（`vm=0`），还可选择加上进位输入或减去借位输入，并将结果写回掩码寄存器 `vd`。如果未掩码（`vm=1`），则没有进位输入或借位输入。这些指令作用于并写回所有体元素，即使被掩码。因为这些指令产生一个掩码值，所以它们总是采用与尾部无关的策略。

----
 # 计算带进位的和

 # vd[i] = vs2[i] + vs1[i] + v0.mask[i]
 vadc.vvm   vd, vs2, vs1, v0  # 向量-向量

 # vd[i] = vs2[i] + x[rs1] + v0.mask[i]
 vadc.vxm   vd, vs2, rs1, v0  # 向量-标量

 # vd[i] = vs2[i] + imm + v0.mask[i]
 vadc.vim   vd, vs2, imm, v0  # 向量-立即数

 # 计算掩码寄存器格式的进位输出

 # vd.mask[i] = carry_out(vs2[i] + vs1[i] + v0.mask[i])
 vmadc.vvm   vd, vs2, vs1, v0  # 向量-向量

 # vd.mask[i] = carry_out(vs2[i] + x[rs1] + v0.mask[i])
 vmadc.vxm   vd, vs2, rs1, v0  # 向量-标量

 # vd.mask[i] = carry_out(vs2[i] + imm + v0.mask[i])
 vmadc.vim   vd, vs2, imm, v0  # 向量-立即数

 # vd.mask[i] = carry_out(vs2[i] + vs1[i])
 vmadc.vv    vd, vs2, vs1      # 向量-向量, 无进位输入

 # vd.mask[i] = carry_out(vs2[i] + x[rs1])
 vmadc.vx    vd, vs2, rs1      # 向量-标量, 无进位输入


 # vd.mask[i] = carry_out(vs2[i] + imm)
 vmadc.vi    vd, vs2, imm      # 向量-立即数, 无进位输入
----

因为实现进位传播需要执行两条指令且输入不变，所以破坏性累加将需要额外的移动操作才能获得正确的结果。

----
  # 示例：多字算术序列，将结果累加到 v4
  vmadc.vvm v1, v4, v8, v0  # 将进位保存到临时寄存器 v1 
  vadc.vvm v4, v4, v8, v0   # 计算新的和 
  vmmv.m v0, v1             # 将临时进位移入 v0，为下一个字准备
----

减法带借位指令 `vsbc` 执行等效操作，以支持长字减法算术。没有带立即数的减法指令。

----
  # 计算带借位的差值。

  # vd[i] = vs2[i] - vs1[i] - v0.mask[i]
 vsbc.vvm   vd, vs2, vs1, v0  # 向量-向量

  # vd[i] = vs2[i] - x[rs1] - v0.mask[i]
 vsbc.vxm   vd, vs2, rs1, v0  # 向量-标量

  # Produce borrow out in mask register format

  # vd.mask[i] = borrow_out(vs2[i] - vs1[i] - v0.mask[i])
 vmsbc.vvm   vd, vs2, vs1, v0  # 向量-向量

  # vd.mask[i] = borrow_out(vs2[i] - x[rs1] - v0.mask[i])
 vmsbc.vxm   vd, vs2, rs1, v0  # 向量-标量

  # vd.mask[i] = borrow_out(vs2[i] - vs1[i])
 vmsbc.vv    vd, vs2, vs1      # 向量-向量, 无借位

  # vd.mask[i] = borrow_out(vs2[i] - x[rs1])
 vmsbc.vx    vd, vs2, rs1      # 向量-标量, 无借位
----

对于 `vmsbc`，当差值（截断前）为负时，借位被定义为 1。

对于 `vadc` 和 `vsbc`，如果目标向量寄存器是 `v0`，则指令编码被保留。

NOTE: 此约束与掩码向量操作的约束相对应，掩码寄存器被重写。

==== 向量按位逻辑操作指令

----
 # 按位逻辑操作
vand.vv vd, vs2, vs1, vm # 向量-向量 
vand.vx vd, vs2, rs1, vm # 向量-标量 
vand.vi vd, vs2, imm, vm # 向量-立即数

vor.vv vd, vs2, vs1, vm  # 向量-向量 
vor.vx vd, vs2, rs1, vm  # 向量-标量 
vor.vi vd, vs2, imm, vm  # 向量-立即数

vxor.vv vd, vs2, vs1, vm # 向量-向量 
vxor.vx vd, vs2, rs1, vm # 向量-标量 
vxor.vi vd, vs2, imm, vm # 向量-立即数
----

NOTE: 当立即数为 -1 时，`vxor` 指令的标量立即数形式提供按位取反操作。可以使用汇编伪指令 `vnot.v vd,vs,vm` 来表示，即 `vxor.vi vd,vs,-1,vm`。

==== 向量单宽度移位指令

提供了一整套向量移位指令，包括逻辑左移（`sll`），逻辑右移（零扩展 `srl`）和算术右移（符号位扩展 `sra`）。需要移位的数据在由 `vs2` 指定的向量寄存器组中，移位量可以来自向量寄存器组 `vs1`、标量整数寄存器 `rs1`，或零扩展的 5 位立即数。只有移位量的低 lg2(SEW) 位用于控制移位量。

----
 # 按位移位操作
vsll.vv vd, vs2, vs1, vm # 向量-向量 
vsll.vx vd, vs2, rs1, vm # 向量-标量 
vsll.vi vd, vs2, uimm, vm # 向量-立即数

vsrl.vv vd, vs2, vs1, vm # 向量-向量 
vsrl.vx vd, vs2, rs1, vm # 向量-标量 
vsrl.vi vd, vs2, uimm, vm # 向量-立即数

vsra.vv vd, vs2, vs1, vm # 向量-向量 
vsra.vx vd, vs2, rs1, vm # 向量-标量 
vsra.vi vd, vs2, uimm, vm # 向量-立即数
----

==== 向量缩小整数右移指令

缩小右移操作从宽操作数中提取较小的字段，并具有零扩展（`srl`）和符号扩展（`sra`）形式。移位量可以来自向量寄存器组、标量 `x` 寄存器，或零扩展的 5 位立即数。移位量的低 lg2(2*SEW) 位用于控制移位量（例如，对于 SEW=64 位到 SEW=32 位的缩小操作，使用低 6 位）。

----
 # 缩小右移逻辑操作，SEW = (2*SEW) >> SEW
vnsrl.wv vd, vs2, vs1, vm # 向量-向量 
vnsrl.wx vd, vs2, rs1, vm # 向量-标量 
vnsrl.wi vd, vs2, uimm, vm # 向量-立即数

 # 缩小右移算术操作，SEW = (2*SEW) >> SEW
vnsra.wv vd, vs2, vs1, vm # 向量-向量 
vnsra.wx vd, vs2, rs1, vm # 向量-标量 
vnsra.wi vd, vs2, uimm, vm # 向量-立即数
----

NOTE: 未来扩展可能会添加支持将目标缩小到源的 1/4 宽度的版本。

NOTE: 可以使用带标量操作数 x0 的缩小整数移位指令将整数值宽度减半。提供了一个汇编伪指令 `vncvt.x.x.w vd,vs,vm`，等同于 `vnsrl.wx vd,vs,x0,vm`。

==== 向量整数比较指令

以下整数比较指令会在比较为真时将 1 写入目标掩码寄存器元素，否则写入 0。目标掩码向量总是保存在单个向量寄存器中，元素布局如 <<sec-mask-register-layout>> 所述。目标掩码向量寄存器可以与源向量掩码寄存器（`v0`）相同。

----
 # 相等时置 1
vmseq.vv vd, vs2, vs1, vm # 向量-向量 
vmseq.vx vd, vs2, rs1, vm # 向量-标量 
vmseq.vi vd, vs2, imm, vm # 向量-立即数

 # 不相等时置 1
vmsne.vv vd, vs2, vs1, vm # 向量-向量 
vmsne.vx vd, vs2, rs1, vm # 向量-标量 
vmsne.vi vd, vs2, imm, vm # 向量-立即数

 # 小于时置 1，无符号
vmsltu.vv vd, vs2, vs1, vm # 向量-向量 
vmsltu.vx vd, vs2, rs1, vm # 向量-标量

 # 小于时置 1，有符号
vmslt.vv vd, vs2, vs1, vm # 向量-向量 
vmslt.vx vd, vs2, rs1, vm # 向量-标量

 # 小于或等于时置 1，无符号
vmsleu.vv vd, vs2, vs1, vm # 向量-向量 
vmsleu.vx vd, vs2, rs1, vm # 向量-标量 
vmsleu.vi vd, vs2, imm, vm # 向量-立即数

 # 小于或等于时置 1，有符号
vmsle.vv vd, vs2, vs1, vm # 向量-向量 
vmsle.vx vd, vs2, rs1, vm # 向量-标量 
vmsle.vi vd, vs2, imm, vm # 向量-立即数

 # 大于时置 1，无符号
vmsgtu.vx vd, vs2, rs1, vm # 向量-标量 
vmsgtu.vi vd, vs2, imm, vm # 向量-立即数

 # 大于时置 1，有符号
vmsgt.vx vd, vs2, rs1, vm # 向量-标量 
vmsgt.vi vd, vs2, imm, vm # 向量-立即数

 # 以下两条指令不直接提供
 # 大于或等于时置 1，无符号
 # vmsgeu.vx vd, vs2, rs1, vm # 向量-标量
 # 大于或等于时置 1，有符号
 # vmsge.vx vd, vs2, rs1, vm # 向量-标量
----

以下表格展示了所有比较在本机机器代码中的实现方式。

----
比较             汇编映射                      汇编伪指令
va < vb         vmslt{u}.vv vd, va, vb, vm
va <= vb        vmsle{u}.vv vd, va, vb, vm
va > vb         vmslt{u}.vv vd, vb, va, vm    vmsgt{u}.vv vd, va, vb, vm
va >= vb        vmsle{u}.vv vd, vb, va, vm    vmsge{u}.vv vd, va, vb, vm

va < x          vmslt{u}.vx vd, va, x, vm
va <= x         vmsle{u}.vx vd, va, x, vm
va > x          vmsgt{u}.vx vd, va, x, vm
va >= x         see below

va < i          vmsle{u}.vi vd, va, i-1, vm    vmslt{u}.vi vd, va, i, vm
va <= i         vmsle{u}.vi vd, va, i, vm
va > i          vmsgt{u}.vi vd, va, i, vm
va >= i         vmsgt{u}.vi vd, va, i-1, vm    vmsge{u}.vi vd, va, i, vm

va, vb 向量寄存器组
x      标量整数寄存器
i      立即数
----

NOTE: vmslt{u}.vi 的立即数形式未提供，因为立即数可以减去 1，改用 `vmsle{u}.vi` 变体。`vmsle.vi` 的范围是 -16 到 15，因此有效的`vmslt.vi` 范围是 -15 到 16。`vmsleu.vi` 的范围是 0 到 15，给出了有效的 `vmsltu.vi` 范围是 1 到 16（注意，`vmsltu.vi` 的立即数为 0 时没有用处，因为它总是为假）。

NOTE: 由于 5 位向量立即数总是符号位扩展的，当 `simm5` 立即数的高位被设置时，`vmsleu.vi` 也支持无符号立即数值，范围是 `2^SEW^-16` 到 `2^SEW^-1`，因此相应的 `vmsltu.vi` 可以与范围 `2^SEW^-15` 到 `2^SEW^` 的无符号立即数进行比较。注意，`vmsltu.vi` 使用立即数 `2^SEW^` 是没有意义的，因为它总是为真。

类似地，`vmsge{u}.vi` 页没有被提供，这一比较通过使用 `vmsgt{u}.vi` 并将立即数减去 1 来实现。结果有效的 `vmsge.vi` 范围是 -15 到 16，结果有效的 `vmsgeu.vi` 范围是 1 到 16（注意，`vmsgeu.vi` 的立即数为 0 时没有用处，因为它总是为真）。

NOTE: 提供了寄存器标量和立即数形式的 `vmsgt`，允许通过单个比较指令提供正确的掩码值极性，而无需使用额外的掩码逻辑指令。

为了减少编码空间，`vmsge{u}.vx` 形式未直接提供，因此 `va {ge} x` 情况需要特殊处理。

NOTE: `vmsge{u}.vx` 可能会通过在未使用的 OPIVI 变体下，使用 `vmslt{u}` 以非正交的方式进行编码。这些将是 OPIVI 中唯一使用标量 `x` 寄存器的指令。另一种方法是使用额外的两个 funct6 编码，但它们的操作数格式（写入掩码寄存器）与同一组 8 个 funct6 编码中的其他指令不同。目前的 PoR 是省略这些指令，并根据需要进行合成，如下所述。

`vmsge{u}.vx` 操作可以通过将 `x` 的值减去 1 并使用 `vmsgt{u}.vx` 指令来合成，当已知这不会导致 `x` 中的表示下溢时。

----
合成 `vmsge{u}.vx` 指令的序列：

va >= x,  x > minimum

   addi t0, x, -1; vmsgt{u}.vx vd, va, t0, vm
----

上述序列通常是最有效的实现，但在 `x` 的范围未知的情况下，可以提供汇编伪指令。

----
未掩码 va >= x

    伪指令：vmsge{u}.vx vd, va, x 
    展开：vmslt{u}.vx vd, va, x; vmnand.mm vd, vd, vd

掩码 va >= x, vd != v0

    伪指令：vmsge{u}.vx vd, va, x, v0.t 
    展开：vmslt{u}.vx vd, va, x, v0.t; vmxor.mm vd, vd, v0

掩码 va >= x, vd == v0

    伪指令：vmsge{u}.vx vd, va, x, v0.t, vt 
    展开：vmslt{u}.vx vt, va, x; vmandn.mm vd, vd, vt

掩码 va >= x, 任意 vd

    伪指令：vmsge{u}.vx vd, va, x, v0.t, vt 
    展开：vmslt{u}.vx vt, va, x; vmandn.mm vt, v0, vt; vmandn.mm vd, vd, v0; vmor.mm vd, vt, vd

伪指令中的 vt 参数必须命名为一个临时向量寄存器，该寄存器不同于 vd，并且会被伪指令破坏。
----

在掩码未干扰的策略下，比较实际上是与掩码进行按位与操作，如果目标寄存器是 v0，例如：

----
    # (a < b) && (b < c) 在两条指令中进行，当掩码未干扰时
    vmslt.vv    v0, va, vb        # 所有元素写入
    vmslt.vv    v0, vb, vc, v0.t  # 仅在设置掩码时更新
----

比较写入掩码寄存器，因此始终在尾部无关的策略下操作。

==== 向量整数最小值/最大值指令

支持有符号和无符号整数的最小值和最大值指令。

----
 # 无符号最小值
vminu.vv vd, vs2, vs1, vm # 向量-向量 
vminu.vx vd, vs2, rs1, vm # 向量-标量

 # 有符号最小值
vmin.vv vd, vs2, vs1, vm # 向量-向量 
vmin.vx vd, vs2, rs1, vm # 向量-标量

 # 无符号最大值
vmaxu.vv vd, vs2, vs1, vm # 向量-向量 
vmaxu.vx vd, vs2, rs1, vm # 向量-标量

 # 有符号最大值
vmax.vv vd, vs2, vs1, vm # 向量-向量
vmax.vx vd, vs2, rs1, vm # 向量-标量
----

====  向量单宽度整数乘法指令

单宽度乘法指令执行 SEW 位 * SEW 位的乘法，生成一个 2*SEW 位的结果，然后将乘积的一个部分返回到 SEW 位宽的目标寄存器。`*mul*` 版本将乘积的低字写入目标寄存器，而 `*mulh*` 版本将乘积的高字写入目标寄存器。

----
 # 有符号乘法，返回乘积的低位
vmul.vv vd, vs2, vs1, vm # 向量-向量 
vmul.vx vd, vs2, rs1, vm # 向量-标量

 # 有符号乘法，返回乘积的高位
vmulh.vv vd, vs2, vs1, vm # 向量-向量 
vmulh.vx vd, vs2, rs1, vm # 向量-标量

 # 无符号乘法，返回乘积的高位
vmulhu.vv vd, vs2, vs1, vm # 向量-向量 
vmulhu.vx vd, vs2, rs1, vm # 向量-标量

 # 有符号（vs2）- 无符号乘法，返回乘积的高位
vmulhsu.vv vd, vs2, vs1, vm # 向量-向量 
vmulhsu.vx vd, vs2, rs1, vm # 向量-标量
----

NOTE: 没有 `vmulhus.vx` 操作码返回无符号向量 * 有符号标量乘积的高半部分。标量可以扩展为向量，然后使用 `vmulhsu.vv`。

NOTE: 当前的 `vmulh*` 操作码执行简单的分数乘法，但没有选项来缩放、舍入和/或饱和结果。未来的扩展可能会考虑 `vmulh`、`vmulhu`、`vmulhsu` 的变体，在丢弃乘积的低半部分时使用 `vxrm` 舍入模式。在这些情况下，不会发生溢出。

==== 向量整数除法指令

除法和余数指令与 RISC-V 标准标量整数乘法/除法等效，对于极端输入产生相同的结果。

----
    # 无符号除法
    vdivu.vv vd, vs2, vs1, vm   # 向量-向量
    vdivu.vx vd, vs2, rs1, vm   # 向量-标量

    # 有符号除法
    vdiv.vv vd, vs2, vs1, vm   # 向量-向量
    vdiv.vx vd, vs2, rs1, vm   # 向量-标量

    # 无符号余数
    vremu.vv vd, vs2, vs1, vm   # 向量-向量
    vremu.vx vd, vs2, rs1, vm   # 向量-标量

    # 有符号余数
    vrem.vv vd, vs2, vs1, vm   # 向量-向量
    vrem.vx vd, vs2, rs1, vm   # 向量-标量
----

NOTE: 是否包含整数除法和余数指令存在争议。支持这一观点的理由是，如果没有标准指令，软件将不得不选择某些算法来执行该操作，这可能在某些微架构上表现较差。

NOTE: 没有执行“标量除法对向量”操作的指令。

==== 向量宽整数乘法指令

宽整数乘法指令返回一个 SEW 位 * SEW 位乘法的完整 2*SEW 位乘积。

----
 # 宽度有符号整数乘法
vwmul.vv vd, vs2, vs1, vm # 向量-向量 
vwmul.vx vd, vs2, rs1, vm # 向量-标量

 # 宽度无符号整数乘法
vwmulu.vv vd, vs2, vs1, vm # 向量-向量 
vwmulu.vx vd, vs2, rs1, vm # 向量-标量

 # 宽度有符号(vs2)-无符号整数乘法
vwmulsu.vv vd, vs2, vs1, vm # 向量-向量 
vwmulsu.vx vd, vs2, rs1, vm # 向量-标量
----

==== 向量单宽度整数乘加指令

整数乘加指令是破坏性的，提供了两种形式，一种覆盖加数或减数（vmacc，vnmsac），另一种覆盖第一个乘数（vmadd，vnmsub）。

乘积的低半部分会被加到或减去第三个操作数。

NOTE: sac 应理解为“从累加器中减去”。操作码是 vnmsac，以匹配（不幸的是直觉上相反的）浮点 fnmsub 指令定义。vnmsub 操作码
同样如此。

----
 # 整数乘加，覆盖加数
vmacc.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) + vd[i] 
vmacc.vx vd, rs1, vs2, vm # vd[i] = +(x[rs1] * vs2[i]) + vd[i]

 # 整数乘减，覆盖减数
vnmsac.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i]) + vd[i] 
vnmsac.vx vd, rs1, vs2, vm # vd[i] = -(x[rs1] * vs2[i]) + vd[i]

 # 整数乘加，覆盖乘数
vmadd.vv vd, vs1, vs2, vm # vd[i] = (vs1[i] * vd[i]) + vs2[i] 
vmadd.vx vd, rs1, vs2, vm # vd[i] = (x[rs1] * vd[i]) + vs2[i]

 # 整数乘减，覆盖乘数
vnmsub.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vd[i]) + vs2[i] 
vnmsub.vx vd, rs1, vs2, vm # vd[i] = -(x[rs1] * vd[i]) + vs2[i]
----

==== 向量宽整数乘加指令

宽整数乘加指令将 SEW 位 * SEW 位乘法的完整 2*SEW 位乘积加到 2*SEW 位值上，产生 2*SEW 位的结果。支持所有有符号和无符号乘法操作数的组合。

----
 # 拓宽无符号整数乘加，覆盖加数
vwmaccu.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) + vd[i] 
vwmaccu.vx vd, rs1, vs2, vm # vd[i] = +(x[rs1] * vs2[i]) + vd[i]

 # 拓宽有符号整数乘加，覆盖加数
vwmacc.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) + vd[i] 
vwmacc.vx vd, rs1, vs2, vm # vd[i] = +(x[rs1] * vs2[i]) + vd[i]

 # 拓宽有符号-无符号整数乘加，覆盖加数
vwmaccsu.vv vd, vs1, vs2, vm # vd[i] = +(signed(vs1[i]) * unsigned(vs2[i])) + vd[i] 
vwmaccsu.vx vd, rs1, vs2, vm # vd[i] = +(signed(x[rs1]) * unsigned(vs2[i])) + vd[i]

 # 拓宽无符号-有符号整数乘加，覆盖加数
vwmaccus.vx vd, rs1, vs2, vm # vd[i] = +(unsigned(x[rs1]) * signed(vs2[i])) + vd[i]
----

====  向量整数合并指令

向量整数合并指令根据掩码将两个源操作数组合。与常规算术指令不同，合并操作作用于所有元素（即从 `vstart` 到当前向量长度 `vl` 之间的元素集合）。

`vmerge` 指令被编码为掩码指令（vm=0）。指令按以下方式合并两个源操作数：在掩码值为零的元素处，第一个操作数被复制到目标元素，否则第二个操作数被复制到目标元素。第一个操作数始终是由 `vs2` 指定的向量寄存器组。第二个操作数是由 `vs1` 指定的向量寄存器组、由 `rs1` 指定的标量 `x` 寄存器，或一个 5 位符号扩展的立即数。

----
vmerge.vvm vd, vs2, vs1, v0 # vd[i] = v0.mask[i] ? vs1[i] : vs2[i] 
vmerge.vxm vd, vs2, rs1, v0 # vd[i] = v0.mask[i] ? x[rs1] : vs2[i] 
vmerge.vim vd, vs2, imm, v0 # vd[i] = v0.mask[i] ? imm : vs2[i]
----

==== 向量整数移动指令

向量整数移动指令将源操作数复制到向量寄存器组中。`vmv.v.v` 变体复制一个向量寄存器组，而 `vmv.v.x` 和 `vmv.v.i` 变体将标量寄存器或立即数扩展到目标向量寄存器组的所有激活元素中。这些指令被编码为未掩码指令（`vm=1`）。第一个操作数说明符（`vs2`）必须包含 `v0`，并且 `vs2` 中的任何其他向量寄存器编号都是保留的。

----
vmv.v.v vd, vs1 # vd[i] = vs1[i]
vmv.v.x vd, rs1 # vd[i] = x[rs1]
vmv.v.i vd, imm # vd[i] = imm
----

NOTE: 掩码值可以通过序列 `vmv.v.i vd, 0; vmerge.vim vd, vd, 1, v0` 扩展为 SEW 宽度的元素。

NOTE: 向量整数移动指令与向量合并指令共享编码，但 `vm=1` 且 `vs2=v0`。

形式 `vmv.v.v vd, vd`，它保持主体元素不变，可以用来表示该寄存器接下来将以与 SEW 相等的 EEW 一起使用。

NOTE: 实现内部按 EEW 重组数据的，可以根据 SEW 重新排列内部表示。对于不进行数据内部重组的实现，可以动态省略此指令，将其视为 NOP。

NOTE: `vmv.v.v vd, vd` 指令不是 RISC-V 提示（HINT），因为尾部无关的设置可能会在某些实现中引起架构状态变化。

[[sec-vector-fixed-point]]
=== 向量定点算术指令

之前的整数算术指令集已扩展以支持定点算术。

定点数是一个二进制补码的有符号或无符号整数，解释为一个分数的分子，且分母隐含。定点指令旨在应用于分子；分母的管理由软件负责。一个 N 位元素可以存储二进制补码的有符号整数，范围为 -2^(N-1) 到 +2^(N-1)-1，以及无符号整数，范围为 0 到 +2^N-1。定点指令通过支持缩放和舍入来帮助保持窄操作数的精度，并通过将溢出结果饱和到目标格式范围来处理溢出。

NOTE: 上述描述的拓宽整数操作也可以用来避免溢出。

==== 向量单宽度饱和加法与减法

提供了有符号和无符号整数的饱和加法和饱和减法形式。如果结果会溢出目标范围，结果将被替换为最接近的可表示值，并且 vxsat 位会被设置。

----
 # 无符号整数的饱和加法
vsaddu.vv vd, vs2, vs1, vm # 向量-向量
vsaddu.vx vd, vs2, rs1, vm # 向量-标量
vsaddu.vi vd, vs2, imm, vm # 向量-立即数

 # 有符号整数的饱和加法
vsadd.vv vd, vs2, vs1, vm # 向量-向量
vsadd.vx vd, vs2, rs1, vm # 向量-标量
vsadd.vi vd, vs2, imm, vm # 向量-立即数

 # 无符号整数的饱和减法
vssubu.vv vd, vs2, vs1, vm # 向量-向量
vssubu.vx vd, vs2, rs1, vm # 向量-标量

 # 有符号整数的饱和减法
vssub.vv vd, vs2, vs1, vm # 向量-向量
vssub.vx vd, vs2, rs1, vm # 向量-标量
----

==== 向量单宽度平均加法与减法

平均加法与减法指令会将结果右移一个比特，并根据 `vxrm` 中的设置对结果进行舍入。提供了有符号和无符号版本。对于 `vaaddu` 和 `vaadd`，结果中不会发生溢出。对于 `vasub` 和 `vasubu`，溢出会被忽略，结果会发生环绕。

NOTE: 对于 `vasub`，只有在使用 `rnu` 或 `rne` 舍入模式时，从最小数减去最大数才会发生溢出。

----
 # 平均加法

 # 无符号整数的平均加法
vaaddu.vv vd, vs2, vs1, vm   # roundoff_unsigned(vs2[i] + vs1[i], 1)
vaaddu.vx vd, vs2, rs1, vm   # roundoff_unsigned(vs2[i] + x[rs1], 1)

 # 有符号整数的平均加法
vaadd.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] + vs1[i], 1)
vaadd.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] + x[rs1], 1)

 # 平均减法

 # 无符号整数的平均减法
vasubu.vv vd, vs2, vs1, vm   # roundoff_unsigned(vs2[i] - vs1[i], 1)
vasubu.vx vd, vs2, rs1, vm   # roundoff_unsigned(vs2[i] - x[rs1], 1)

 # 有符号整数的平均减法
vasub.vv vd, vs2, vs1, vm   # roundoff_signed(vs2[i] - vs1[i], 1)
vasub.vx vd, vs2, rs1, vm   # roundoff_signed(vs2[i] - x[rs1], 1)
----

==== 向量单宽度带舍入与饱和的分数乘法

有符号分数乘法指令将两个 SEW 位输入的乘积扩展为 2*SEW 位，然后将结果右移 SEW-1 位，根据 `vxrm` 舍入这些位，最后将结果饱和到 SEW 位。如果结果发生饱和，`vxsat` 位会被设置。

----
 # 有符号饱和并舍入的分数乘法
 # 请参见 vxrm 描述，了解舍入计算
vsmul.vv vd, vs2, vs1, vm # vd[i] = clip(roundoff_signed(vs2[i]*vs1[i], SEW-1))
vsmul.vx vd, vs2, rs1, vm # vd[i] = clip(roundoff_signed(vs2[i]*x[rs1], SEW-1))
----

NOTE: 当乘以两个 N 位有符号数时，最大幅度是通过 -2^(N-1) * -2^(N-1) 得到的，结果为 +2^(2N-2)，该结果在 2N 位中有一个（零）符号位。所有其他乘积在 2N 位中将有两个符号位。为了保持 N 位结果的更高精度，乘积将右移一个比 N 少的位数，从而饱和最大的幅度结果，但对于所有其他乘积增加一个结果精度位。

NOTE: 我们不提供等效的分数乘法，其中一个输入是无符号的，因为这些操作会保留所有上位 SEW 位，并且无需饱和。此操作部分由 `vmulhu` 和 `vmulhsu` 指令覆盖，适用于舍入仅为截断（`rdn`）的情况。

==== 向量单宽度缩放移位指令

这些指令将输入值右移，并根据 `vxrm` 对移出的比特进行舍入。缩放右移有两种形式：零扩展（`vssrl`）和符号扩展（`vssra`）。需要移位的数据在由 `vs2` 指定的向量寄存器组中，移位量的值可以来自向量寄存器组 `vs1`、标量整数寄存器 `rs1` 或零扩展的 5 位立即数。移位量值的低 lg2(SEW) 位用于控制移位量。

----
 # 缩放右移（逻辑）
vssrl.vv vd, vs2, vs1, vm # vd[i] = roundoff_unsigned(vs2[i], vs1[i])
vssrl.vx vd, vs2, rs1, vm # vd[i] = roundoff_unsigned(vs2[i], x[rs1])
vssrl.vi vd, vs2, uimm, vm # vd[i] = roundoff_unsigned(vs2[i], uimm)

 # 缩放右移（算术）
vssra.vv vd, vs2, vs1, vm # vd[i] = roundoff_signed(vs2[i],vs1[i])
vssra.vx vd, vs2, rs1, vm # vd[i] = roundoff_signed(vs2[i], x[rs1])
vssra.vi vd, vs2, uimm, vm # vd[i] = roundoff_signed(vs2[i], uimm)
----

==== 向量定点裁剪指令（缩小位宽）

`vnclip` 指令用于将定点值打包到较窄的目标格式中。该指令支持舍入、缩放和饱和到最终目标格式。源数据位于由 `vs2` 指定的向量寄存器组中。缩放移位量的值可以来自向量寄存器组 `vs1`、标量整数寄存器 `rs1` 或零扩展的 5 位立即数。向量或标量移位量值的低 lg2(2*SEW) 位（例如，SEW=64 位到 SEW=32 位缩小操作时的低 6 位）用于控制右移量，从而提供缩放。

----
 # 无符号裁剪
 #                                SEW                           2*SEW    SEW
 vnclipu.wv vd, vs2, vs1, vm  # vd[i] = clip(roundoff_unsigned(vs2[i], vs1[i]))
 vnclipu.wx vd, vs2, rs1, vm  # vd[i] = clip(roundoff_unsigned(vs2[i], x[rs1]))
 vnclipu.wi vd, vs2, uimm, vm # vd[i] = clip(roundoff_unsigned(vs2[i], uimm))

 # 有符号裁剪
 vnclip.wv vd, vs2, vs1, vm  # vd[i] = clip(roundoff_signed(vs2[i], vs1[i]))
 vnclip.wx vd, vs2, rs1, vm  # vd[i] = clip(roundoff_signed(vs2[i], x[rs1]))
 vnclip.wi vd, vs2, uimm, vm # vd[i] = clip(roundoff_signed(vs2[i], uimm))
----

对于 `vnclipu` 和 `vnclip`，舍入模式在 `vxrm` 控制状态寄存器中指定。舍入发生在目标的最低有效位之前，并且发生在饱和之前。

对于 `vnclipu`，移位后舍入的源值被视为无符号整数，如果结果溢出目标（被视为无符号整数），则结果会饱和。

NOTE: 没有单一指令可以将有符号值饱和到无符号目标。如果不需要为负数设置 `vxsat` 值，可以使用两个向量指令的序列：首先使用 `vmax` 与 0 执行最大值操作移除负数，然后使用 `vnclipu` 将结果无符号值裁剪到目标。要在这两条指令之间改变 SEW，需要使用 `vsetvli`。

对于 `vnclip`，移位后舍入的源值被视为有符号整数，如果结果溢出目标（被视为有符号整数），则结果会饱和。

如果任何目标元素发生饱和，`vxsat` 位会在 `vxsat` 寄存器中设置。

[[sec-vector-float]]
=== 向量浮点指令

标准的向量浮点指令将元素视为符合 IEEE-754/2008 标准的值。如果向量浮点操作数的 EEW 与支持的 IEEE 浮点类型不匹配，则该指令编码是保留的。

NOTE: 浮点是否支持，以及支持哪些元素宽度，取决于具体的向量扩展。目前的扩展集包括对 32 位和 64 位浮点值的支持。当支持 16 位和 128 位元素宽度时，它们也将被视为符合 IEEE-754/2008 标准的值。未来的扩展可能会支持其他浮点格式。

向量浮点指令要求具有与支持的向量浮点元素宽度相对应的基础标量浮点扩展。

NOTE: 特别是，未来支持 16 位半精度浮点值的向量扩展，也将要求一些标量半精度浮点支持。

如果浮点单元状态字段 `mstatus.FS` 为 `Off`，则任何尝试执行向量浮点指令的操作将引发非法指令异常。任何修改浮点扩展状态（即浮点控制状态寄存器或 f 寄存器）的向量浮点指令必须将 `mstatus.FS` 设置为 `Dirty`。

如果实现了虚拟化扩展且 V=1，则 `vsstatus.FS` 字段对于向量浮点指令也会生效。如果 `vsstatus.FS` 或 `mstatus.FS` 为 `Off`，则任何尝试执行向量浮点指令的操作将引发非法指令异常。任何修改浮点扩展状态（即浮点 CSR 或 f 寄存器）的向量浮点指令必须将 `mstatus.FS` 和 `vsstatus.FS` 都设置为 Dirty。

向量浮点指令在 NaN 处理方面与标量浮点指令具有相同的行为。

浮点向量-标量操作的标量值来源于 <<sec-arithmetic-encoding>>所述的方式。

==== 向量浮点异常标志

任何激活浮点元素上的向量浮点异常会在 `fflags` 寄存器中设置标准的浮点异常标志。未激活元素不会设置浮点异常标志。

==== 向量单宽度浮点加法/减法指令

----
    # 浮点加法
    vfadd.vv vd, vs2, vs1, vm   # 向量-向量  
    vfadd.vf vd, vs2, rs1, vm   # 向量-标量  

    # 浮点减法
    vfsub.vv vd, vs2, vs1, vm   # 向量-向量  
    vfsub.vf vd, vs2, rs1, vm   # 向量-标量 vd[i] = vs2[i] - f[rs1]  
    vfrsub.vf vd, vs2, rs1, vm  # 标量-向量 vd[i] = f[rs1] - vs2[i]  
----

==== 向量宽度浮点加法/减法指令

----
 # 宽度浮点加法/减法，2*SEW = SEW +/- SEW
vfwadd.vv vd, vs2, vs1, vm # 向量-向量
vfwadd.vf vd, vs2, rs1, vm # 向量-标量
vfwsub.vv vd, vs2, vs1, vm # 向量-向量
vfwsub.vf vd, vs2, rs1, vm # 向量-标量

 # 宽度浮点加法/减法，2SEW = 2SEW +/- SEW
vfwadd.wv vd, vs2, vs1, vm # 向量-向量
vfwadd.wf vd, vs2, rs1, vm # 向量-标量
vfwsub.wv vd, vs2, vs1, vm # 向量-向量
vfwsub.wf vd, vs2, rs1, vm # 向量-标量
----

==== 向量单宽度浮点乘法/除法指令

----
    # 浮点乘法
    vfmul.vv vd, vs2, vs1, vm   # 向量-向量  
    vfmul.vf vd, vs2, rs1, vm   # 向量-标量  

    # 浮点除法
    vfdiv.vv vd, vs2, vs1, vm   # 向量-向量  
    vfdiv.vf vd, vs2, rs1, vm   # 向量-标量  

    # 反向浮点除法，向量 = 标量 / 向量
    vfrdiv.vf vd, vs2, rs1, vm  # 标量-向量，vd[i] = f[rs1]/vs2[i]  
----

==== 向量宽度浮点乘法

----
 # 宽度浮点乘法
vfwmul.vv vd, vs2, vs1, vm # 向量-向量
vfwmul.vf vd, vs2, rs1, vm # 向量-标量
----

==== 向量单宽度浮点融合乘加指令

提供了四种类型的融合乘加指令，其中两种是破坏性形式，会覆盖操作数中的一个，可能是加数或第一个乘数。

----
 # 浮点乘加，覆盖加数
vfmacc.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
vfmacc.vf vd, rs1, vs2, vm # vd[i] = +(f[rs1] * vs2[i]) + vd[i]

 # 浮点否定乘加，覆盖被减数
vfnmacc.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i]) - vd[i]
vfnmacc.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vs2[i]) - vd[i]

 # 浮点乘减加，覆盖被减数
vfmsac.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) - vd[i]
vfmsac.vf vd, rs1, vs2, vm # vd[i] = +(f[rs1] * vs2[i]) - vd[i]

 # 浮点否定乘减加，覆盖减数
vfnmsac.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i]) + vd[i]
vfnmsac.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vs2[i]) + vd[i]

 # 浮点乘加，覆盖乘数
vfmadd.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vd[i]) + vs2[i]
vfmadd.vf vd, rs1, vs2, vm # vd[i] = +(f[rs1] * vd[i]) + vs2[i]

 # 浮点否定乘加，覆盖乘数
vfnmadd.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vd[i]) - vs2[i]
vfnmadd.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vd[i]) - vs2[i]

 # 浮点乘减，覆盖乘数
vfmsub.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vd[i]) - vs2[i]
vfmsub.vf vd, rs1, vs2, vm # vd[i] = +(f[rs1] * vd[i]) - vs2[i]

 # 浮点反向乘减，覆盖乘数
vfnmsub.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vd[i]) + vs2[i]
vfnmsub.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vd[i]) + vs2[i]
----

NOTE: 虽然我们考虑过使用标量浮点 FMA 编码中的两个未使用的舍入模式来提供一些非破坏性的 FMA，这样做会使微架构变得复杂，因为它们是唯一具有三个输入和独立输出的带掩码操作。

==== 向量宽度浮点融合乘加指令

宽度浮点融合乘加指令会用结果覆盖宽度加数。乘法输入都是 SEW 宽度，而加数和目标是 2*SEW 位宽

----
 # 浮点宽度乘加，覆盖加数
vfwmacc.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) + vd[i]
vfwmacc.vf vd, rs1, vs2, vm # vd[i] = +(f[rs1] * vs2[i]) + vd[i]

 # 浮点宽度否定乘加，覆盖加数
vfwnmacc.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i]) - vd[i]
vfwnmacc.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vs2[i]) - vd[i]

 # 浮点宽度乘减加，覆盖加数
vfwmsac.vv vd, vs1, vs2, vm # vd[i] = +(vs1[i] * vs2[i]) - vd[i]
vfwmsac.vf vd, rs1, vs2, vm # vd[i] = +(f[rs1] * vs2[i]) - vd[i]

 # 浮点宽度否定乘减加，覆盖加数
vfwnmsac.vv vd, vs1, vs2, vm # vd[i] = -(vs1[i] * vs2[i]) + vd[i]
vfwnmsac.vf vd, rs1, vs2, vm # vd[i] = -(f[rs1] * vs2[i]) + vd[i]
----

==== 向量浮点平方根指令

这是一个一元向量-向量指令。

----
    # 浮点平方根
    vfsqrt.v vd, vs2, vm   # 向量-向量平方根  
----

==== 向量浮点倒数平方根估算指令

----
    # 浮点倒数平方根估算到 7 位。
    vfrsqrt7.v vd, vs2, vm
----

这是一个一元向量-向量指令，返回精确到 7 位的 1/sqrt(x) 估算值。

NOTE: 早期的草案版本使用了汇编器名称 vfrsqrte7，但由于该名称与元素宽度的 ``e``__x__ 表示法容易混淆，因此进行了修改。早期的名称可以作为工具链中的别名，保持向后兼容。

下表描述了该指令对于所有浮点输入类别的行为：

[cols="1,1,1"]
[%autowidth,float="center",align="center",options="header"]
|===
| 输入 | 输出 | 引发的异常

| -{inf} {le} _x_ < -0.0     | canonical NaN           | NV
| -0.0                       | -{inf}                  | DZ
| +0.0                       | +{inf}                  | DZ
| +0.0 < _x_ < +{inf}        | _estimate of 1/sqrt(x)_ |
| +{inf}                     | +0.0                    |
| qNaN                       | canonical NaN           |
| sNaN                       | canonical NaN           | NV
|===

NOTE: 所有正的标准数和非标准数输入都会产生正常的输出。

NOTE: 输出值与动态舍入模式无关。

对于非异常情况，指数的最低位和有效数字的六个最高位（去掉前导1后）被拼接起来并用于查找下表。表格中的输出结果成为结果有效数字的七个最高位（去掉前导1）；其余部分为零。非标准输入会先被规范化，并适当调整指数后再进行查找。输出的指数选择使得结果近似于输入数的倒数平方根。

更精确地说，结果计算如下：设输入的规范化指数为输入指数（如果输入是标准数），否则为 0 减去有效数字中前导零的个数。如果输入是非标准数，则规范化后的有效数字通过将输入有效数字左移 1 减去规范化指数的位数得到，并丢弃前导的1位。输出的指数等于 floor((3*B - 1 - 规范化输入指数) / 2)，其中 B 是指数偏置。输出符号与输入符号相同。

下表给出了输出尾数的七个最高有效位（MSB）作为规范化输入指数最低有效位（LSB）和规范化输入尾数六个最高有效位（MSB）的函数；输出尾数的其他位为零。

include::images/wavedrom/vfrsqrt7.adoc[]

NOTE: 例如，当 SEW=32 时，vfrsqrt7(0x00718abc (约为 1.043e-38)) = 0x5f080000 (约为 9.800e18)，而 vfrsqrt7(0x7f765432(约为 3.274e38)) = 0x1f820000 (约为 5.506e-20)。

NOTE: 选择 7 位精度是因为它需要 0、1、2、3 次牛顿-拉弗森迭代来分别收敛到接近 bfloat16、FP16、FP32、FP64 精度。未来的指令可以定义更高精度的估算。

==== 向量浮点倒数估算指令

----
    # 浮点倒数估算，精确到7位
    vfrec7.v vd, vs2, vm
----

NOTE: 早期的草案版本使用了汇编器名称 vfrece7，但由于该名称容易与元素宽度的 ex 表示法产生混淆，因此进行了修改。早期的名称可以作为工具链中的别名，保持向后兼容。

这是一个一元向量-向量指令，返回 1/x 的估算值，精度为 7 位。

下表描述了该指令对于所有浮点输入类别的行为，其中 B 是指数偏置：

[cols="1,1,1,1"]
[%autowidth,float="center",align="center",options="header"]
|===
| 输入 (_x_) | 舍入模式 | 输出 (_y_ {approx} _1/x_) | 引发的异常

| -{inf}                                              | _any_         | -0.0                      |
| -2^B+1^ < _x_ {le} -2^B^ (normal)                   | _any_         | -2^-(B+1)^ {ge} _y_ > -2^-B^ (subnormal, sig=01...) |
| -2^B^ < _x_ {le} -2^B-1^ (normal)                   | _any_         | -2^-B^ {ge} _y_ > -2^-B+1^ (subnormal, sig=1...) |
| -2^B-1^ < _x_ {le} -2^-B+1^ (normal)                | _any_         | -2^-B+1^ {ge} _y_ > -2^B-1^ (normal) |
| -2^-B+1^ < _x_ {le} -2^-B^ (subnormal, sig=1...)    | _any_         | -2^B-1^ {ge} _y_ > -2^B^ (normal) |
| -2^-B^ < _x_ {le} -2^-(B+1)^ (subnormal, sig=01...) | _any_         | -2^B^ {ge} _y_ > -2^B+1^ (normal) |
| -2^-(B+1)^ < _x_ < -0.0 (subnormal, sig=00...)      | RUP, RTZ      | greatest-mag. negative finite value | NX, OF
| -2^-(B+1)^ < _x_ < -0.0 (subnormal, sig=00...)      | RDN, RNE, RMM | -{inf}                    | NX, OF
| -0.0                                                | _any_         | -{inf}                    | DZ
| +0.0                                                | _any_         | +{inf}                    | DZ
| +0.0 < _x_ < 2^-(B+1)^ (subnormal, sig=00...)       | RUP, RNE, RMM | +{inf}                    | NX, OF
| +0.0 < _x_ < 2^-(B+1)^ (subnormal, sig=00...)       | RDN, RTZ      | greatest finite value     | NX, OF
| 2^-(B+1)^ {le} _x_ < 2^-B^ (subnormal, sig=01...)   | _any_         | 2^B+1^ > _y_ {ge} 2^B^ (normal) |
| 2^-B^ {le} _x_ < 2^-B+1^ (subnormal, sig=1...)      | _any_         | 2^B^ > _y_ {ge} 2^B-1^ (normal) |
| 2^-B+1^ {le} _x_ < 2^B-1^ (normal)                  | _any_         | 2^B-1^ > _y_ {ge} 2^-B+1^ (normal) |
| 2^B-1^ {le} _x_ < 2^B^ (normal)                     | _any_         | 2^-B+1^ > _y_ {ge} 2^-B^ (subnormal, sig=1...) |
| 2^B^ {le} _x_ < 2^B+1^ (normal)                     | _any_         | 2^-B^ > _y_ {ge} 2^-(B+1)^ (subnormal, sig=01...) |
| +{inf}                                              | _any_         | +0.0                      |
| qNaN                                                | _any_         | canonical NaN             |
| sNaN                                                | _any_         | canonical NaN             | NV
|===

NOTE: 具有大小至少为 2^-(B+1)^ 的次正常输入会产生正常输出；其他次正常输入会产生无穷大输出。具有大小至少为 2^B-1^ 的正常输入会产生次正常输出；其他正常输入会产生正常输出。

NOTE: 输出值取决于在溢出异常被触发时的动态舍入模式。

对于非异常情况，尾数的七个高位（去掉首位 1 后）用于查找以下表格。表格的输出值成为结果尾数的七个高位（去掉首位 1 后）；其余的结果尾数为零。次正常输入会先进行归一化，指数也会适当调整后再进行查找。输出指数选择以使结果逼近输入的倒数，且次正常输出会相应去归一化。

更精确地说，结果的计算方式如下：假设归一化的输入指数是输入指数（若输入为正常数），或者是 0 减去尾数中的前导零的个数（否则）。归一化的输出指数等于 (2B - 1 - 归一化输入指数)。如果归一化输出指数超出 [-1, 2B] 范围，结果将对应于上述表格中的某个特殊情况。

如果输入为次正常数，则归一化的输入尾数由将输入尾数左移 1 减去归一化输入指数的位数，去掉前导的 1 位得到。否则，归一化的输入尾数等于输入尾数。以下表格给出了归一化输出尾数的七个最高有效位（MSB）作为归一化输入尾数的七个最高有效位的函数；归一化输出尾数的其他位为零。

include::images/wavedrom/vfrec7.adoc[]

如果归一化输出指数为 0 或 -1，结果为次正常数：输出指数为 0，输出尾数由将 1 位连接到归一化输出尾数的左侧，然后将该值右移 1 减去归一化输出指数得到。否则，输出指数等于归一化输出指数，输出尾数等于归一化输出尾数。输出符号等于输入符号。

NOTE: 例如，当 SEW=32 时，vfrec7(0x00718abc ({approx} 1.043e-38)) = 0x7e900000 ({approx} 9.570e37)，vfrec7(0x7f765432 ({approx} 3.274e38)) = 0x00214000 ({approx} 3.053e-39)。

NOTE: 选择 7 位精度是因为它需要 0、1、2、3 次牛顿-拉夫森迭代，分别收敛到接近 bfloat16、FP16、FP32、FP64 精度。未来的指令可以定义为具有更高的估算精度。

==== 向量浮点最小/最大指令

向量浮点指令 vfmin 和 vfmax 的行为与 RISC-V F/D/Q 扩展版本 2.2 中的相应标量浮点指令相同：它们对激活元素执行 `minimumNumber` 或 `maximumNumber` 操作。

----
    # 浮点最小值
    vfmin.vv vd, vs2, vs1, vm   # 向量-向量
    vfmin.vf vd, vs2, rs1, vm   # 向量-标量

    # 浮点最大值
    vfmax.vv vd, vs2, vs1, vm   # 向量-向量
    vfmax.vf vd, vs2, rs1, vm   # 向量-标量
----

==== 向量浮点符号注入指令

标量符号注入指令的向量版本。结果将从向量 vs2 操作数中获取除了符号位之外的所有位。

----
    vfsgnj.vv vd, vs2, vs1, vm   # 向量-向量
    vfsgnj.vf vd, vs2, rs1, vm   # 向量-标量

    vfsgnjn.vv vd, vs2, vs1, vm  # 向量-向量
    vfsgnjn.vf vd, vs2, rs1, vm  # 向量-标量

    vfsgnjx.vv vd, vs2, vs1, vm  # 向量-向量
    vfsgnjx.vf vd, vs2, rs1, vm  # 向量-标量
----

NOTE: 可以使用符号注入指令对浮点值的向量进行取反，将两个源操作数设置为相同的向量操作数。提供的汇编伪指令为：vfneg.v vd,vs = vfsgnjn.vv vd,vs,vs。

NOTE: 可以使用符号注入指令计算浮点元素向量的绝对值，将两个源操作数设置为相同的向量操作数。提供的汇编伪指令为：vfabs.v vd,vs = vfsgnjx.vv vd,vs,vs。

==== 向量浮点比较指令

这些向量浮点比较指令比较两个源操作数，并将比较结果写入掩码寄存器。目标掩码向量始终保存在单个向量寄存器中，元素布局如 <<sec-mask-register-layout>> 所述。目标掩码向量寄存器可以与源向量掩码寄存器（v0）相同。比较指令会写入掩码寄存器，因此始终在与尾部无关的策略下操作。

比较指令遵循标量浮点比较指令的语义。`vmfeq` 和 `vmfne` 仅在输入为信号 NaN 时触发无效操作异常。`vmflt`、`vmfle`、`vmfgt` 和 `vmfge` 在输入为信号 NaN 或静默 NaN 时都触发无效操作异常。`vmfne` 在任一操作数为 NaN 时将 1 写入目标元素，而其他比较指令在任一操作数为 NaN 时将 0 写入目标元素。

----
    # 比较相等
    vmfeq.vv vd, vs2, vs1, vm  # 向量-向量
    vmfeq.vf vd, vs2, rs1, vm  # 向量-标量

    # 比较不相等
    vmfne.vv vd, vs2, vs1, vm  # 向量-向量
    vmfne.vf vd, vs2, rs1, vm  # 向量-标量

    # 比较小于
    vmflt.vv vd, vs2, vs1, vm  # 向量-向量
    vmflt.vf vd, vs2, rs1, vm  # 向量-标量

    # 比较小于或等于
    vmfle.vv vd, vs2, vs1, vm  # 向量-向量
    vmfle.vf vd, vs2, rs1, vm  # 向量-标量

    # 比较大于
    vmfgt.vf vd, vs2, rs1, vm  # 向量-标量

    # 比较大于或等于
    vmfge.vf vd, vs2, rs1, vm  # 向量-标量
----

----
    比较             汇编器映射                 汇编器伪指令
    
    va < vb         vmflt.vv vd, va, vb, vm
    va <= vb        vmfle.vv vd, va, vb, vm
    va > vb         vmflt.vv vd, vb, va, vm    vmfgt.vv vd, va, vb, vm
    va >= vb        vmfle.vv vd, vb, va, vm    vmfge.vv vd, va, vb, vm
    
    va < f          vmflt.vf vd, va, f, vm
    va <= f         vmfle.vf vd, va, f, vm
    va > f          vmfgt.vf vd, va, f, vm
    va >= f         vmfge.vf vd, va, f, vm
    
    va, vb 向量寄存器组
    f      标量浮点寄存器
----

NOTE: 提供所有形式的比较指令对于正确处理 NaN 的无序比较是必要的。

NOTE: C99 浮点静默比较可以通过在任一输入为 NaN 时屏蔽信号比较来实现，方法如下。当比较值是非 NaN 常量时，可以省略中间的两个指令。

----
    # 实现 isgreater() 的示例
    vmfeq.vv v0, va, va        # 仅在 A 不是 NaN 时设置。
    vmfeq.vv v1, vb, vb        # 仅在 B 不是 NaN 时设置。
    vmand.mm v0, v0, v1        # 仅在 A 和 B 是有序时设置，
    vmfgt.vv v0, va, vb, v0.t  # 仅在有序值上设置标志。
----

NOTE: 在上述序列中，虽然有可能屏蔽第二条 `vmfeq` 指令并移除 `vmand` 指令，但这个更高效的序列会错误地未能在 `va` 的元素包含静默 NaN 且 `vb` 中相应元素包含信号 NaN 时触发无效异常。

==== 向量浮点分类指令

这是一个一元向量-向量指令，操作方式与标量分类指令相同。

----
    vfclass.v vd, vs2, vm   # 向量-向量
----

该指令生成的 10 位掩码被放置在结果元素的最低有效位。结果的高位（SEW-10 位）填充为零。该指令仅在 SEW=16b 或更高时定义，因此结果总是能够适配目标元素。

==== 向量浮点合并指令

提供了一条向量-标量浮点合并指令，它对从 `vstart` 到当前向量长度 `vl` 之间的所有元素进行操作，无论掩码值如何。

`vfmerge.vfm` 指令被编码为一个带掩码的指令（`vm=0`）。在掩码值为零的元素上，第一个向量操作数被复制到目标元素；否则，将标量浮点寄存器值复制到目标元素。

----
vfmerge.vfm vd, vs2, rs1, v0  # vd[i] = v0.mask[i] ? f[rs1] : vs2[i]
----

[[sec-vector-float-move]]
==== 向量浮点移动指令

向量浮点移动指令将浮点标量操作数扩展到一个向量寄存器组。该指令将标量 `f` 寄存器的值复制到向量寄存器组的所有激活元素中。该指令被编码为一个不带掩码的指令（`vm=1`）。指令必须将 `vs2` 字段设置为 `v0`，并且其他 `vs2` 的值被保留。

----
vfmv.v.f vd, rs1  # vd[i] = f[rs1]
----

NOTE: `vfmv.v.f` 指令与 `vfmerge.vfm` 指令共享编码，但其 `vm=1` 且 `vs2=v0`。

==== 单宽浮点/整数类型转换指令

提供了转换操作，用于在浮点值和无符号/有符号整数之间进行转换，源和目标均为 SEW 宽度。

----
vfcvt.xu.f.v vd, vs2, vm        # 将浮点数转换为无符号整数。 
vfcvt.x.f.v  vd, vs2, vm        # 将浮点数转换为有符号整数。

vfcvt.rtz.xu.f.v vd, vs2, vm    # 将浮点数转换为无符号整数（截断）。 
vfcvt.rtz.x.f.v  vd, vs2, vm    # 将浮点数转换为有符号整数（截断）。

vfcvt.f.xu.v vd, vs2, vm        # 将无符号整数转换为浮点数。 
vfcvt.f.x.v  vd, vs2, vm        # 将有符号整数转换为浮点数。
----

这些转换遵循与标量转换指令相同的异常条件规则。转换使用 frm 中的动态舍入模式，rtz 变体除外，后者是朝零舍入。

NOTE: `rtz` 变体是为了加速从浮点到整数的截断转换，正如 C 和 Java 等语言中常见的做法。

==== 扩宽浮点/整数类型转换指令

提供了一组转换指令，用于将较窄的整数和浮点数据类型转换为宽度是原来两倍的类型。

----
vfwcvt.xu.f.v vd, vs2, vm # 将浮点数转换为双宽无符号整数。 
vfwcvt.x.f.v vd, vs2, vm  # 将浮点数转换为双宽有符号整数。

vfwcvt.rtz.xu.f.v vd, vs2, vm # 将浮点数转换为双宽无符号整数（截断）。 
vfwcvt.rtz.x.f.v vd, vs2, vm  # 将浮点数转换为双宽有符号整数（截断）。

vfwcvt.f.xu.v vd, vs2, vm # 将无符号整数转换为双宽浮点数。 
vfwcvt.f.x.v vd, vs2, vm  # 将有符号整数转换为双宽浮点数。

vfwcvt.f.f.v vd, vs2, vm  # 将单宽浮点数转换为双宽浮点数。
----

这些指令在向量寄存器重叠上的约束与其他扩展指令相同（参见 <<sec-widening>>）。

NOTE: 双宽 IEEE 浮点数值总是能够准确表示单宽度整数。

NOTE: 双宽 IEEE 浮点数值总是能够准确表示单宽度 IEEE 浮点数值。

NOTE: 并未提供完整的浮点扩宽转换作为单个指令，但任何扩宽转换都可以通过多个加倍步骤来实现，且结果等效，不会引发额外的异常标志。

==== 缩小浮点/整数类型转换指令

提供了一组转换指令，用于将较宽的整数和浮点数据类型转换为宽度为原来一半的类型。

----
vfncvt.xu.f.w vd, vs2, vm       # 将双宽浮点数转换为无符号整数。 
vfncvt.x.f.w vd, vs2, vm        # 将双宽浮点数转换为有符号整数。

vfncvt.rtz.xu.f.w vd, vs2, vm   # 将双宽浮点数转换为无符号整数（截断）。 
vfncvt.rtz.x.f.w vd, vs2, vm    # 将双宽浮点数转换为有符号整数（截断）。

vfncvt.f.xu.w vd, vs2, vm       # 将双宽无符号整数转换为浮点数。 
vfncvt.f.x.w vd, vs2, vm        # 将双宽有符号整数转换为浮点数。

vfncvt.f.f.w vd, vs2, vm        # 将双宽浮点数转换为单宽浮点数。 
vfncvt.rod.f.f.w vd, vs2, vm    # 将双宽浮点数转换为单宽浮点数， 
                                # 朝奇数舍入。
----

这些指令在向量寄存器重叠上的约束与其他缩小指令相同（参见 <<sec-narrowing>>）。

NOTE: 并未提供完整的浮点缩小转换作为单个指令。转换可以通过一系列减半步骤来实现。如果除最后一步外的所有减半步骤都使用朝奇数舍入（vfncvt.rod.f.f.w），结果将等效地舍入，且会引发相同的异常标志。只有最后一步应使用所需的舍入模式。

NOTE: 对于 vfncvt.rod.f.f.w，如果有限值超出了目标格式的范围，将被转换为目标格式的最大有限值，并保留相同符号。

=== 向量归约操作

向量归约操作接受一个向量寄存器组的元素和一个存储在向量寄存器第 0 元素中的标量，并使用某个二元操作符进行归约，最终将结果存储在向量寄存器的第 0 元素中作为标量结果。标量输入和输出操作数存储在单个向量寄存器的第 0 元素中，而不是在向量寄存器组中，因此，无论 LMUL 设置如何，任何向量寄存器都可以作为向量归约的标量源操作数或目标操作数。

目标向量寄存器可以与源操作数重叠，包括掩码寄存器。

NOTE: 向量归约操作会将标量操作数和结果读取并写入到向量寄存器的第 0 元素中，而不是标量寄存器中，以避免与标量处理器的耦合丧失，并支持未来与标量单元中不支持的类型的多态使用。

源向量寄存器组中的未激活元素会被排除在归约之外，但标量操作数始终会被包含于内，无论掩码值如何。

目标向量寄存器中的其他元素（0 < 索引 < VLEN/SEW）被视为尾部元素，并按当前的尾部不可知/不干扰策略进行管理。

如果 `vl`=0，则不执行任何操作，目标寄存器不会更新。

NOTE: 对于 `vl`=0 的行为选择简化了实现复杂性，因为它与对向量寄存器状态的其他操作保持一致。对于常见情况，即源操作数和目标标量操作数是同一个向量寄存器时，这种行为也会产生预期的结果。对于不常见的情况，即源和目标标量操作数位于不同的向量寄存器中，当 `vl`=0 时，这条指令不会将源寄存器的内容复制到目标寄存器。然而，预计在大多数情况下会静态地知道 `vl` 不是零。在其他情况下，必须检查 `vl` 是否为 0，以确保源标量被复制到目标（例如，显式设置 `vl`=1 并执行寄存器到寄存器的复制）。

向量归约指令的异常总是以 `vstart` 为 0 进行报告。如果 `vstart` 非零，向量归约操作将触发非法指令异常。

归约操作的汇编语法是 `vredop.vs`，其中 `.vs` 后缀表示第一个操作数是向量寄存器组，第二个操作数是存储在向量寄存器元素 0 中的标量。

[[sec-vector-integer-reduce]]
==== 向量单宽整数归约指令

所有单宽归约指令的操作数和结果具有相同的 SEW 宽度。在算术求和时，溢出会发生环绕。

----
    # Simple reductions, where [*] denotes all active elements:
    vredsum.vs  vd, vs2, vs1, vm   # vd[0] =  sum( vs1[0] , vs2[*] )
    vredmaxu.vs vd, vs2, vs1, vm   # vd[0] = maxu( vs1[0] , vs2[*] )
    vredmax.vs  vd, vs2, vs1, vm   # vd[0] =  max( vs1[0] , vs2[*] )
    vredminu.vs vd, vs2, vs1, vm   # vd[0] = minu( vs1[0] , vs2[*] )
    vredmin.vs  vd, vs2, vs1, vm   # vd[0] =  min( vs1[0] , vs2[*] )
    vredand.vs  vd, vs2, vs1, vm   # vd[0] =  and( vs1[0] , vs2[*] )
    vredor.vs   vd, vs2, vs1, vm   # vd[0] =   or( vs1[0] , vs2[*] )
    vredxor.vs  vd, vs2, vs1, vm   # vd[0] =  xor( vs1[0] , vs2[*] )
----

[[sec-vector-integer-reduce-widen]]
==== 向量宽整数归约指令

无符号的 `vwredsumu.vs` 指令在求和之前会对 SEW 宽度的向量元素进行零扩展，然后将 2SEW 宽度的标量元素加到结果中，并将结果存储到一个 2SEW 宽度的标量元素中。

`vwredsum.vs` 指令在求和之前会对 SEW 宽度的向量元素进行符号扩展。

对于 `vwredsumu.vs` 和 `vwredsum.vs`，溢出会发生环绕。

----
    # 无符号和归约，累加到双宽度累加器
    vwredsumu.vs vd, vs2, vs1, vm   # 2*SEW = 2*SEW + sum(零扩展(SEW))

    # 有符号和归约，累加到双宽度累加器
    vwredsum.vs  vd, vs2, vs1, vm   # 2*SEW = 2*SEW + sum(符号扩展(SEW))
----

[[sec-vector-float-reduce]]
==== 向量单宽浮点归约指令

----
    # 简单归约。
    vfredosum.vs vd, vs2, vs1, vm # 有序求和
    vfredusum.vs vd, vs2, vs1, vm # 无序求和
    vfredmax.vs  vd, vs2, vs1, vm # 最大值
    vfredmin.vs  vd, vs2, vs1, vm # 最小值
----

NOTE: 旧的汇编助记符 vfredsum 被保留为 vfredusum 的别名。

===== 向量有序单宽浮点求和归约

`vfredosum` 指令必须按照元素顺序对浮点值进行求和，从 `vs1[0]` 中的标量开始——即它执行以下计算：

----
 vd[0] = `(((vs1[0] + vs2[0]) + vs2[1]) + ...) + vs2[vl-1]`
----
其中每次加法操作与标量浮点指令相同，会触发异常标志并生成或传播特殊值。

NOTE: 有序归约支持编译器的自动向量化，而无序浮点求和则允许更快速的实现。

当操作被掩码时（`vm=0`），被掩码的元素不会影响结果或异常标志。

NOTE: 如果没有元素处于激活状态，则不会执行加法操作，因此 `vs1[0]` 中的标量将直接复制到目标寄存器，而不会标准化 NaN 值，也不会设置任何异常标志。这种行为保留了在自动向量化标量求和循环时对 NaN、异常和舍入的处理。

===== 向量无序单宽浮点求和归约

无序求和归约指令 `vfredusum` 提供了更大的灵活性来执行归约。

实现必须生成一个结果，等同于由二元运算符节点组成的归约树，输入为源向量寄存器组（`vs2`）中的元素和源标量值（`vs1[0]`）。树中的每个运算符接受两个输入并生成一个结果。

每个操作符的结果可以选择不同的浮点范围和精度。

当某个节点的一个输入仅来自被掩码掉或超出激活向量长度的元素时，可以将该输入视为适当 EEW 类型的加法单位元素，或直接将另一个输入复制到输出。

从归约树的根节点获得的舍入结果会被转换（再次进行舍入，使用动态舍入模式）为由 SEW 指定的标准浮点格式。

实现可以向最终结果添加额外的加法单位元素。

加法单位是 +0.0，当舍入方向为向下（接近 -∞）时，或者对于所有其他舍入模式为 -0.0。

归约树的结构对于给定的 `vtype` 和 `vl` 必须是确定的。

NOTE: 根据此定义，实现不需要在没有活动元素时通过归约树传播 NaN 负载。特别是，如果没有元素处于活动状态并且标量输入为 NaN，则实现允许将 NaN 标准化，并且如果该 NaN 为信号 NaN，则设置无效异常标志。实现也可以选择直接通过初始 NaN 并且不设置任何异常标志，就像 vfredosum 一样。

NOTE: `vfredosum` 指令是 `vfredusum` 指令的有效实现。

===== 向量单宽浮点最大值和最小值归约

`vfredmin` 和 `vfredmax` 指令分别使用 `minimumNumber` 和 `maximumNumber` 操作对 `vs1[0]` 中的标量参数和 `vs2` 中的激活元素进行归约。

NOTE: 浮点最大值和最小值归约应返回相同的最终值，并且无论操作顺序如何，都应触发相同的异常标志。

NOTE: 如果没有元素处于激活状态，则 `vs1[0]` 中的标量将简单地复制到目标寄存器，而不会标准化 NaN 值，也不会设置任何异常标志。

[[sec-vector-float-reduce-widen]]
==== 向量宽度浮点归约指令

提供了求和归约的宽度形式，这些形式会读取并写入一个双宽度的归约结果。

----
 # 简单归约
vfwredosum.vs vd, vs2, vs1, vm # 有序求和
vfwredusum.vs vd, vs2, vs1, vm # 无序求和
----
NOTE: 旧的汇编助记符 vfwredsum 被保留为 vfwredusum 的别名。

SEW 宽度的元素归约的执行方式与单宽度归约相同，`vs2` 中的元素在加到 2SEW 位的累加器之前会被提升到 2SEW 位。

NOTE: `vfwredosum.vs` 处理未激活元素和 NaN 负载的方式类似于 `vfredosum.vs`；`vfwredusum.vs` 处理方式类似于 `vfredusum.vs`。

[[sec-vector-mask]]
=== 向量掩码指令

提供了若干指令，帮助操作存储在向量寄存器中的掩码值。

[[sec-mask-register-logical]]
==== 向量掩码寄存器逻辑指令

向量掩码寄存器逻辑操作作用于掩码寄存器。掩码寄存器中的每个元素是一个单独的位，因此这些指令作用于单个向量寄存器，而与 `vtype` 中 `vlmul` 字段的设置无关。它们不会改变 `vlmul` 的值。目标向量寄存器可以是与源向量寄存器相同。

与其他向量指令类似，索引小于 `vstart` 的元素保持不变，执行后 `vstart` 会被重置为零。向量掩码逻辑指令始终是未掩码的，因此没有未激活元素，并且 `vm=0` 的编码被保留。超出 `vl` 的掩码元素，即尾部元素，始终按尾部无关策略更新。

----
    vmand.mm vd, vs2, vs1   # vd.mask[i] =   vs2.mask[i] &&  vs1.mask[i]
    vmnand.mm vd, vs2, vs1  # vd.mask[i] = !(vs2.mask[i] &&  vs1.mask[i])
    vmandn.mm vd, vs2, vs1  # vd.mask[i] =   vs2.mask[i] && !vs1.mask[i]
    vmxor.mm  vd, vs2, vs1  # vd.mask[i] =   vs2.mask[i] ^^  vs1.mask[i]
    vmor.mm  vd, vs2, vs1   # vd.mask[i] =   vs2.mask[i] ||  vs1.mask[i]
    vmnor.mm  vd, vs2, vs1  # vd.mask[i] = !(vs2.mask[i] ||  vs1.mask[i])
    vmorn.mm  vd, vs2, vs1  # vd.mask[i] =   vs2.mask[i] || !vs1.mask[i]
    vmxnor.mm vd, vs2, vs1  # vd.mask[i] = !(vs2.mask[i] ^^  vs1.mask[i])
----

NOTE: 之前的汇编助记符 `vmandnot` 和 `vmornot` 已经被改为 `vmandn` 和 `vmorn`，以与等效的标量指令保持一致。旧的 `vmandnot` 和 `vmornot` 助记符可以作为兼容性别名保留。

定义了几个汇编伪指令，作为常用掩码逻辑操作的简写：
----
    vmmv.m vd, vs  => vmand.mm vd, vs, vs   # 复制掩码寄存器
    vmclr.m vd     => vmxor.mm vd, vd, vd   # 清除掩码寄存器
    vmset.m vd     => vmxnor.mm vd, vd, vd  # 设置掩码寄存器
    vmnot.m vd, vs => vmnand.mm vd, vs, vs  # 按位取反
----

NOTE: `vmmv.m` 指令以前叫做 `vmcpy.m`，但是现在根据新的布局，它更符合“mv”的命名，因为位被直接复制而没有解释。为了兼容性，可以保留旧的 `vmcpy.m` 汇编伪指令。对于内部根据 EEW 重排位的实现，可以使用源和目标相同的 `vmmv.m` 指令，作为强制内部重新格式化为掩码向量的惯用法。

下面这八条掩码逻辑指令可以生成两个输入掩码的 16 种可能的二进制逻辑函数。

[cols="1,1,1,1,12"]
|===
4+| 输入 |

| 0 | 0 | 1 | 1 | src1
| 0 | 1 | 0 | 1 | src2
|===

[cols="1,1,1,1,6,6"]
|===
4+| 输出  | 指令 | 伪指令

| 0 | 0 | 0 | 0 | vmxor.mm vd, vd, vd         | vmclr.m vd
| 1 | 0 | 0 | 0 | vmnor.mm vd, src1, src2     |
| 0 | 1 | 0 | 0 | vmandn.mm vd, src2, src1    |
| 1 | 1 | 0 | 0 | vmnand.mm vd, src1, src1    | vmnot.m vd, src1
| 0 | 0 | 1 | 0 | vmandn.mm vd, src1, src2    |
| 1 | 0 | 1 | 0 | vmnand.mm vd, src2, src2    | vmnot.m vd, src2
| 0 | 1 | 1 | 0 | vmxor.mm vd, src1, src2     |
| 1 | 1 | 1 | 0 | vmnand.mm vd, src1, src2    |
| 0 | 0 | 0 | 1 | vmand.mm vd, src1, src2     |
| 1 | 0 | 0 | 1 | vmxnor.mm vd, src1, src2    |
| 0 | 1 | 0 | 1 | vmand.mm vd, src2, src2     | vmmv.m vd, src2
| 1 | 1 | 0 | 1 | vmorn.mm vd, src2, src1     |
| 0 | 0 | 1 | 1 | vmand.mm vd, src1, src1     | vmmv.m vd, src1
| 1 | 0 | 1 | 1 | vmorn.mm vd, src1, src2     |
| 0 | 1 | 1 | 1 | vmor.mm vd, src1, src2      |
| 1 | 1 | 1 | 1 | vmxnor.mm vd, vd, vd        | vmset.m vd
|===

NOTE: 向量掩码逻辑指令旨在与后续的掩码向量操作轻松融合，从而通过在使用之前将值移入 `v0` 来有效扩展谓词寄存器的数量。

==== 向量掩码中的计数操作 `vcpop.m`

----
    vcpop.m rd, vs2, vm
----

NOTE: 该指令之前的汇编助记符是 `vpopc.m`，但为了与标量指令保持一致，已将其重命名。为了软件兼容性，汇编指令别名 `vpopc.m` 仍然保留。

源操作数是一个向量寄存器，存储了掩码寄存器的值，具体内容参见 <<sec-mask-register-layout>>。

`vcpop.m` 指令计算向量源掩码寄存器的激活元素中值为 1 的掩码元素的数量，并将结果写入标量 `x` 寄存器。

该操作可以在掩码下执行，此时仅计数被掩码的元素。

----
 vcpop.m rd, vs2, v0.t # x[rd] = sum_i ( vs2.mask[i] && v0.mask[i] )
----

即使 `vl = 0`，`vcpop.m` 指令也会写入 `x[rd]`（值为 0，因为没有激活的掩码元素）。

`vcpop.m` 指令的陷阱始终报告 `vstart` 为 0。如果 `vstart` 非零，则该指令会触发非法指令异常。

==== `vfirst` 查找第一个设置的掩码位

----
    vfirst.m rd, vs2, vm
----

`vfirst` 指令查找源掩码向量中值为 1 的最小编号的激活元素，并将该元素的索引写入通用寄存器（GPR）。如果没有激活元素的值为 1，则将 -1 写入 GPR。

NOTE: 软件可以假设任何负值（最高位被设置）表示未找到元素，因为向量长度在任何实现中都不会达到 2^(XLEN-1)。

即使 `vl = 0`，`vfirst.m` 指令也会写入 `x[rd]`（值为 -1，因为没有激活的掩码元素）。

`vfirst` 指令的陷阱始终报告 `vstart` 为 0。如果 `vstart` 非零，则该指令会触发非法指令异常。

==== `vmsbf.m` 设置第一个掩码位之前的掩码位

----
    vmsbf.m vd, vs2, vm

 # 例子

     7 6 5 4 3 2 1 0   元素编号

     1 0 0 1 0 1 0 0   v3 内容
                       vmsbf.m v2, v3
     0 0 0 0 0 0 1 1   v2 内容

     1 0 0 1 0 1 0 1   v3 内容
                       vmsbf.m v2, v3
     0 0 0 0 0 0 0 0   v2

     0 0 0 0 0 0 0 0   v3 内容
                       vmsbf.m v2, v3
     1 1 1 1 1 1 1 1   v2

     1 1 0 0 0 0 1 1   v0 内容
     1 0 0 1 0 1 0 0   v3 内容
                       vmsbf.m v2, v3, v0.t
     0 1 x x x x 1 1   v2 内容
----

`vmsbf.m` 指令以掩码寄存器为输入，并将结果写回掩码寄存器。该指令在第一个活跃源元素为 1 之前，将所有活跃的掩码元素写为 1，然后将该元素及其后续的所有活跃元素写为 0。如果源向量的活跃元素中没有设置的位，则目标中的所有活跃元素都会被写为 1。

目标掩码寄存器中的尾部元素在尾部无关策略下更新。

`vmsbf.m` 指令的异常总是报告 `vstart` 为 0。如果 `vstart` 非零，`vmsbf` 指令会引发非法指令异常。

目标寄存器不能与源寄存器重叠，并且如果被屏蔽，也不能与掩码寄存器（'v0'）重叠。

==== `vmsif.m` 设置包括第一个掩码位

向量掩码设置包括第一个指令类似于设置前第一个，只是它还包括具有设置位的元素。

----
    vmsif.m vd, vs2, vm

 # 例子

     7 6 5 4 3 2 1 0   元素编号

     1 0 0 1 0 1 0 0   v3 内容
                       vmsif.m v2, v3
     0 0 0 0 0 1 1 1   v2 内容

     1 0 0 1 0 1 0 1   v3 内容
                       vmsif.m v2, v3
     0 0 0 0 0 0 0 1   v2

     1 1 0 0 0 0 1 1   v0 内容
     1 0 0 1 0 1 0 0   v3 内容
                       vmsif.m v2, v3, v0.t
     1 1 x x x x 1 1   v2 内容
----

目标掩码寄存器中的尾部元素在尾部无关策略下更新。

`vmsif.m` 指令的异常总是报告 `vstart` 为 0。如果 `vstart` 非零，`vmsif` 指令会引发非法指令异常。

目标寄存器不能与源寄存器重叠，并且如果被屏蔽，也不能与掩码寄存器（'v0'）重叠。

==== `vmsof.m` 仅设置第一个掩码位

向量掩码仅设置第一个指令与设置前第一个指令类似，区别在于它只设置第一个设置了位的元素（如果有的话）。

----
    vmsof.m vd, vs2, vm

 # 例子

     7 6 5 4 3 2 1 0   元素编号

     1 0 0 1 0 1 0 0   v3 内容
                       vmsof.m v2, v3
     0 0 0 0 0 1 0 0   v2 内容

     1 0 0 1 0 1 0 1   v3 内容
                       vmsof.m v2, v3
     0 0 0 0 0 0 0 1   v2

     1 1 0 0 0 0 1 1   v0 内容
     1 1 0 1 0 1 0 0   v3 内容
                       vmsof.m v2, v3, v0.t
     0 1 x x x x 0 0   v2 内容
----

目标掩码寄存器中的尾部元素在尾部无关策略下更新。

`vmsof.m` 指令的异常总是报告 `vstart` 为 0。如果 `vstart` 非零，`vmsof` 指令会引发非法指令异常。

目标寄存器不能与源寄存器重叠，并且如果被屏蔽，也不能与掩码寄存器（'v0'）重叠。

==== 使用向量掩码指令的示例

以下是一个向量化数据依赖退出循环的示例。

----
include::example/strcpy_zh.s[lines=4..-1]
----
----
include::example/strncpy_zh.s[lines=4..-1]
----

==== 向量 Iota 指令

viota.m 指令读取源向量掩码寄存器，并将该掩码寄存器中所有小于当前元素索引的元素的位的总和写入目标向量寄存器组的每个元素，例如，掩码值的并行前缀和。

此指令可以进行掩码操作，在这种情况下，只有启用的元素才会参与计算。

----
 viota.m vd, vs2, vm

 # 例子

     7 6 5 4 3 2 1 0   元素编号

     1 0 0 1 0 0 0 1   v2 内容
                       viota.m v4, v2 # 未掩码
     2 2 2 1 1 1 1 0   v4 结果

     1 1 1 0 1 0 1 1   v0 内容
     1 0 0 1 0 0 0 1   v2 内容
     2 3 4 5 6 7 8 9   v4 内容
                       viota.m v4, v2, v0.t # 掩码, vtype.vma=0
     1 1 1 5 1 7 1 0   v4 结果
----

如果 SEW 宽度大于结果宽度，则结果值会被零扩展以填充目标元素。如果结果值会溢出目标 SEW，则保留最低有效的 SEW 位。

`viota.m` 指令的异常总是报告 `vstart` 为 0，且每次恢复后从头开始执行。如果 `vstart` 非零，指令会引发非法指令异常。

目标寄存器组不能与源寄存器重叠，并且如果被屏蔽，也不能与掩码寄存器（`v0`）重叠。

`viota.m` 指令可以与内存散射指令（索引存储）结合使用，以执行向量压缩功能。

----
    # 将非零元素从输入内存数组压缩到输出内存数组
    #
    # size_t compact_non_zero(size_t n, const int* in, int* out)
    # {
    #   size_t i;
    #   size_t count = 0;
    #   int *p = out;
    #
    #   for (i=0; i<n; i++)
    #   {
    #       const int v = *in++;
    #       if (v != 0)
    #           *p++ = v;
    #   }
    #
    #   return (size_t) (p - out);
    # }
    #
    # a0 = n
    # a1 = &in
    # a2 = &out

compact_non_zero:
    li a6, 0                      # 重置非零元素计数数量
loop:
    vsetvli a5, a0, e32, m8, ta, ma   # 32位整形
    vle32.v v8, (a1)               # 读取输入向量
      sub a0, a0, a5               # 完成数量递减
      slli a5, a5, 2               # 乘以 4 个字节
    vmsne.vi v0, v8, 0             # 查找非零值
      add a1, a1, a5               # 碰撞输入指针
    vcpop.m a5, v0                 # 对 v0 中设置的元素数进行计数
    viota.m v16, v0                # 获取激活元素的目标偏移量
      add a6, a6, a5               # 累加元素数量
    vsll.vi v16, v16, 2, v0.t      # 将偏移量乘以 4 个字节
      slli a5, a5, 2               # 将非零元素的数量乘以 4 个字节
    vsuxei32.v v8, (a2), v16, v0.t # 在掩码下使用缩放的 viota 结果进行散射
      add a2, a2, a5               # 碰撞输出指针
      bnez a0, loop                # 继续?

      mv a0, a6                    # 返回计数数量
      ret
----

==== 向量元素索引指令

`vid.v` 指令将每个元素的索引写入目标向量寄存器组，索引从 0 到 `vl`-1。

----
    vid.v vd, vm  # 将元素 ID 写入目标。
----

该指令可以被屏蔽。屏蔽不会改变写入激活元素的索引值。

指令中的 `vs2` 字段必须设置为 `v0`，否则该编码为保留。

如果目标 SEW 比结果宽，结果值将被零扩展以填充目标元素。如果结果值会溢出目标 SEW，则保留最低有效的 SEW 位。

NOTE: 微架构可以使用与 `viota.m` 相同的数据通路实现 `vid.v` 指令，但隐式设置掩码源。

[[sec-vector-permute]]
=== 向量置换指令

提供了一系列置换指令，用于在向量寄存器内移动元素。

==== 整数标量移动指令

整数标量读/写指令在标量 `x` 寄存器和向量寄存器的元素 0 之间传输单个值。该指令忽略 LMUL 和向量寄存器组。

----
vmv.x.s rd, vs2  # x[rd] = vs2[0] (vs1=0)
vmv.s.x vd, rs1  # vd[0] = x[rs1] (vs2=0)
----

`vmv.x.s` 指令将源向量寄存器索引 0 处的一个 SEW 宽元素复制到目标整数寄存器。如果 SEW > XLEN，则传输最低有效的 XLEN 位，忽略上面的 SEW-XLEN 位。如果 SEW < XLEN，则该值会被符号扩展到 XLEN 位。

NOTE: 即使 `vstart` {ge} `vl` 或 `vl`=0，`vmv.x.s` 也会执行操作。

`vmv.s.x` 指令将标量整数寄存器的值复制到目标向量寄存器的元素 0。如果 SEW < XLEN，则复制最低有效的位，忽略上面的 XLEN-SEW 位。如果 SEW > XLEN，则该值会被符号扩展到 SEW 位。目标向量寄存器中其他元素（0 < 索引 < VLEN/SEW）将按照当前尾部无关/未干扰策略处理。如果 vstart {ge} vl，则不执行任何操作，目标寄存器不会被更新。

NOTE: 因此，当 `vl`=0 时，无论 `vstart` 如何，目标向量寄存器组中的元素都不会被更新。

与 `vmv.x.s` 和 `vmv.s.x` 的屏蔽版本（vm=0）对应的编码是保留的。

====  浮点标量移动指令

浮点标量读/写指令在标量 `f` 寄存器和向量寄存器的元素 0 之间传输单个值。该指令忽略 LMUL 和向量寄存器组。

----
vfmv.f.s rd, vs2  # f[rd] = vs2[0] (rs1=0)
vfmv.s.f vd, rs1  # vd[0] = f[rs1] (vs2=0)
----
`vfmv.f.s` 指令将源向量寄存器索引 0 处的单个 SEW 宽元素复制到目标标量浮点寄存器。

NOTE: 即使 `vstart` {ge} `vl` 或 `vl`=0，`vfmv.f.s` 也会执行操作。

`vfmv.s.f` 指令将标量浮点寄存器的值复制到目标向量寄存器的元素 0。目标向量寄存器中其他元素（0 < 索引 < VLEN/SEW）将按照当前尾部无关/未干扰策略处理。如果 `vstart` {ge} `vl`，则不执行任何操作，目标寄存器不会被更新。

NOTE: 因此，当 `vl`=0 时，无论 `vstart` 如何，目标向量寄存器组中的元素都不会被更新。

与 `vfmv.f.s` 和 `vfmv.s.f` 的屏蔽版本（`vm=0`）对应的编码是保留的。

==== 向量滑动指令

滑动指令将元素在向量寄存器组中上下移动。

NOTE: 滑动操作比使用任意寄存器聚集指令更高效实现。实现可能会针对 `vslideup` 和 `vslidedown` 优化某些偏移量。特别是，2 的幂偏移可能比其他偏移操作要快得多。

对于所有 `vslideup`、`vslidedown`、`v[f]slide1up` 和 `v[f]slide1down` 指令，如果 `vstart` {ge} `vl`，则指令不执行任何操作，目标向量寄存器保持不变。

NOTE: 因此，当 `vl`=0 时，无论 `vstart` 如何，目标向量寄存器组中的元素都不会被更新。

尾部元素将按照尾部无关/未干扰策略处理。

滑动指令可以被掩码，掩码元素 _i_ 控制是否写入目标元素 _i_。对于未激活元素，将遵循掩码未干扰/无关策略。

===== 向量向上滑动指令

----
 vslideup.vx vd, vs2, rs1, vm        # vd[i+x[rs1]] = vs2[i]
 vslideup.vi vd, vs2, uimm, vm       # vd[i+uimm] = vs2[i]
----

对于 `vslideup`，`vl` 中的值指定了写入目标元素的最大数量。目标的起始索引（OFFSET）可以通过 `rs1` 指定的 `x` 寄存器中的无符号整数来指定，也可以通过一个 5 位的立即数来指定，并且该立即数会零扩展为 XLEN 位。如果 XLEN > SEW，OFFSET 不会被截断为 SEW 位。如果未屏蔽且 OFFSET < `vl`，则写入目标元素 OFFSET 到 `vl`-1。

----
    vslideup 行为对于目标元素（`vstart` < `vl`）

    OFFSET 是偏移量，可以来自 x 寄存器或 5 位立即数

                    0 <= i < min(vl, max(vstart, OFFSET))  不变
  max(vstart, OFFSET) <= i < vl                            如果 v0.mask[i] 使能则 vd[i] = vs2[i-OFFSET] 
                   vl <= i < VLMAX                         遵循尾部策略
----

`vslideup` 的目标向量寄存器组不能与源向量寄存器组重叠，否则该指令编码为保留。

NOTE: 此非重叠约束避免了在执行过程中输入向量上的 WAR 危害，并且支持在 `vstart` 非零时重新启动。

===== 向量向下滑动指令

----
 vslidedown.vx vd, vs2, rs1, vm       # vd[i] = vs2[i+x[rs1]]
 vslidedown.vi vd, vs2, uimm, vm      # vd[i] = vs2[i+uimm]
----

对于 `vslidedown`，`vl` 中的值指定了写入目标元素的最大数量。超过 `vl` 的剩余元素将根据当前的尾部策略处理（参见 <<sec-agnostic>>）。

源的起始索引可以通过 `rs1` 指定的 `x` 寄存器中的无符号整数来指定，也可以通过一个 5 位的立即数来指定，并且该立即数会零扩展为 XLEN 位。如果 XLEN > SEW，偏移量不会被截断为 SEW 位。

----
  vslidedown 对于源元素的行为（对于滑动中的元素 i，`vstart` < `vl`）
                   0 <= i+OFFSET < VLMAX   src[i] = vs2[i+OFFSET]
               VLMAX <= i+OFFSET           src[i] = 0

  vslidedown 对于目标元素 i 的行为（对于滑动中的元素 i，`vstart` < `vl`）
                   0 <= i < vstart         不变
              vstart <= i < vl             如果 v0.mask[i] 使能则 vd[i] = src[i]
                  vl <= i < VLMAX          遵循尾部策略

----

===== 向量单元素向上滑动指令

提供了一些变体的滑动指令，它们每次只滑动一个元素，但也允许在空出的位置插入标量整数值。

----
 vslide1up.vx  vd, vs2, rs1, vm        # vd[0]=x[rs1], vd[i+1] = vs2[i]
----

`vslide1up` 指令将 x 寄存器的参数放置在目标向量寄存器组的第 0 位，前提是元素 0 是激活的，否则目标元素更新将按照当前的掩码无关/未干扰策略进行。如果 XLEN < SEW，值会被符号扩展到 SEW 位。如果 XLEN > SEW，最低有效的位将被复制，高于 SEW 的 XLEN-SEW 位将被忽略。

剩余的 `vl`-1 个激活元素（从源向量寄存器组的索引 i 到目标向量寄存器组的索引 i+1）会被复制过来。

`vl` 寄存器指定了从源值更新目标向量寄存器元素的最大数量，超过 `vl` 的剩余元素将根据当前的尾部策略处理（参见 <<sec-agnostic>>）。

----
   vslide1up behavior when vl > 0

                    i < vstart  不变
                0 = i = vstart  如果 v0.mask[i] 使能则 vd[i] = x[rs1] 
  max(vstart, 1) <= i < vl      如果 v0.mask[i] 使能则 vd[i] = vs2[i-1] 
              vl <= i < VLMAX   遵循尾部策略
----

`vslide1up` 指令要求目标向量寄存器组与源向量寄存器组不重叠，违背这一要求的指令编码是被保留的。

[[sec-vfslide1up]]
===== 向量浮点单元素向上滑动指令

----
 vfslide1up.vf vd, vs2, rs1, vm        # vd[0]=f[rs1], vd[i+1] = vs2[i]
----

`vfslide1up` 指令的定义类似于 `vslide1up`，但它的标量参数来自 `f` 寄存器。

===== 向量单元素向下滑动指令

`vslide1down` 指令将源向量寄存器组中从索引 _i_+1 开始的前 `vl`-1 个激活元素的值复制到目标向量寄存器组中的索引 _i_ 位置。

`vl` 寄存器指定了从源值更新目标向量寄存器元素的最大数量，超过 `vl` 的剩余元素将根据当前的尾部策略处理（参见 <<sec-agnostic>>）。

----
 vslide1down.vx  vd, vs2, rs1, vm      # vd[i] = vs2[i+1], vd[vl-1]=x[rs1]
----

`vslide1down` 指令将 `x` 寄存器的参数放置在目标向量寄存器的 `vl`-1 位置，前提是元素 `vl-1` 是激活的，否则目标元素更新将按照当前的掩码无关/未干扰策略进行。如果 XLEN < SEW，值会被符号扩展到 SEW 位。如果 XLEN > SEW，最低有效的位将被复制，高于 SEW 的 XLEN-SEW 位将被忽略。

----
   vslide1down 行为

                       i < vstart  不变
             vstart <= i < vl-1    如果 v0.mask[i] 使能则 vd[i] = vs2[i+1] 
             vstart <= i = vl-1    如果 v0.mask[i] 使能则 vd[vl-1] = x[rs1] 
                 vl <= i < VLMAX   遵循尾部策略
----

NOTE: `vslide1down` 指令可以用来将值加载到向量寄存器中，而无需使用内存，并且不会干扰其他向量寄存器。这为调试器提供了修改向量寄存器内容的路径，尽管速度较慢，需要多次重复调用 `vslide1down`。

[[sec-vfslide1down]]
===== 向量浮点单元素向上滑动指令

----
 vfslide1down.vf vd, vs2, rs1, vm      # vd[i] = vs2[i+1], vd[vl-1]=f[rs1]
----

`vfslide1down` 指令的定义类似于 `vslide1down`，但它的标量参数来自 f 寄存器。

==== 向量寄存器收集指令

向量寄存器收集指令从第一个源向量寄存器组读取元素，这些元素的位置由第二个源向量寄存器组给出。第二个向量中的索引值被视为无符号整数。源向量可以在任何索引 < VLMAX 处读取，而不考虑 `vl`。要写入目标寄存器的最大元素数由 `vl` 给出，超过 `vl` 的剩余元素将根据当前的尾部策略处理（参见 <<sec-agnostic>>）。该操作可以被屏蔽，并且对于未激活元素会遵循掩码无关/未干扰策略。

----
vrgather.vv vd, vs2, vs1, vm     # vd[i] = (vs1[i] >= VLMAX) ? 0 : vs2[vs1[i]];
vrgatherei16.vv vd, vs2, vs1, vm # vd[i] = (vs1[i] >= VLMAX) ? 0 : vs2[vs1[i]];
----

`vrgather.vv` 形式同时使用 SEW/LMUL 来处理数据和索引。`vrgatherei16.vv` 形式在 `vs2` 中使用 SEW/LMUL 来处理数据，而在 `vs1` 中使用 EEW=16 和 EMUL = (16/SEW)*LMUL 来处理索引。

NOTE: 当 SEW=8 时，`vrgather.vv` 只能引用向量元素 0-255。`vrgatherei16` 形式可以索引 64K 个元素，并且在 SEW > 16 时，也可以减少存储索引所需的寄存器容量。

如果元素索引超出范围（vs1[i] >= VLMAX），则返回该元素的值为零。

还提供了向量-标量和向量-立即数形式的寄存器收集指令。这些指令在给定索引处从源向量中读取一个元素，并将该值写入目标向量寄存器的激活元素中。标量寄存器中的索引值和立即数（零扩展为 XLEN 位）被视为无符号整数。如果 XLEN > SEW，索引值不会被截断为 SEW 位。

NOTE: 这些形式允许将任何向量元素“扩展”到整个向量。

----
vrgather.vx vd, vs2, rs1, vm  # vd[i] = (x[rs1] >= VLMAX) ? 0 : vs2[x[rs1]]
vrgather.vi vd, vs2, uimm, vm # vd[i] =  (uimm >= VLMAX)  ? 0 : vs2[uimm]
----

对于任何 `vrgather` 指令，目标向量寄存器组不能与源向量寄存器组重叠，违背这一要求的指令编码是被保留的。

==== 向量压缩指令

向量压缩指令允许从源向量寄存器组中，由向量掩码寄存器选中的元素被打包到目标向量寄存器组的起始位置，形成连续的元素。

----
vcompress.vm vd, vs2, vs1 # 将 vs2 中选择的元素压缩到 vd 中，vs1 启用的元素
----

由 `vs1` 指定的向量掩码寄存器指示应该从向量寄存器组 `vs2` 的前 `vl` 个元素中提取哪些元素，并将它们打包到目标向量寄存器 `vd` 的起始位置。目标向量寄存器 `vd` 中的剩余元素将根据当前的尾部策略处理（参见 <<sec-agnostic>>）。

----
    vcompress 指令的示例用法

        8 7 6 5 4 3 2 1 0   元素编号

        1 1 0 1 0 0 1 0 1   v0
        8 7 6 5 4 3 2 1 0   v1
        1 2 3 4 5 6 7 8 9   v2
                                vsetivli     t0, 9, e8, m1, tu, ma
                                vcompress.vm v2, v1, v0
        1 2 3 4 8 7 5 2 0   v2
----

`vcompress` 被编码为一个未掩码的指令（`vm=1`）。等效的掩码指令（`vm=0`）是保留的。

目标向量寄存器组不能与源向量寄存器组或源掩码寄存器重叠，违背这一要求的指令编码是被保留的。

`vcompress` 指令的异常总是报告 `vstart` 为 0。如果在非零 `vstart` 的情况下执行 `vcompress` 指令，则会引发非法指令异常。

NOTE: 虽然可能，但 `vcompress` 是少数几个较难在非零 `vstart` 的情况下重启的指令之一，因此假设实现通常会选择从元素 0 开始重启，而不是从非零的 `vstart` 开始。这意味着，`vstart` 之后的目标寄存器中的元素已经被更新。

===== 向量合成指令 `vdecompress`

没有提供逆向的 `vdecompress`，因为这个操作可以通过 iota 和一个掩码的 vrgather 来方便地合成：

----
    vdecompress 的期望功能
      7 6 5 4 3 2 1 0     # vid

            e d c b a     # 打包的5元素向量
      1 0 0 1 1 1 0 1     # 掩码向量，包含8个元素
      p q r s t u v w     # vdecompress 之前的目标寄存器

      e q r d c b v a     # vdecompress 的结果
----

----
     # v0 保存掩码
     # v1 保存打包的数据
     # v11 保存输入扩展向量和结果
     viota.m v10, v0                 # 计算 v0 中 mask 的 iota
     vrgather.vv v11, v1, v10, v0.t  # 在目标寄存器中扩展
----
----
   p q r s t u v w    # v11 目标注册
         e d c b a    # v1 源向量
   1 0 0 1 1 1 0 1    # v0 掩码向量

   4 4 4 3 2 1 1 0    # viota.m 的 v10 结果
   e q r d c b v a    # 使用 viota.m 在掩码下经过 vrgather 后的 v11 目标寄存器
----

==== 整个向量寄存器移动

`vmv<nr>r.v` 指令复制整个向量寄存器（即，所有 VLEN 位），并且可以复制整个向量寄存器组。操作码中的 nr 值指定要复制的独立向量寄存器的数量，即 NREG。指令的操作方式就像是 EEW=SEW，EMUL = NREG，实际长度 `evl`= EMUL * VLEN/SEW。

NOTE: 这些指令旨在帮助编译器在不需要知道或改变 `vl` 或 `vtype` 的情况下，进行向量寄存器的重新排列。

NOTE: 通常情况下，如果 `vstart` >= `vl`，则不会写入任何元素，但这些指令不适用这一规则。相反，如果 `vstart` >= `evl`，则不会写入任何元素。

NOTE: 如果 `vd` 等于 `vs2`，则该指令是一个空操作（NOP），但它作为对实现的提示，表示下一个对寄存器组的访问将使用与 SEW 相等的 EEW。

该指令被编码为 OPIVI 指令。要复制的向量寄存器数量编码在 simm 字段的最低三位（simm[2:0]），并且使用与内存指令的 nf[2:0] 字段相同的编码方式（参见 <<fig-nf>>），即 simm[2:0] = NREG-1。

NREG 的值必须为 1、2、4 或 8，并且 `simm[4:0]` 的值除了 0、1、3 和 7 之外都是保留的。

NOTE: 未来的扩展可能支持移动其他数量的寄存器。

NOTE: 该指令使用与 `vsmul` 指令相同的 funct6 编码，但带有立即数操作数，并且仅支持未掩码版本（`vm=1`）。此编码方式的选择是因为它接近于 `vmerge` 编码，并且不太可能 `vsmul` 指令会从立即数形式中受益。

----
    vmv<nr>r.v vd, vs2  # 通用形式

    vmv1r.v v1, v2   # 复制 v1 = v2
    vmv2r.v v10, v12 # 复制 v10 = v12；v11 = v13
    vmv4r.v v4, v8   # 复制 v4 = v8；v5 = v9；v6 = v10；v7 = v11
    vmv8r.v v0, v8   # 复制 v0 = v8；v1 = v9；...；v7 = v15
----

源向量寄存器和目标向量寄存器的编号必须与向量寄存器组的大小对齐，其他向量寄存器编号的编码是保留的。

NOTE: 未来的扩展可能会放宽向量寄存器对齐的限制

=== 异常处理

在向量指令的陷阱过程中（由同步异常或异步中断引起），现有的 *epc 控制状态寄存器会被写入指向触发陷阱的向量指令的指针，同时 `vstart` 控制状态寄存器包含发生陷阱时的元素索引。

NOTE: 我们选择添加一个 vstart 控制状态寄存器，以允许从部分执行的向量指令恢复，从而减少中断延迟并简化持续进展保证。这类似于 IBM 3090 向量
功能中的方案。为了确保在没有 vstart 控制状态寄存器的情况下前进，实施者必须保证整个向量指令总是能够原子性地完成，而不会触发陷阱。特别
是在有跨步或散播/聚集操作以及按需分页虚拟内存的情况下，确保这一点特别困难。

==== 精确向量陷阱

NOTE: 我们假设大多数具有按需分页的监控模式环境将需要精确的向量陷阱。

精确向量陷阱要求：

. 所有比触发陷阱的向量指令更老的指令必须已经提交了它们的结果。
. 所有比触发陷阱的向量指令更年轻的指令不应修改架构状态。
. 触发陷阱的向量指令中影响 vstart 控制状态寄存器中索引之前的元素的操作，必须已提交其结果。
. 触发陷阱的向量指令中影响 vstart 控制状态寄存器索引及之后的元素的操作，除非重新启动并完成受影响的向量指令仍然能够生成正确的最终状态，否则不应修改架构状态。

我们放宽了最后一条要求，允许在报告陷阱时 `vstart` 后面的元素已被更新，只要从给定的 `vstart` 重新执行该指令能正确覆盖这些元素。

在幂等内存区域中，向量存储指令可能已更新内存中超出引发同步陷阱元素的部分。对于非幂等内存区域，在向量存储指令引发同步陷阱时，索引等于或大于导致同步陷阱的元素的区域不得被更新。

除非上述特别说明，否则向量指令可以覆盖它们的输入，因此在大多数情况下，向量指令的重启必须从 vstart 元素索引开始。然而，也有一些情况下禁止这种覆盖，以便使向量指令的执行是幂等的，从而能够从更早的索引位置重新启动。

实施者必须确保 v`start` 报告的元素或段最终能够保证前进。

==== 不精确向量陷阱

不精确向量陷阱是指那些不精确的陷阱。特别地，比 *epc 更新的指令可能已提交结果，而比 *epc 更早的指令可能未完成执行。不精确陷阱主要用于那些报告错误并终止执行是适当响应的情况。

NOTE: 一个配置文件可能指定中断是精确的，而其他陷阱是不精确的。我们假设许多嵌入式实现会在发生致命错误时仅为向量指令生成不精确的陷阱，因为它们不需要可恢复的陷阱。

不精确陷阱应在同步向量异常引发的陷阱中报告 `vstart` 中的出错元素。

当前标准扩展中不支持不精确陷阱。

==== 可选择的精确/不精确陷阱

某些配置可能选择提供一个特权模式位，用于在精确和不精确的向量陷阱之间进行选择。不精确模式将以高性能运行，但可能使错误原因的辨别变得困难，而精确模式则运行较慢，但支持调试错误，尽管有可能无法遇到与不精确模式相同的错误。

该机制在当前标准扩展中没有定义。

==== 可交换陷阱

另一种陷阱模式可以支持向量单元中的可交换状态，其中在触发陷阱时，特殊指令可以保存和恢复向量单元的微体系结构状态，以便在不精确陷阱周围继续正确执行。

该机制在当前标准扩展中没有定义。

NOTE: 未来的扩展可能会定义一种标准方式来保存和恢复向量单元实现中的非透明微体系结构状态，以支持在不精确陷阱情况下的上下文切换。

[[sec-vector-extensions]]
=== 标准向量扩展

本节描述了标准向量扩展。用于嵌入式用途的一组较小扩展以“Zve”前缀命名，而为应用处理器设计的较大向量扩展则命名为单字母的 V 扩展。还提供了一组带有“Zvl”前缀的向量长度扩展名称。

初始向量扩展旨在作为各种领域（包括加密和机器学习）中其他向量扩展的基础。

==== Zvl*：最小向量长度标准扩展

所有标准向量扩展都有一个最低要求的 VLEN，如下所述。提供了一组向量长度扩展，用于增加向量扩展的最小向量长度。

NOTE: 向量长度扩展可以用于指定额外的软件或体系结构配置要求，或者用于展示硬件能力。

.向量长度扩展
[cols="1,1"]
[%autowidth,float="center",align="center",options="header"]
|===
| 扩展        | 最小 VLEN

| Zvl32b     | 32
| Zvl64b     | 64
| Zvl128b    | 128
| Zvl256b    | 256
| Zvl512b    | 512
| Zvl1024b   | 1024
|===

NOTE: 更长的向量长度扩展应遵循相同的模式。

NOTE: 每个向量长度扩展实际上包含所有较短的向量长度扩展。

NOTE: 扩展名称的语法正在修订，这些名称可能会发生变化。尾部的“b”将用于区分数值字段和版本号。

NOTE: 对于任何标准向量扩展来说，并不要求显式使用 Zvl32b 扩展字符串，因为它们都有效地要求至少有此最小值，但该字符
串在说明硬件功能时可能很有用。

==== Zve*: 嵌入式处理器的向量扩展
以下五个标准扩展提供了不同程度的向量支持，旨在与嵌入式处理器一起使用。任何这些扩展可以添加到 XLEN=32 或 XLEN=64
的基本 ISA 中。表中列出了每个扩展的最小 VLEN、支持的 EEW 以及支持的浮点类型。

.嵌入式向量扩展
[cols="1,1,2,1,1"]
[%autowidth,float="center",align="center",options="header"]
|===
| 扩展 | 最小的 VLEN | 支持的 EEW  |  FP32 | FP64

| Zve32x    | 32    | 8, 16, 32     |   N   |  N
| Zve32f    | 32    | 8, 16, 32     |   Y   |  N
| Zve64x    | 64    | 8, 16, 32, 64 |   N   |  N
| Zve64f    | 64    | 8, 16, 32, 64 |   Y   |  N
| Zve64d    | 64    | 8, 16, 32, 64 |   Y   |  Y
|===

Zve32f 和 Zve64x 扩展依赖于 Zve32x 扩展。
Zve64f 扩展依赖于 Zve32f 和 Zve64x 扩展。
Zve64d 扩展依赖于 Zve64f 扩展。

所有 Zve* 扩展都支持精确陷阱。

NOTE: 目前没有标准支持处理不精确的陷阱，因此标准扩展必须提供精确的陷阱。

所有 Zve* 扩展都支持 EEW 为 8、16 和 32，Zve64* 扩展还支持 EEW 为 64。

所有 Zve* 扩展都支持向量配置指令（<<sec-vector-config>>）。

所有 Zve* 扩展都支持所有向量加载和存储指令（<<sec-vector-memory>>），除了在 XLEN=32 时，Zve64* 扩展不支持索引值为 EEW=64。

所有 Zve* 扩展都支持所有向量整数指令（<<sec-vector-integer>>），但对于 EEW=64，Zve64* 不包括返回乘积高字的 vmulh 整数乘法变体（vmulh.vv、vmulh.vx、vmulhu.vv、vmulhu.vx、vmulhsu.vv、vmulhsu.vx）。

NOTE: 产生乘积的高字可能需要大量额外的逻辑，对于较大的 EEW，这可能会增加很多门电路。

所有 Zve* 扩展都支持所有向量定点运算指令（<<sec-vector-fixed-point>>），但在 Zve64* 中，EEW=64 时不包括 vsmul.vv 和 vsmul.vx。

NOTE: 与 vmulh 类似，vsmul 也需要大量额外的逻辑，且 64 位定点乘法相对较少见。

所有 Zve* 扩展都支持所有向量整数单宽度和扩展宽度的规约操作（<<sec-vector-integer-reduce>> 节，<<sec-vector-integer-reduce-widen>> 节）。

所有 Zve* 扩展都支持所有向量掩码指令（<<sec-vector-mask>> 节）。

所有 Zve* 扩展都支持所有向量置换指令（<<sec-vector-permute>>），但 Zve32x 和 Zve64x 不包括带有浮点操作数的置换指令，Zve64f 不包括带有 EEW=64 浮点操作数的置换指令。

Zve32x 扩展依赖于 Zicsr 扩展。Zve32f 和 Zve64f 扩展依赖于 F 扩展，并实现所有用于浮点操作数的向量浮点指令（第 <<sec-vector-float>> 节），支持 EEW=32的浮点操作数。对于 EEW=32，支持向量单宽度浮点减法操作（<<sec-vector-float-reduce>>）。

Zve64d 扩展依赖于 D 扩展，并实现所有用于浮点操作数的向量浮点指令（<<sec-vector-float>>），支持 EEW=32 或 EEW=64 的浮点操作数（包括扩展指令以及 FP32 与 FP64 之间的转换）。支持 EEW=32 和 EEW=64 的向量单宽度浮点减法操作（<<sec-vector-float-reduce>>），以及从 FP32 到 FP64 的扩展减法操作。

==== V扩展：面向应用处理器的向量扩展

单字母 V 扩展适用于应用处理器配置。

misa中的 misa.v 置位支持 V 扩展。

V 向量扩展支持精确异常。

V 扩展依赖于 Zvl128b 和 Zve64d 扩展。
NOTE: VLEN=128 是应用处理器的折中选择：更大的 VLEN 可在某些短向量情况下避免分块代码。但同时增加了最小实现的规模。使用更大的 LMUL 可避免分块，但会减少可用的向量寄存器组：例如，LMUL=8 时，最多可处理 16 个 64 位元素的向量，无需分块，但仅能使用 4 组向量寄存器。

V 扩展支持 EEW 取值 8、16、32 和 64。

V 扩展支持向量配置指令（见 <<sec-vector-config>>）。

V 扩展支持所有向量加载/存储指令（见 <<sec-vector-memory>>），但当 XLEN=32 时，不支持索引值的 EEW=64。

V 扩展支持所有向量整数指令（见 <<sec-vector-integer>>）。

V 扩展支持所有向量定点算术指令（见 <<sec-vector-fixed-point>>）。

V 扩展支持所有向量整数单宽与加宽归约操作（见 <<sec-vector-integer-reduce>>，<<sec-vector-integer-reduce-widen>>）。

V 扩展支持所有向量掩码指令（见 <<sec-vector-mask>>）。

V 扩展支持所有向量置换指令（见 <<sec-vector-permute>>）。

V 扩展依赖 F 和 D 扩展，并实现所有向量浮点指令（见 <<sec-vector-float>>），适用于 EEW=32 或 EEW=64 的浮点操作数（包括加宽指令以及 FP32 与 FP64 之间的转换）。支持 EEW=32 和 EEW=64 的单宽浮点归约（见 <<sec-vector-float-reduce>>），以及 FP32 到 FP64 的加宽归约。


[NOTE]
====
与其他 RISC-V 扩展一样，可以在同一 ISA 字符串中包含重叠的扩展。例如，RV64GCV 和 RV64GCV_Zve64f 都是有效且等效的 ISA 字符串，RV64GCV_Zve64f_Zve32x_Zvl128b 也是有效的。
====

==== Zvfhmin：最小半精度浮点向量扩展

Zvfhmin 扩展提供对 IEEE 754-2008 binary16 向量的最小支持，添加了 binary16 和 binary32 之间的转换指令。当实现 Zvfhmin 扩展时，在 SEW=16 时 vfwcvt.f.f.v 和 vfncvt.f.f.w 指令将被定义。这些指令的 EEW=16 浮点操作数采用 binary16 格式。

Zvfhmin 扩展依赖于 Zve32f 扩展。

==== Zvfh：半精度浮点向量扩展

Zvfh 扩展提供对 IEEE 754-2008 binary16 向量的支持。
当实现 Zvfh 扩展时，在 SEW=16 时，以下章节中的所有指令将被定义：
<<sec-vector-float>>，<<sec-vector-float-reduce>>，<<sec-vector-float-reduce-widen>>，<<sec-vector-float-move>>，
<<sec-vfslide1up>> 和 <<sec-vfslide1down>>。
这些指令的 EEW=16 浮点操作数采用 binary16 格式。

此外，Zvfh 扩展提供 8 位整数与 binary16 之间的转换：浮点到整数的窄化转换（vfncvt[.rtz].x[u].f.w）和 整数到浮点的加宽转换（vfwcvt.f.x[u].v）： 这些指令在 SEW=8 时被定义。

Zvfh 扩展依赖于 Zve32f 和 Zfhmin 扩展。

NOTE: 要求基本的标量半精度支持使得 Zvfh 的向量-标量指令更具实用性。我们曾考虑要求更完整的标量半精度支持，但我们认为，对于许多半精度向量工作负载而言，在单精度下执行标量计算已经足够。

=== 向量指令列表

include::images/wavedrom/v-inst-table.adoc[]

