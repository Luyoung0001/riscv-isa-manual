[[atomics]]
== “A”扩展：原子指令，版本 2.1

“A”扩展，即原子指令扩展，包含了原子性地读-改-写内存的指令，以支持在同一内存空间中运行的多个 RISC-V 硬件线程之间的同步。提供的两种原子指令形式是加载保留/存储条件指令和原子取值并操作内存指令。这两种类型的原子指令支持多种内存一致性排序，包括无序、获取、释放和顺序一致语义。这些指令使 RISC-V 能够支持 RCsc 内存一致性模型。cite:[Gharachorloo90memoryconsistency]

[NOTE]
====
经过深入的探讨，语言社区和架构社区似乎最终倾向于将释放一致性模型作为标准的内存一致性模型。因此，RISC-V 的原子操作支持也是围绕此模型构建的。
====

A 扩展包括 Zaamo 扩展和 Zalrsc 扩展所提供的指令。

=== 用于确定访问顺序的原子指令

基准 RISC-V ISA 采用弱内存模型，使用 FENCE 指令来施加额外的顺序约束。地址空间由执行环境划分为内存域和 I/O 域，FENCE 指令允许对这两个地址域的访问进行顺序控制。

为了更高效地支持释放一致性 cite:[Gharachorloo90memoryconsistency]，每条原子指令都配备了 _aq_ 和 _rl_ 位，用于在其他 RISC-V 硬件线程的视角下，指定额外的内存顺序约束。这两位用于控制原子指令所访问的地址域（内存或 I/O）的访问顺序。对于访问另一域的操作，则不施加任何顺序约束。若需要在不同域之间强制顺序，则应使用 FENCE 指令。

如果两个位都未设置，则不会对原子内存操作施加额外的顺序约束。如果仅设置了 _aq_ 位，则原子内存操作被视为获取（acquire）访问，即在此 RISC-V 硬件线程上，任何后续内存操作都不能被观察到发生在获取内存操作之前。如果仅设置了 _rl_ 位，则原子内存操作被视为释放（release）访问，即释放内存操作不能被观察到发生在此 RISC-V 硬件线程上的任何先前内存操作之前。如果同时设置了 _aq_ 和 _rl_ 位，则原子内存操作是顺序一致（sequentially consistent）的，并且不能被观察到发生在任何先前内存操作之前或任何后续内存操作之后，且作用于相同地址域的内存操作。

[[sec:lrsc]]
=== “Zalrsc”扩展：用于 Load-Reserved/Store-Conditional 指令

include::images/wavedrom/load-reserve-st-conditional.adoc[]

对单个内存字或双字的复杂原子内存操作，RISC-V 提供了加载预留 (LR) 和条件存储 (SC) 指令来实现。LR.W 从 _rs1_ 指定的内存地址加载一个字，将符号扩展后的值放入 _rd_，并注册一个预留集——该集合包含了被寻址字所覆盖的所有字节。SC.W 条件性地将 _rs2_ 中的字写入 _rs1_ 中的地址：只有当预留仍然有效且预留集包含正在写入的字节时，SC.W 才会成功。如果 SC.W 成功，指令将 _rs2_ 中的字写入内存，并将零写入 _rd_。如果 SC.W 失败，指令不写入内存，并将非零值写入 _rd_。出于保护内存的考虑，执行失败的 SC.W 指令可以被视为一次存储操作。无论执行成功与否，执行 SC.W 指令都会使该硬件线程持有的任何预留失效。LR.D 和 SC.D 对双字执行类似操作，但仅在 RV64 上可用。对于 RV64，LR.W 和 SC.W 指令均会对其置入 rd 寄存器的值进行符号扩展。

[NOTE]
====
比较并交换（CAS）和 LR/SC 都可以用来构建无锁数据结构。经过广泛讨论，我们选择了 LR/SC，原因有以下几点：1）CAS 存在 ABA 问题，而 LR/SC 通过监控对地址的所有写入来避免这个问题，而不仅仅检查数据值的变化；2）CAS 还需要一种新的整数指令格式来支持三个源操作数（地址、比较值、交换值），以及不同的内存系统消息格式，这会使微架构变得更加复杂；3）此外，为了避免 ABA 问题，其他系统提供了双字 CAS（DW-CAS），允许在测试和增加计数器的同时操作数据字。这需要在一条指令中读取五个寄存器并写入两个寄存器，还需要一个新的更大的内存系统消息类型，进一步增加了实现的复杂性；4）LR/SC 提供了更高效的许多原语的实现，因为它只需要一个加载，而 CAS 需要两个加载（在 CAS 指令前进行一次加载以获取用于投机计算的值，然后在 CAS 指令中进行第二次加载，检查值是否未更改，然后再进行更新）。

LR/SC 相比于 CAS 的主要缺点是活锁（livelock），我们在特定情况下通过架构层面保证最终的持续进展来避免活锁，具体内容如下。另一个问题是当前 x86 架构的影响，尤其是其对双字 DW-CAS 的依赖，是否会使同步库和假定 DW-CAS 为基本机器原语的其他软件的移植工作变得复杂。一个可能的缓解因素是最近 x86 添加了事务性内存指令，这可能会导致从 DW-CAS 向其他方法的转变。

一般来说，多字原子操作是理想的，但关于其应采取何种形式仍存在相当大的争议，而且保证持续进展会增加系统的复杂性。

====

值为 1 的错误代码表示 UNSPECIFIED 的错误。目前，其他错误代码被保留。可移植软件应仅假设错误代码将是非零值。

[NOTE]
====
我们保留了错误代码 1 表示 “UNSPECIFIED”，以便简单的实现可以使用现有的多路复用器（mux）返回该值，该多路复用器是 SLT/SLTU 指令所需的。未来版本或 ISA 扩展中可能会定义更具体的错误代码。
====

对于 LR 和 SC，Zalrsc 扩展要求 _rs1_ 中的地址与操作数的大小自然对齐（即，对于双字，需要 8 字节对齐，对于字，需要 4 字节对齐）。如果地址没有自然对齐，将会生成地址未对齐异常或访问故障异常。如果内存访问因对齐问题无法完成，而该未对齐的访问不应被模拟，则会生成访问故障异常。
[NOTE]
====
在大多数系统中，模拟未对齐的 LR/SC 序列是不可行的。

未对齐的 LR/SC 序列还会带来同时访问多个保留集的可能性，而目前的定义并未考虑这种情况。

====

实现可以在每个 LR 上注册一个任意大的保留集，前提是保留集包含所访问的数据字或双字的所有字节。SC 只能与程序顺序中的最近 LR 配对。SC 只有在以下条件下才可能成功：没有观察到来自其他硬件线程的存储操作发生在 LR 和 SC 之间，并且在 LR 和 SC 之间没有其他 SC 指令。SC 只有在以下条件下才可能成功：没有观察到来自硬件线程以外的设备对 LR 指令访问的字节的写入发生在 LR 和 SC 之间。请注意，这个 LR 可能具有不同的有效地址和数据大小，但仍然将 SC 的地址作为保留集的一部分进行保留。

[NOTE]
====
遵循此模型，在具有内存地址转换的系统中，如果先前执行的 LR 指令使用具有不同虚拟地址的别名保留了相同的位置，则 SC 允许成功；但如果虚拟地址不同，SC 也允许失败。

为了兼容旧设备和总线，除了 RISC-V 硬件线程之外的设备写入仅在它们访问的字节与 LR 访问的字节重叠时才需要使保留无效。当它们访问保留集中的其他字节时，这些写入不需要使保留无效。
====

如果目标地址不在程序顺序中最近的 LR 的预留集内，则 SC 必须执行失败。如果在 LR 和 SC 指令之间，可以观测到来自另一硬件线程对预留集的存储操作，SC 指令必须执行失败。如果在 LR 和 SC 指令之间，可以观测到来自其他设备对 LR 指令访问字节的写操作，SC 指令必须执行失败。（如果该设备写入了预留集，但并未写入 LR 指令访问的字节，则 SC 可能成功，也可能失败。）如果在程序顺序中，LR 和 SC 指令之间存在另一条 SC 指令（无论目标地址为何），SC 指令必须执行失败。成功完成的 LR/SC 指令序列的原子性需求，其精确定义见 <<rvwmo>> 中的原子性公理（Atomicity Axiom）。



[NOTE]
====
平台应提供一种机制来确定预留集的大小和形状。

平台规范可能会限制预留集的大小和形状。

应使用 SC 指令对内存中的空闲字进行操作，以强制撤销任何现有的加载预留：

* 在抢占式上下文切换时
* 必要时，在更改虚拟地址到物理地址的映射时，例如，当迁移可能包含活动预留的页面时。

当硬件线程执行 LR 或 SC 指令时，预留的无效化意味着硬件线程一次只能持有一个预留，并且 SC 只能与最近的 LR 配对，LR 只能与紧随其后的 SC 配对，按程序顺序排列。这是对 <<rvwmo>> 中原子性公理（Atomicity Axiom）的一项约束，旨在确保软件在符合手册预期的常见实现上能够正确运行。

====

在另一个 RISC-V 硬件线程观察到 SC 指令之前，必须先执行建立预留的 LR 指令。

[NOTE]
====
通过在 LR 指令上设置 _aq_ 位，可以使 LR/SC 序列具有获取语义（acquire semantics）。通过在 SC 指令上设置 _rl_ 位，可以使 LR/SC 序列具有释放语义（release semantics）。假设其他原子操作有合适的映射，在 LR 指令上设置 _aq_ 位，并在 SC 指令上设置 _rl_ 位，使得 LR/SC 序列在 Cpp 的 `memory_order_seq_cst` 意义下是顺序一致的（sequentially consistent）。这样的序列不会充当屏障（fence）来排序序列前后普通的加载和存储指令。对于其他 Cpp 原子操作的具体指令映射，或者更强的 “顺序一致性” 概念，可能要求在 LR 或 SC 指令的任意一条或两条上都设置这两个位。

如果在 LR 或 SC 上都没有设置 _aq_ 和 _rl_ 位，则可以观测到 LR/SC 序列与同一 RISC-V 硬件线程发出的周围内存操作，在执行顺序上互不约束。当 LR/SC 序列用于实现并行归约操作时，这是一种合理的选择。
====

软件不应在 LR 指令上设置 _rl_ 位，除非同时设置 _aq_ 位；同样，软件也不应在 SC 指令上设置 _aq_ 位，除非同时设置 _rl_ 位。LR._rl_ 和 SC._aq_ 指令并不保证提供比两个位都未设置时更强的排序，这可能会导致性能降低。

<<<

[[cas]]
[source,asm]
.使用 LR/SC 的比较并交换函数示例代码。
        # a0 寄存器存储内存地址
        # a1 寄存器存储期望值
        # a2 寄存器存储目标值
        # a0 寄存器存储返回值，0 表示成功，非 0 表示失败
    cas:
        lr.w t0, (a0)        # 加载初始值。
        bne t0, a1, fail     # 值不匹配，因此失败。
        sc.w t0, a2, (a0)    # 尝试更新。
        bnez t0, cas         # 如果条件存储失败，则重试。
        li a0, 0             # 设置返回值为成功。
        jr ra                # 返回。
    fail:
        li a0, 1             # 设置返回值为失败。
        jr ra                # 返回。

LR/SC 可以用于构造无锁数据结构。一个使用 LR/SC 实现比较并交换（compare-and-swap）功能的示例显示在 <<cas>> 中。如果内联实现，比较并交换功能仅需四条指令。

[[sec:lrscseq]]
=== 存储条件指令的最终成功

Zalrsc 扩展定义了受限的 LR/SC 循环，其具有以下特点：

* 循环仅包含一个 LR/SC 序列和在失败时重试该序列的代码，且最多只能包含 16 条指令，这些指令必须按顺序放置在内存中。
* 一个 LR/SC 序列以 LR 指令开始，以 SC 指令结束。在 LR 和 SC 指令之间执行的动态代码只能包含基准 “I” 指令集中的指令，不包括加载、存储、向后跳转、被执行的向后分支、JALR、FENCE 和 SYSTEM 指令。如果支持 “C” 扩展，则也允许上述 “I” 指令的压缩形式。
* 重试失败的 LR/SC 序列的代码可以包含向后跳转和/或分支以重复执行 LR/SC 序列，但除此之外，其约束与 LR 和 SC 之间的代码相同。
* LR 和 SC 的地址必须位于具有 LR/SC 最终性属性的内存区域内。执行环境负责通知哪些区域具有该属性。
* SC 必须针对相同的有效地址，并且数据大小与同一硬件线程执行的最新 LR 相同。

不位于受限 LR/SC 循环中的 LR/SC 序列是不受约束的。不受约束的 LR/SC 序列可能在某些实现上某些尝试成功，但在其他实现上可能永远不会成功。

[NOTE]
====
我们将 LR/SC 循环的长度限制为在基础 ISA 中适配 64 字节连续指令，以避免对指令缓存和 TLB 大小及关联性的过度限制。同样，我们禁止在循环内执行其他加载和存储操作，以避免对简单实现中私有缓存中跟踪保留集的数据缓存关联性产生限制。对分支和跳转的限制则限制了序列中可以花费的时间。为了简化操作系统对缺乏适当硬件支持的实现的指令的模拟，浮点运算和整数乘法/除法被禁止。

软件并不禁止使用不受限的 LR/SC 序列，但可移植的软件必须检测到该序列反复失败的情况，然后回退到不依赖于不受约束的 LR/SC 序列的替代代码序列。实现允许在任何不受限的 LR/SC 序列上无条件失败。
====
如果一个硬件线程 H 进入一个受限的 LR/SC 循环，执行环境必须保证最终发生以下事件之一：

* _H_ 或其他硬件线程执行一个成功的 SC 指令，且该 SC 指令操作的是 H 的受限 LR/SC 循环中的预留集。
* 其他硬件线程执行一个无条件的存储或原子内存操作（AMO）指令，且该指令操作的是 _H_ 的受限 LR/SC 循环中的预留集合，或者系统中的其他设备向该预留集写入数据。
* _H_ 执行一个跳转或分支，退出受限 LR/SC 循环。
* _H_ 触发陷阱。

[NOTE]
====
请注意，这些定义允许在实现中 SC 指令因任何原因偶尔失败，只要上述保证没有被违反。

由于要保证最终的结构，如果某些硬件线程在执行受限的 LR/SC 循环，并且在执行环境中没有其他硬件线程或设备对该保留集执行无条件存储或 AMO 操作，那么至少有一个硬件线程最终会退出其受限的 LR/SC 循环。相反，如果其他硬件线程或设备继续写入该保留集，则无法保证任何硬件线程会退出其 LR/SC 循环。

加载和 LR 指令本身不会妨碍其他硬件线程的 LR/SC 序列进展。请注意，这一约束意味着，加载和 LR 指令的执行（可能发生在同一个核心内的其他硬件线程中）不会无限期地妨碍 LR/SC 的进展。例如，由于另一个硬件线程共享缓存而导致的缓存驱逐，不能无限期地妨碍 LR/SC 的进展。通常，这意味着预留操作会独立于任何共享缓存的驱逐进行跟踪。同样，由硬件线程内部的推测执行引起的缓存未命中，也不能无限期地妨碍 LR/SC 的进展。

这些定义允许 SC 指令因实现原因而偶尔虚假的发生了失败，只要最终能够继续进行下去。

CAS 的一个优势是，它保证某个硬件线程最终会取得进展，而 LR/SC 原子序列在某些系统上可能会无限期地发生活锁。为了避免这个问题，我们为某些 LR/SC 序列添加了活锁自由的架构保证。

早期版本的规范强制要求提供更严格的饥饿自由（starvation-freedom）保证。然而，较弱的无活锁（livelock-freedom）保证已足以支持 C11 和 C++11 语言的实现，并且在某些微架构风格中提供这一保证要简单得多。

====

[[sec:amo]]
=== “Zaamo”扩展：原子内存操作

include::images/wavedrom/atomic-mem.adoc[]

原子内存操作（AMO）指令执行用于多处理器同步的读-改-写操作，并采用 R 型指令格式编码。这些 AMO 指令会以原子方式从寄存器 _rs1_ 指定的地址加载数据值，将该值存入寄存器 _rd_ 中。随后，对刚加载的值与 _rs2_ 中的初始值应用二进制运算符，并将运算结果存回 _rs1_ 指定的初始内存地址。AMO 指令可以操作内存中的双字（仅限 RV64）或单字。对于 RV64，32 位 AMO 总是对其置入 _rd_ 的值进行符号扩展，并忽略 _rs2_ 初始值的高 32 位。

对于 AMO 指令，Zaamo 扩展要求寄存器 _rs1_ 中保存的地址，必须按照操作数大小进行自然对齐（例如，双字需 8 字节对齐，单字需 4 字节对齐）。如果地址未按自然边界对齐，则会触发地址未对齐异常或访问故障异常。当内存访问原本可以成功完成，但因未对齐而无法完成，且该未对齐访问不应被模拟时，便会触发访问故障异常。

本手册第二卷定义的 “未对齐原子性粒度 PMA” 机制，可选择性地放宽上述对对齐的要求。一旦启用 PMA，它将指定一个未对齐原子性粒度的大小，该粒度大小必须是 2 的幂次方字节数。未对齐原子性粒度 PMA 机制仅适用于以下指令集：AMO 指令、基本 ISA 中定义的加载和存储指令，以及F、D 和 Q 扩展中定义的、操作数大小不超过 XLEN 位的加载和存储指令。对于属于上述指令集的指令，如果其所有访问的字节都落在同一个未对齐原子性粒度所覆盖的范围内，则该指令将不会因地址对齐问题而触发异常，并且在 RVWMO 内存模型下，该指令将仅产生一次内存操作——换言之，它将以原子方式执行。

支持的操作包括交换、整数加法、按位与、按位或、按位异或，以及有符号和无符号整数的最大值和最小值。在没有顺序约束的情况下，这些 AMO 操作可以用于实现并行归约操作，在这种情况下，返回值通常会通过写入 x0 来丢弃。

[NOTE]
====
我们提供了取值并操作（fetch-and-op）风格的原子操作（AMO），因为它们比 LR/SC 或 CAS 更适用于高并发系统。一个简单的微架构可以通过使用 LR/SC 原语来实现 AMO ，前提是该实现能够保证 AMO 最终完成。更复杂的实现可能还会在内存控制器中实现 AMO，并可以在目标是 x0 时优化掉获取初始值的操作。

AMO 的操作集被选择为高效支持 C11/C++11 的原子内存操作，并且能够支持内存中的并行归约操作。AMO 的另一个用途是在 I/O 空间内为内存映射的设备寄存器提供原子更新（例如，设置、清除或切换位）。

Zaamo 扩展使得微控制器类的实现能够利用 A 扩展中的 AMO 子集提供的原子原语。通常，这类实现没有缓存，因此可能无法自然地支持 Zalrsc 扩展提供的 LR/SC 指令。
====

为了帮助实现多处理器同步，AMO 可选地提供释放一致性语义。如果设置了 _aq_ 位，则在此 RISC-V 内核中，任何后续的内存操作都不能在 AMO 之前被观察到。相反，如果设置了 _rl_ 位，则其他 RISC-V 内核不会在此内核的 AMO 之前观察到 AMO ，且 AMO 之前的内存访问会先于 AMO 被观察到。将 _aq_ 和 _rl_ 位都设置在 AMO 上，使得该序列具有顺序一致性，意味着它不能与同一内核的早期或晚期内存操作重排序。

[NOTE]
====
AMO 被设计为高效地实现 C11 和 C++11 的内存模型。尽管 FENCE R、RW 指令足以实现 acquire 操作，FENCE RW、W 指令足以实现 release 操作，但与设置了相应 _aq_ 或 _rl_ 位的 AMO 相比，这两者都会引入额外的不必要的排序。
====

一个使用测试-测试-设置自旋锁保护的临界区的示例代码序列显示在示例 <<critical>>中。请注意，第一个 AMO 被标记为 _aq_，用于在进入临界区之前对锁的获取进行排序，而第二个 AMO 被标记为 _rl_，用于在锁释放之前对临界区的操作进行排序。

<<<

[[critical]]
[source,asm]
.互斥示例代码。锁地址在 a0 中。
        li           t0, 1        # 初始化交换值为 1。
    again:
        lw           t1, (a0)     # 检查锁是否被持有。
        bnez         t1, again    # 如果已被持有，则重试。
        amoswap.w.aq t1, t0, (a0) # 尝试获取锁。
        bnez         t1, again    # 如果已被持有，则重试。
        # ...
        # 临界区。
        # ...
        amoswap.w.rl x0, x0, (a0) # 通过存储 0 来释放锁。

[NOTE]
====
我们建议使用上面展示的 AMO Swap 范式来实现锁的获取和释放，以简化推测性锁消除（speculative lock elision）的实现。cite:[Rajwar:2001:SLE]
====

[NOTE]
====
“A” 扩展中的指令可以用于提供顺序一致性的加载和存储，但这会比必要的更严格地限制硬件对内存访问的重排序。C++ 顺序一致性的加载可以通过设置 _aq_ 位的 _LR_ 指令来实现。然而，_LR/SC_ 的最终成功保证可能会减慢来自相同有效地址的并发加载。顺序一致性的存储可以通过一个 AMOSWAP 指令来实现，该指令将旧值写入 `x0` 并设置 _rl_ 位。然而，不必要的加载可能会引入不必要的排序约束，在这个例子中并不需要。特定的编译约定可能要求在 LR 和 AMOSWAP 指令中设置 _aq_ 和 _rl_ 位，或者两者都设置。
====
