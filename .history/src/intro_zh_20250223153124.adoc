== 引言


RISC-V（发音为“risk-five”）是一种新的指令集架构（ISA），最初的设计目的是支持计算机架构的研究和教育，但我们希望它也能成为工业实现中的一个标准化、免费且开放的架构。我们在定义 RISC-V 时的目标包括：

* 一个完全开放的 ISA，提供给学术界和工业界自由使用。
* 一个实际可用的 ISA，适用于直接的原生硬件实现，而不仅仅是用于模拟或二进制翻译。
* 一个能够避免针对特定微架构风格（例如微编码、顺序执行、解耦、乱序执行）或实现技术（例如全定制、ASIC、FPGA）“过度设计” 的 ISA，同时允许在任何这些技术中进行高效实现。
* 一个由精简的基础整数 ISA 和可选标准扩展组成的 ISA。基础整数 ISA 可单独用作定制加速器的基础或用于教学目的，而可选扩展则支持通用软件开发。
* 支持 2008 年修订版的 IEEE-754 浮点标准。cite:[ieee754-2008]
* 一个支持广泛 ISA 扩展和专用变体的 ISA。
* 为应用程序、操作系统内核和硬件实现提供 32 位和 64 位地址空间变体。
* 一个支持高度并行的多核或众核集群实现（包括异构多处理器）的 ISA。
* 可选的可变长度指令，既可以扩展可用的指令编码空间，也可以通过可选的紧凑指令编码来提升性能、减少静态代码大小并提高能效。
* 一个完全可虚拟化的 ISA，以简化虚拟机管理程序（Hypervisor）的开发。
* 一个简化了新型特权架构设计实验的 ISA。

[TIP]
====
关于我们设计决策的注释会像本段落这样格式化。如果读者只对规范本身感兴趣，可以跳过这些非规范性内容。
====

[NOTE]
====
RISC-V 这个名称的选择是为了代表加州大学伯克利分校设计的第五代主要 RISC 指令集架构（RISC-I cite:[riscI-isca1981]、RISC-II cite:[Katevenis:1983]、SOAR cite:[Ungar:1984] 和 SPUR cite:[spur-jsscc1989] 是前四代）。我们还巧妙地利用了罗马数字 "V" 的双关意义，既表示 "变体"（variations）也表示 "向量"（vectors），因为支持各种架构研究（包括不同的数据并行加速器）是该指令集架构设计的明确目标。
====
(((ISA, definition)))
RISC-V ISA 的定义尽量避免涉及实现细节（尽管其中包含了关于实现驱动决策的注释）。这些定义应被理解为适用于多种实现的软硬件可见接口，而不是特定硬件设计的说明。RISC-V 手册分为两卷。本卷描述了基础的 非特权 指令设计，包括可选的非特权 ISA 扩展。非特权指令是指通常情况下在所有特权架构的所有特权模式中都可用的指令，但是其行为可能会因特权模式和特权架构的不同而有所变化。第二卷则提供了第一版（“经典”）特权架构的设计。手册采用 IEC 80000-13:2008 标准，其中一个字节等于 8 位。

[TIP]
====
在非特权 ISA 设计中，我们尽量去除对特定微架构特性的依赖（例如缓存行大小），以及对特权架构细节的依赖（例如页表翻译）。这样做的目的是为了简化设计，并为其他微架构或特权架构提供最大的灵活性。
====

=== RISC-V 硬件平台术语


一个 RISC-V 硬件平台可以包含一个或多个兼容 RISC-V 的处理核心，以及其他非 RISC-V 兼容的核心、固定功能的加速器、各种物理内存结构、I/O 设备，以及允许这些组件通信的互连结构。
(((core, component)))

如果一个组件包含独立的指令获取单元，则称其为核心 (core)。一个兼容 RISC-V 的核心可能通过多线程支持多个与 RISC-V 兼容的硬件线程，或称为 hart。(译注：除本章外，hart 将被统一翻译为硬件线程)
(((core, extensions, coprocessor)))

一个 RISC-V 核心可能具有额外的专用指令集扩展或一个附加的协处理器 (coprocessor)。我们使用“协处理器”这个术语来指代连接到 RISC-V 核心的单元，它主要由 RISC-V 指令流控制，但包含额外的体系结构状态和指令集扩展，并可能相对于主要 RISC-V 指令流具有一定的有限自主性。

我们使用“加速器” (accelerator) 一词来指代非可编程的固定功能单元，或能够自主运行但专用于特定任务的核心。在 RISC-V 系统中，我们预计许多可编程加速器将是基于 RISC-V 的核心，并具有专用指令集扩展和/或定制的协处理器。RISC-V 加速器中一个重要的类别是 I/O 加速器，它们将 I/O 处理任务从主应用核心中卸载，以减轻核心负担。
(((core, accelerator)))

一个 RISC-V 硬件平台的系统级组织可以从单核微控制器扩展到拥有成千上万节点的共享内存众核服务器集群。即使是小型片上系统（SoC），也可能通过多计算机和/或多处理器的分层结构进行模块化开发，或者在子系统之间提供安全隔离。
(((core, cluster, multiprocessors)))

=== RISC-V 软件执行环境和硬件线程


RISC-V 程序的行为取决于其运行的执行环境。RISC-V 执行环境接口（Execution Environment Interface，简称 EEI）定义了程序的初始状态、环境中 harts 的数量和类型（包括 harts 支持的特权模式）、内存和 I/O 区域的可访问性及属性、每个 hart 执行的所有合法指令的行为（即 ISA 是 EEI 的一个组成部分），以及在执行过程中引发的任何中断或异常（包括环境调用）的处理方式。EEI 的例子包括 Linux 应用程序二进制接口（ABI）或 RISC-V 监督二进制接口（SBI）。RISC-V 执行环境的实现可以是纯硬件、纯软件，或硬件与软件的结合。例如，可以使用操作码陷阱和软件仿真来实现硬件未提供的功能。执行环境实现的示例如下：

* 裸机（Bare metal）硬件平台：在这种环境中，harts 直接由物理处理器线程实现，指令可以完全访问物理地址空间。硬件平台定义了一个从上电复位（power-on reset）开始的执行环境。
* RISC-V 操作系统：这些操作系统通过将用户级 harts 多路复用到可用的物理处理器线程上，并通过虚拟内存控制对内存的访问，提供多个用户级执行环境。
* RISC-V 虚拟机监控器（Hypervisor）：虚拟机监控器为客户（guest）操作系统提供多个监督级执行环境。
* RISC-V 仿真器：例如 Spike、QEMU 或 rv8，这些仿真器在底层 x86 系统上仿真 RISC-V 的 harts，可以提供用户级或监督级执行环境。

[TIP]
====
裸硬件平台可以被视为定义了一个执行环境接口（EEI），其中可访问的 harts、内存和其他设备构成了环境，其初始状态为上电复位时的状态。通常，大多数软件被设计为使用更抽象的硬件接口，因为更抽象的 EEI 提供了跨硬件平台的更大可移植性。通常，EEI 会层层叠加，较高层的 EEI 使用较低层的 EEI。
====
(((hart, execution environment)))
从运行在特定执行环境中的软件视角来看，hart 是一种资源，它可以在该执行环境中自主获取并执行 RISC-V 指令。从这个意义上讲，hart 的行为类似于硬件线程资源，即使它在执行环境中通过时间复用方式运行在真实硬件上。一些 EEI 支持创建和销毁额外的 harts，例如通过环境调用来派生（fork）新的 harts。

执行环境负责确保其每个 hart 最终能够持续进展（forward progress）。对于特定的 hart，当它执行某种显示等待事件的机制时（例如本规范第二卷中定义的“等待中断”（wait-for-interrupt）指令），这一责任会暂时中止；当 hart 被终止时，这一责任则结束。以下事件构成了持续进展的标志：

* 一条指令的退休（retirement）。
* 一个陷阱（trap），如<<trap-defn, Section 1.6>>中定义的内容.
* 任何由扩展的，构成持续进展的其他事件。

[TIP]
====
术语 hart 最早在 Lithe 的研究中引入 cite:[lithe-pan-hotpar09] 和 cite:[lithe-pan-pldi10]，用来表示一种抽象的执行资源，而不是软件线程的编程抽象。（译注：hart 在手册的其它部分将被翻译成硬件线程）

硬件线程（hart）与软件线程上下文之间的重要区别在于，运行在执行环境中的软件不需要负责促使每个 hart 继续运行；这由外部执行环境负责。因此，从执行环境内的软件的视角来看，环境提供的 harts 就像硬件线程一样运行。

一个执行环境的实现可能会通过时间复用（time-multiplexing）将一组客户 harts 映射到更少的由其自身执行环境提供的宿主 harts 上，但必须以一种使客户 harts 像独立硬件线程一样运行的方式进行。特别地，如果客户 harts 的数量多于宿主 harts，则执行环境必须能够抢占（preempt）客户 harts，而不能无限期地等待运行在某个客户 hart 上的软件“释放”对该客户 hart 的控制权。
====

=== RISC-V ISA 概述


RISC-V ISA 定义为一个基础整数 ISA，任何实现中都必须包含该基础部分，并可以根据需要添加可选的扩展。RISC-V 的基础整数 ISA 与早期的 RISC 处理器非常相似，区别在于没有分支延迟槽，并支持可选的可变长度指令编码。基础 ISA 被精心限制为一组最小化的指令集，这些指令足以为编译器、汇编器、链接器和操作系统（包括额外的特权操作）提供合适的基础，同时作为一个方便的 ISA 和软件工具链的“骨架”，可以围绕其构建更多定制化的处理器 ISA。

尽管我们通常谈论“RISC-V ISA”，但实际上，RISC-V 是一组相关 ISA 的家族，目前包含四种基础 ISA。每个基础整数指令集的特点在于整数寄存器的宽度、对应的地址空间大小以及整数寄存器的数量。主要有两种基础整数变体：RV32I 和 RV64I，分别提供 32 位和 64 位地址空间，具体描述见 <<rv32>> 和 <<rv64>>。我们使用术语 XLEN 来指代整数寄存器的宽度（以位为单位，取值为 32 或 64）。<<rv32e, 第 6 章>> 描述了 RV32E 和 RV64E，这些是 RV32I 和 RV64I 基础指令集的子集变体，它们的整数寄存器的数量减半，设计用于支持小型微控制器。<<rv128, 第 8 章>> 概述了未来的 RV128I 基础整数指令集变体，该变体支持平坦的 128 位地址空间（XLEN=128）。基础整数指令集使用二进制补码（two's complement）表示有符号整数值。


[TIP]
====
虽然64位地址空间对于更大系统是必要的，但我们认为32位地址空间在未来几十年内仍然足够满足许多嵌入式设备和客户端设备的需求，并且对于降低内存流量和能耗来说更具优势。此外，32位地址空间对于教学目的来说也足够。未来可能需要更大的128位平坦地址空间，因此我们确保RISC-V ISA框架能够支持这一需求。
====

[NOTE]
====
RISC-V 中的四种基础 ISA 被视为独立的基础 ISA。一个常见的问题是：为什么不设计成单一的 ISA？尤其是，为什么 RV32I 不是 RV64I 的严格子集？一些早期的 ISA 设计（例如 SPARC、MIPS）采用了严格的超集策略，以便在扩展地址空间支持新 64 位硬件时能够运行现有的 32 位二进制程序。

显式分离基础 ISA 的主要优势在于，每个基础 ISA 都可以针对自身需求进行优化，而无需支持其他基础 ISA 所需的所有操作。例如，RV64I 可以省略仅用于应对 RV32I 中较窄寄存器的指令和 CSR，而 RV32I 变体则可以利用本来保留给宽地址空间变体指令的编码空间。

不将设计视为单一 ISA 的主要缺点是，在一种基础 ISA 上模拟另一种基础 ISA（例如在 RV64I 上模拟 RV32I）会增加硬件复杂性。然而，由于地址和非法指令异常处理的差异，即使采用完整的超集指令编码，硬件仍然需要某种模式切换。此外，不同的 RISC-V 基础 ISA 十分相似，因此支持多个版本的成本相对较低。尽管有人提出，严格超集设计可以让遗留的 32 位库与 64 位代码进行链接，但实际上，由于软件调用约定和系统调用接口的差异，即使编码兼容，这种方式在实践中也是不可行的。

RISC-V 特权架构在 `misa` 寄存器中提供了字段，用于控制每个级别上的非特权 ISA，从而支持在同一硬件上模拟不同的基础 ISA。值得注意的是，更新版本的 SPARC 和 MIPS ISA 修订版已不再支持 64 位系统上运行未修改的 32 位代码。

实际上，ADDW 操作码可以用于 RV32I 中的 32 位加法，而 ADDD 操作码可以用于 RV64I 中的 64 位加法，这样就可以替代当前的设计：在 RV32I 中使用相同的 ADD 操作码进行 32 位加法，在 RV64I 中用不同的 ADDW 操作码进行 32 位加法。这样做会更加一致，类似于 RV32I 和 RV64I 中 32 位加载指令都使用相同的 LW 操作码。RISC-V ISA 的最初版本确实采用了这种替代设计，但在 2011 年 1 月，RISC-V 的设计被修改为当前的选择。我们的重点是支持 64 位 ISA 中的 32 位整数，而不是提供与 32 位 ISA 的兼容性，动机是消除由于并非所有 RV32I 操作码都带有 *W 后缀（例如，ADDW，但 AND 没有 ANDW）而产生的不对称性。事后来看，这种设计可能并不完全合理，主要是因为两种 ISA 是同时进行设计的，而不是一个在另一个基础上添加。同时我们也认为必须将平台需求纳入 ISA 规范，这意味着 RV64I 中必须支持所有 RV32I 指令。现在已经为时过晚无法更改编码，但基于上述原因，这对实际应用几乎没有影响。

有观点认为，可以将 *W 变体作为扩展启用到 RV32I 系统中，从而在 RV64I 和未来的 RV32 变体之间提供统一的编码。
====

RISC-V 被设计为支持广泛的定制化和专用化。每个基础整数 ISA 都可以通过一个或多个可选的指令集扩展来进行扩展。扩展可以分为三类：标准扩展、自定义扩展和不符合规范的扩展。为此，我们将每个 RISC-V 指令集编码空间（以及相关的编码空间，例如 CSR）划分为三个不相交的类别：标准编码、保留编码和自定义编码。标准扩展和编码由 RISC-V 国际组织定义；任何未由 RISC-V 国际组织定义的扩展均为非标准扩展。每个基础 ISA 及其标准扩展仅使用标准编码，并且在使用这些编码时相互不冲突。保留编码当前未定义，但保留用于未来的标准扩展；一旦被使用，它们将成为标准编码。自定义编码永远不会用于标准扩展，而是提供给特定厂商的非标准扩展使用。非标准扩展可以是只使用自定义编码的自定义扩展，或者是使用任何标准或保留编码的不符合规范的扩展。指令集扩展通常是共享的，但可能根据基础 ISA 提供略微不同的功能。<<extending>> 描述了扩展 RISC-V ISA 的各种方法。此外，我们还制定了 RISC-V 基础指令和指令集扩展的命名规范，具体描述请参见 <<naming>>。

为了支持更广泛的通用软件开发，定义了一组标准扩展，以提供整数乘法/除法、原子操作以及单精度和双精度浮点运算。基础整数 ISA 被命名为 “I”（根据整数寄存器宽度加上 RV32 或 RV64 前缀），包含整数计算指令、整数加载、整数存储和控制流指令。标准整数乘法和除法扩展命名为 “M”，增加了在整数寄存器中进行乘法和除法操作的指令。标准原子指令扩展，记为 “A”，增加了用于多处理器同步的原子性读取、修改和写入内存的指令。标准单精度浮点扩展，记为 “F”，增加了浮点寄存器、单精度计算指令以及单精度加载和存储。标准双精度浮点扩展，记为 “D”，扩展了浮点寄存器，并增加了双精度计算指令、加载和存储。标准 “C” 压缩指令扩展提供了常用指令的更窄的 16 位形式。

除了基础整数 ISA 及这些标准扩展之外，我们认为很少有新的指令能够对所有应用程序提供显著的优势，但它可能对某些特定领域非常有益。随着对能效要求日益提高而促使更大程度的专用化，我们认为简化 ISA 规范中必需的部分非常重要。与而其他架构通常将其 ISA 视为一个整体，随着时间的推移不断添加新指令而发布新版本；而 RISC-V 力求保持基础 ISA 和每个标准扩展的稳定性，新增指令则作为额外的可选扩展逐层添加。例如，基础整数 ISA 将始终作为独立的、完全支持的 ISA存在，不受后续扩展影响。

=== 内存

RISC-V 的一个 hart 拥有一个单字节可寻址的地址空间，大小为 latexmath:[$2^{\text{XLEN}}$] 字节，用于所有内存访问。内存中的一个 字（word）被定义为 32 位（4 字节）。相应地，半字（halfword）为 16 位（2 字节），双字（doubleword）为 64 位（8 字节），四字（quadword）为 128 位（16 字节）。内存地址空间是循环的，因此地址为 latexmath:[$2^{\text{XLEN}}-1$] 的字节与地址为 0 的字节相邻。因此，硬件执行的内存地址计算会忽略溢出，并以 latexmath:[$2^{\text{XLEN}}$] 为模进行循环。

执行环境决定硬件资源在 hart 地址空间中的映射。hart 地址空间的不同地址范围可能：(1) 空置，(2) 包含主存，或 (3) 包含一个或多个I/O 设备。对 I/O 设备的读写可能会产生可见的副作用，而对主存的访问则不会。尽管执行环境可以将 hart 地址空间中的所有内容都视为 I/O 设备，但通常期望将一部分地址范围指定为主存。

当一个 RISC-V 平台包含多个 hart 时，任意两个 hart 的地址空间可以完全相同、也可以是完全不同，或者部分不同但共享某些资源，这些资源可以映射到相同或不同的地址范围中。

[TIP]
====
对于一个完全的“裸机”环境，所有的 harts 可能会看到相同的地址空间，并完全通过物理地址进行访问。然而，当执行环境包含一个使用地址转换的操作系统时，通常每个 hart 会被分配一个几乎完全独立的虚拟地址空间。
====
(((memory access, implicit and explicit)))
每条 RISC-V 机器指令的执行都涉及一个或多个内存访问，这些访问分为隐式和显式两类。对于每条被执行的指令，都会进行一次隐式内存读取（指令取值，或简称为取指）以获取要执行的编码指令。许多 RISC-V 指令在指令取值之外不再进行额外的内存访问。特定的加载（load）和存储（store）指令会显式地读取或写入由指令确定地址的内存。执行环境可能要求，指令执行期间除了无特权 ISA 文档中记录的内容外，还进行其他隐式内存访问（例如地址转换的实现）。

执行环境决定了非空闲地址空间的哪些部分可以用于哪种或哪些类型的内存访问。例如，指令取值可以隐式读取的地址范围可能与加载指令显式读取的地址范围完全不同；而存储指令可以显式写入的地址范围可能只是可读取地址范围的一个子集。通常，如果一条指令试图访问一个不可访问的地址，则会引发该指令的异常。地址空间中的空白位置永远不可访问。

除非另有说明，否则不会引发异常且无副作用的隐式读取可以在任意时刻提前执行和推测性发生，甚至机器在逻辑上还无法确定是否需要该读取。例如，一个合法的实现可以在尽早的时机尝试读取整个主存，将尽可能多的可取值（可执行）字节缓存起来以供后续指令取值使用，并避免为指令取值再次读取主存。为了确保某些隐式读取在写入同一内存位置之后才进行，软件必须执行为此目的定义的特定屏障（fence）或缓存控制指令（例如 <<zifencei>> 中定义的 FENCE.I 指令）。
(((memory access, implicit and explicit)))

一个 hart 执行的内存访问（隐式或显式）在其他 hart 或可以访问相同内存的任何其他代理看来，可能呈现出不同的顺序。然而，这种感知到的内存访问重排序始终受到适用的内存一致性模型的约束。RISC-V 的默认内存一致性模型是 RISC-V 弱内存排序（RVWMO），其定义见 <<memorymodel>> 及相关附录。作为选择，一个实现可以采用更强的完全存储排序模型（Total Store Ordering），定义见 <<ztso>>。执行环境也可能增加额外的限制，进一步约束内存访问的感知重排序。由于 RVWMO 模型是所有 RISC-V 实现允许的最弱模型，为此模型编写的软件与所有 RISC-V 实现的实际内存一致性规则兼容。与隐式读取一样，软件必须执行屏障或缓存控制指令，以确保超出默认内存一致性模型和执行环境要求的内存访问顺序。

=== 基础指令长度编码

基础 RISC-V ISA 使用固定长度的 32 位指令，这些指令必须自然对齐到 32 位边界。然而，标准 RISC-V 编码方案旨在支持具有可变长度指令的 ISA 扩展，其中每条指令可以由任意数量的 16 位指令段（parcels）组成，而这些段自然对齐到 16 位边界。<<compressed>> 中描述的标准压缩 ISA 扩展通过提供压缩的 16 位指令来减少代码大小，并放宽对齐约束，允许所有指令（16 位和 32 位）对齐到任意 16 位边界，从而提升代码密度。

我们使用术语 IALIGN（以位为单位）来表示实现强制执行的指令地址对齐约束。在基础 ISA 中，IALIGN 是 32 位，但某些 ISA 扩展（包括压缩 ISA 扩展）将 IALIGN 放宽到 16 位。IALIGN 仅允许取值 16 或 32。
(((ILEN)))

我们使用术语 ILEN（以位为单位）来表示实现支持的最大指令长度，并且该值始终是 IALIGN 的倍数。对于仅支持基础指令集的实现，ILEN 是 32 位。支持更长指令的实现会有更大的 ILEN 值。

<<instlengthcode>> 展示了标准 RISC-V 指令长度编码约定。基础 ISA 中的所有 32 位指令的最低两位被设置为 11。可选的压缩 16 位指令集扩展的最低两位为 00、01 或 10。

==== 扩展指令长度编码
一部分 32 位指令编码空间已被暂时分配用于长度超过 32 位的指令。目前，这部分空间完全保留，而以下针对超过 32 位指令的编码提案尚未冻结。
(((instruction length encoding)))

标准的指令集扩展采用超过 32 位的编码时，附加的低位会被设置为 1，其中 48 位和 64 位长度的编码约定如 <<instlengthcode>> 所示。指令长度在 80 位到 176 位之间的编码使用位 [14:12] 的 3 位字段来表示比初始的 5latexmath:[$\times$]16 位字多出的 16 位字的数量。位 [14:12] 设置为 "111" 的编码保留用于未来更长指令的编码。

[[instlengthcode, Table 1]]
.RISC-V 指令长度编码

.RISC-V 指令长度编码。当前仅冻结了 16 位和 32 位编码。
[%autowidth,cols="^2,^2,^3,^3,<4"]
|===
||||xxxxxxxxxxxxxxaa |16-bit (aa&#8800;11)

|||xxxxxxxxxxxxxxxx |xxxxxxxxxxxbbb11 |32-bit (bbb&#8800;111)

||latexmath:[$\cdot\cdot\cdot$]xxxx |xxxxxxxxxxxxxxxx
|xxxxxxxxxx011111 |48-bit

||latexmath:[$\cdot\cdot\cdot$]xxxx |xxxxxxxxxxxxxxxx
|xxxxxxxxx0111111 |64-bit

||latexmath:[$\cdot\cdot\cdot$]xxxx |xxxxxxxxxxxxxxxx
|xnnnxxxxx1111111 |(80+16*nnn)-bit, nnn&#8800;111

||latexmath:[$\cdot\cdot\cdot$]xxxx |xxxxxxxxxxxxxxxx
|x111xxxxx1111111 |Reserved for &#8805;192-bits

|Byte Address: >|base+4 >|base+2 >|base |
|===

[NOTE]
====
考虑到压缩格式在代码大小和能效上的优势，我们希望将对压缩格式的支持内建到 ISA 编码方案中，而不是事后补充。但为了简化实现，我们不想强制要求使用压缩格式。我们还希望可以选择性地支持更长的指令，以便于支持实验和更大的指令集扩展。尽管我们的编码约定要求对核心 RISC-V ISA 进行更紧凑的编码，但这带来了多个有利的效果。
(((IMAFD)))

对于标准 IMAFD ISA 的实现，指令缓存中只需存储指令的最高 30 位（节省 6.25%）。在指令缓存重新填充时，任何遇到的低位清零的指令都应在存储到缓存之前被重新编码为非法的 30 位指令，以保留非法指令的异常行为。

或许更重要的是，通过将基础 ISA 压缩到 32 位指令字的一个子集，我们为非标准和自定义扩展留出了更多的编码空间。具体来说，基础 RV32I ISA 在 32 位指令字中使用的编码空间不到 1/8。如 <<extending>> 所述，对于不需要支持标准压缩指令扩展的实现，可以将 3 个额外的不符合规范的 30 位指令空间映射到 32 位固定宽度格式，同时保留对标准 ≥32 位指令集扩展的支持。此外，如果实现也不需要支持超过 32 位的指令长度，还可以额外恢复 4 个主操作码供不符合规范的扩展使用。
====

所有位 [15:0] 都为零的编码被定义为非法指令。这些指令被认为是最小长度：如果存在任何 16 位指令集扩展，则为 16 位；否则为 32 位。位 [ILEN-1:0] 全为 1 的编码同样是非法的；该指令被视为是 ILEN 位长的指令。

[TIP]
====
我们认为，任何全零位的指令长度被定义为非法是一种特性，因为它可以快速捕获跳转到全零内存区域的错误跳转。同样，我们也将全 1 位的指令编码保留为非法指令，以捕获未编程的非易失性存储设备、断开连接的内存总线或损坏的内存设备中这些常见的模式。

软件可以依赖于一个自然对齐的 32 位全零字，在所有 RISC-V 实现上将其视为非法指令，以在需要显式非法指令的情况下使用。为全一位定义对应的非法值更为困难，因为存在可变长度编码。软件通常不能使用 ILEN 位全为 1 的非法值，因为软件可能无法确定最终目标机器的 ILEN（例如，当软件被编译为供多种不同机器使用的标准二进制库时）。我们曾考虑定义一个 32 位全一字为非法，因为所有机器都必须支持 32 位指令长度，但这会要求在 ILEN > 32 的机器上，指令取值单元在此类指令位于保护边界时报告非法指令异常，而不是访问错误异常，从而复杂化了可变指令长度的取值和解码。
====
(((endian, little and big)))
RISC-V 基础 ISA 支持小端序（little-endian）或大端序（big-endian）内存系统，而特权架构进一步定义了双端序操作（bi-endian）。无论内存系统的字节序如何，指令都以 16 位小端格式段的形式（parcels）存储在内存中。这些段组成一条指令，并按增加的半字地址存储，其中最低地址的段包含指令规格中最低编号的位。
(((bi-endian)))
(((endian, bi-)))

[TIP]
====
我们最初为 RISC-V 内存系统选择小端字节序，是因为目前小端系统在商业上占主导地位（例如所有 x86 系统，以及 iOS、Android 和 Windows 的 ARM 系统）。一个小细节是，我们还发现小端序内存系统对硬件设计者来说更为自然。然而，某些应用领域（例如 IP 网络）操作的是大端序数据结构，而某些遗留代码库是基于大端序处理器构建的，因此我们为 RISC-V 定义了大端序和双端序变体。

我们必须固定指令段在内存中的存储顺序，与内存系统的字节序无关，以确保长度编码位始终在半字地址顺序中首先出现。这使得指令取值单元只需检查第一条 16 位指令段的前几位即可快速确定可变长度指令的长度。

此外，我们将指令段本身设计为小端，以完全将指令编码与内存系统的字节序解耦。这种设计对软件工具和双端硬件都有好处。例如，如果不这么做，RISC-V 的汇编器或反汇编器将始终需要知道当前活动的字节序模式，即使在双端系统中，这种模式可能会在执行期间动态改变。相比之下，通过为指令指定固定的字节序，有时可以使经过仔细编写的软件即使在二进制形式下也不依赖字节序，就像位置无关代码一样。

然而，选择仅支持小端序的指令确实会对 RISC-V 软件带来一些影响，特别是涉及对机器指令进行编码或解码的情况。例如，大端序的即时编译器（JIT）在将指令存储到指令内存时必须交换字节顺序。

当我们决定采用小端的指令编码时，这自然导致将长度编码位放在指令格式的最低有效位（LSB）位置，以避免破坏操作码字段。
====

[[trap-defn]]
=== 异常、陷阱和中断

我们使用术语“异常”（exception）来指代当前 RISC-V hart 中与指令相关联的运行时异常情况。使用术语“中断”（interrupt）指代外部的异步事件，它可能导致 RISC-V hart 发生意外的控制转移。使用术语“陷阱”（trap）指代由异常或中断引发的控制转移到陷阱处理程序的过程。
(((exceptions)))
(((traps)))
(((interrupts)))

以下章节中的指令描述说明了执行过程中可能引发异常的条件。在大多数 RISC-V 执行环境接口（EEI）中，当指令上触发异常信号时，通常会触发陷阱并跳转到相应的处理程序（标准浮点扩展中的浮点异常除外，这些异常不会引发陷阱）。而中断的生成、路由和启用的方式取决于具体的 EEI 实现。

[NOTE]
====
我们对“异常”和“陷阱”的使用与 IEEE-754 浮点标准中的定义兼容。
====

陷阱的处理方式及其对运行在 hart 上的软件的可见性取决于所处的执行环境。从运行在某个执行环境中的软件角度来看，hart 在运行时遇到的陷阱可能有以下四种效果：

受控陷阱（Contained Trap）:::
  陷阱对运行在执行环境内的软件可见，并由其处理。例如，在一个提供 supervisor 模式和 user 模式的 EEI 中，user 模式 hart 的 ECALL 通常会导致控制转移到在同一 hart 上运行的 supervisor 模式处理程序。同样，在相同的环境中，当 hart 被中断时，中断处理程序将在 hart 的 supervisor 模式下运行。
请求陷阱（Requested Trap）:::
  这种陷阱是一个同步异常，明确请求执行环境为执行环境内的软件执行某项操作。例如，系统调用（system call）就是一个例子。在这种情况下，请求操作完成后，执行可能会也可能不会在 hart 上恢复。例如，一个系统调用可能移除该 hart，或导致整个执行环境的有序终止。
隐性陷阱（Invisible Trap）:::
  陷阱由执行环境透明处理，处理完成后执行正常恢复。例子包括模拟缺失的指令、在按需分页虚拟内存系统中处理非驻留页面错误，或在多任务机器中处理其他作业的设备中断。在这些情况下，运行在执行环境内的软件不会意识到陷阱的发生（在这些定义中忽略了时序影响）。
致命陷阱（Fatal Trap）:::
  陷阱代表致命失败，导致执行环境终止执行。例如，未通过虚拟内存页面保护检查，或允许看门狗计时器超时。每个 EEI 应定义如何终止执行以及如何向外部环境报告。

<<trapcharacteristics>> 显示了每种陷阱的特性。

[[trapcharacteristics, Table 2]]

[%autowidth,float="center",align="center",cols="<,^,^,^,^",options="header",]
|===
| |包含（Contained）|请求（Requested）|不可见（Invisible）|致命（Fatal）
|执行终止（Execution terminates）|No |No^1^|No |Yes
|软件无反应（Software is oblivious）|No |No |Yes |Yes^2^|环境处理（Handled by environment）|No |Yes |Yes |Yes
|===
<<trapcharacteristics>> 陷阱特性说明：1）执行终止可能是通过请求产生的。2）非精确的致命陷阱可能会被软件观察到。

EEI（执行环境接口）定义了每种陷阱是否需要精确处理，但建议尽可能保持精确性。在执行环境内部的软件中，受控陷阱和请求陷阱可能被观察为非精确的。根据定义，隐性陷阱无法被执行环境中的软件观察为精确或非精确的。如果已知错误的指令不会导致立即终止，执行环境内的软件可能观察到致命陷阱是非精确的。

由于本文档描述的是非特权指令，因此很少提及陷阱。用于处理受控陷阱的架构方法在特权架构手册中定义，同时还包括支持更丰富 EEI 的其他特性。专门为了引发请求陷阱而定义的非特权指令会在本文档中记录。隐性陷阱根据其性质不在本文档范围内。未在本文档中定义或通过其他方式未定义的指令编码可能会引发致命陷阱。

=== UNSPECIFIED 的行为和值
架构全面描述了实现中必须遵守的内容以及任何可能的约束。在某些情况下，架构有意不约束实现，此时会明确使用术语未指定（UNSPECIFIED）。
(((unspecified, behaviors)))
(((unspecified, values)))

术语 UNSPECIFIED 指的是有意不加约束的行为或数值。这些行为或数值的定义可以由扩展、平台标准或具体实现来确定。扩展、平台标准或实现文档可以提供规范性内容，以进一步约束基本架构定义为 UNSPECIFIED 的情况。

与基本架构类似，扩展应完全描述允许的行为和数值，并在有意不约束的情况下使用术语 UNSPECIFIED。这些未约束的情况可以由其他扩展、平台标准或具体实现进一步约束或定义。
